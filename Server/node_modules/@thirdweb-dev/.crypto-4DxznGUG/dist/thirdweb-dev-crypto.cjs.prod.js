'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var sha256$1 = require('@noble/hashes/sha256');
var jsSha3 = require('js-sha3');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

class TextProcessorCache {
  get encoder() {
    if (!this._encoder) {
      this._encoder = new TextEncoder();
    }
    return this._encoder;
  }
  get decoder() {
    if (!this._decoder) {
      this._decoder = new TextDecoder();
    }
    return this._decoder;
  }
}

// create a singleton instance of the TextProcessorCache
const textProcessorSingleton = new TextProcessorCache();
function getCachedTextEncoder() {
  return textProcessorSingleton.encoder;
}
function getCachedTextDecoder() {
  return textProcessorSingleton.decoder;
}

// stripped down version of `js-md5`
// changes:
// - we know we always have ArrayBuffer available
// - we only care about `arrayBuffer` output
// - we want to behave the same regardless of NODE or non NODE env
// - transformed into class
// - typescript

/**
 * [js-md5]{@link https://github.com/emn178/js-md5}
 *
 * @namespace md5
 * @version 0.8.3
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2023
 * @license MIT
 */

const INPUT_ERROR = "input is invalid type";
const FINALIZE_ERROR = "finalize already called";
const EXTRA = [128, 32768, 8388608, -2147483648];

// [message: string, isString: bool]
function formatMessage(message) {
  const type = typeof message;
  if (typeof message === "string") {
    return [message, true];
  }
  if (type !== "object" || message === null) {
    throw new Error(INPUT_ERROR);
  }
  if (message instanceof ArrayBuffer) {
    return [new Uint8Array(message), false];
  }
  if (!Array.isArray(message) && !ArrayBuffer.isView(message)) {
    throw new Error(INPUT_ERROR);
  }
  return [message, false];
}

/**
 * Md5 class
 * @class Md5
 * @description This is internal class.
 * @see {@link md5.create}
 */
class Md5 {
  lastByteIndex = 0;
  constructor() {
    // eslint-disable-next-line @typescript-eslint/no-shadow
    const buffer = new ArrayBuffer(68);
    this.buffer8 = new Uint8Array(buffer);
    this.blocks = new Uint32Array(buffer);
    this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0;
    this.finalized = this.hashed = false;
    this.first = true;
  }
  /**
   * @method update
   * @memberof Md5
   * @instance
   * @description Update hash
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {Md5} Md5 object.
   * @see {@link md5.update}
   */
  update(inputMessage) {
    if (this.finalized) {
      throw new Error(FINALIZE_ERROR);
    }
    const [message, isString] = formatMessage(inputMessage);
    const blocks = this.blocks;
    let length = 0;
    if (ArrayBuffer.isView(message)) {
      length = message.byteLength;
    } else {
      length = message.length;
    }
    let code,
      index = 0,
      i;

    // eslint-disable-next-line @typescript-eslint/no-shadow
    const buffer8 = this.buffer8;
    while (index < length) {
      if (this.hashed) {
        this.hashed = false;
        blocks[0] = blocks[16];
        blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      }
      if (isString) {
        for (i = this.start; index < length && i < 64; ++index) {
          code = message.charCodeAt(index);
          if (code < 0x80) {
            buffer8[i++] = code;
          } else if (code < 0x800) {
            buffer8[i++] = 0xc0 | code >>> 6;
            buffer8[i++] = 0x80 | code & 0x3f;
          } else if (code < 0xd800 || code >= 0xe000) {
            buffer8[i++] = 0xe0 | code >>> 12;
            buffer8[i++] = 0x80 | code >>> 6 & 0x3f;
            buffer8[i++] = 0x80 | code & 0x3f;
          } else {
            code = 0x10000 + ((code & 0x3ff) << 10 | message.charCodeAt(++index) & 0x3ff);
            buffer8[i++] = 0xf0 | code >>> 18;
            buffer8[i++] = 0x80 | code >>> 12 & 0x3f;
            buffer8[i++] = 0x80 | code >>> 6 & 0x3f;
            buffer8[i++] = 0x80 | code & 0x3f;
          }
        }
      } else {
        for (i = this.start; index < length && i < 64; ++index) {
          // at this point we know it's not a string
          buffer8[i++] = message[index];
        }
      }
      this.lastByteIndex = i;
      this.bytes += i - this.start;
      if (i >= 64) {
        this.start = i - 64;
        this.hash();
        this.hashed = true;
      } else {
        this.start = i;
      }
    }
    if (this.bytes > 4294967295) {
      this.hBytes += this.bytes / 4294967296 << 0;
      this.bytes = this.bytes % 4294967296;
    }
    return this;
  }
  finalize() {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    // eslint-disable-next-line @typescript-eslint/no-shadow
    const blocks = this.blocks,
      i = this.lastByteIndex;
    blocks[i >>> 2] |= EXTRA[i & 3];
    if (i >= 56) {
      if (!this.hashed) {
        this.hash();
      }
      blocks[0] = blocks[16];
      blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] =