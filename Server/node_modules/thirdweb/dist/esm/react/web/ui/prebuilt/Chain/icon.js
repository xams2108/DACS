"use client";
import { jsx as _jsx } from "react/jsx-runtime";
import { useQuery } from "@tanstack/react-query";
import { getChainMetadata } from "../../../../../chains/utils.js";
import { getFunctionId } from "../../../../../utils/function-id.js";
import { resolveScheme } from "../../../../../utils/ipfs.js";
import { useChainContext } from "./provider.js";
/**
 * This component tries to resolve the icon of a given chain, then return an image.
 * @returns an <img /> with the src of the chain icon
 *
 * @example
 * ### Basic usage
 * ```tsx
 * import { ChainProvider, ChainIcon } from "thirdweb/react";
 *
 * <ChainProvider chain={chain}>
 *   <ChainIcon />
 * </ChainProvider>
 * ```
 *
 * Result: An <img /> component with the src of the icon
 * ```html
 * <img src="chain-icon.png" />
 * ```
 *
 * ### Override the icon with the `iconResolver` prop
 * If you already have the icon url, you can skip the network requests and pass it directly to the ChainIcon
 * ```tsx
 * <ChainIcon iconResolver="/ethereum-icon.png" />
 * ```
 *
 * You can also pass in your own custom (async) function that retrieves the icon url
 * ```tsx
 * const getIcon = async () => {
 *   const icon = getIconFromCoinMarketCap(chainId, etc);
 *   return icon;
 * };
 *
 * <ChainIcon iconResolver={getIcon} />
 * ```
 *
 * ### Show a loading sign while the icon is being loaded
 * ```tsx
 * <ChainIcon loadingComponent={<Spinner />} />
 * ```
 *
 * ### Fallback to a dummy image if the chain icon fails to resolve
 * ```tsx
 * <ChainIcon fallbackComponent={<img src="blank-image.png" />} />
 * ```
 *
 * ### Usage with queryOptions
 * ChainIcon uses useQuery() from tanstack query internally.
 * It allows you to pass a custom queryOptions of your choice for more control of the internal fetching logic
 * ```tsx
 * <ChainIcon queryOptions={{ enabled: someLogic, retry: 3, }} />
 * ```
 *
 * @component
 * @chain
 * @beta
 */
export function ChainIcon({ iconResolver, loadingComponent, fallbackComponent, queryOptions, client, ...restProps }) {
    const { chain } = useChainContext();
    const iconQuery = useQuery({
        queryKey: getQueryKeys({ chainId: chain.id, iconResolver }),
        queryFn: async () => fetchChainIcon({ chain, client, iconResolver }),
        ...queryOptions,
    });
    if (iconQuery.isLoading) {
        return loadingComponent || null;
    }
    if (!iconQuery.data) {
        return fallbackComponent || null;
    }
    return _jsx("img", { src: iconQuery.data, ...restProps, alt: restProps.alt });
}
/**
 * @internal Exported for tests only
 */
export async function fetchChainIcon(props) {
    const { chain, client, iconResolver } = props;
    if (typeof iconResolver === "string") {
        return iconResolver;
    }
    if (typeof iconResolver === "function") {
        return iconResolver();
    }
    // Check if the chain object already has "icon"
    if (chain.icon?.url) {
        return resolveScheme({ uri: chain.icon.url, client });
    }
    const possibleUrl = await getChainMetadata(chain)
        .then((data) => data.icon?.url)
        .catch(() => undefined);
    if (!possibleUrl) {
        throw new Error("Failed to resolve icon for chain");
    }
    return resolveScheme({ uri: possibleUrl, client });
}
/**
 * @internal
 */
export function getQueryKeys(props) {
    const { chainId, iconResolver } = props;
    return [
        "_internal_chain_icon_",
        chainId,
        {
            resolver: typeof iconResolver === "string"
                ? iconResolver
                : typeof iconResolver === "function"
                    ? getFunctionId(iconResolver)
                    : undefined,
        },
    ];
}
//# sourceMappingURL=icon.js.map