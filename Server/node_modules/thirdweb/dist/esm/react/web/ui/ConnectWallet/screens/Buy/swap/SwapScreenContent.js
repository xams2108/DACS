import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { useQuery } from "@tanstack/react-query";
import { useState } from "react";
import { trackPayEvent } from "../../../../../../../analytics/track/pay.js";
import { getCachedChain } from "../../../../../../../chains/utils.js";
import { NATIVE_TOKEN_ADDRESS } from "../../../../../../../constants/addresses.js";
import { getContract } from "../../../../../../../contract/contract.js";
import { allowance } from "../../../../../../../extensions/erc20/__generated__/IERC20/read/allowance.js";
import { formatNumber } from "../../../../../../../utils/formatNumber.js";
import { useWalletBalance } from "../../../../../../core/hooks/others/useWalletBalance.js";
import { useBuyWithCryptoQuote } from "../../../../../../core/hooks/pay/useBuyWithCryptoQuote.js";
import { getErrorMessage } from "../../../../../utils/errors.js";
import { Drawer, DrawerOverlay, useDrawer, } from "../../../../components/Drawer.js";
import { Spacer } from "../../../../components/Spacer.js";
import { Spinner } from "../../../../components/Spinner.js";
import { SwitchNetworkButton } from "../../../../components/SwitchNetwork.js";
import { Container } from "../../../../components/basic.js";
import { Button } from "../../../../components/buttons.js";
import { Text } from "../../../../components/text.js";
import { TokenSymbol } from "../../../../components/token/TokenSymbol.js";
import { isNativeToken } from "../../nativeToken.js";
import { EstimatedTimeAndFees } from "../EstimatedTimeAndFees.js";
import { SwapFees } from "./Fees.js";
import { PayWithCryptoQuoteInfo } from "./PayWithCrypto.js";
export function SwapScreenContent(props) {
    const { setScreen, payer, client, toChain, tokenAmount, toToken, fromChain, fromToken, payOptions, disableTokenSelection, } = props;
    const defaultRecipientAddress = props.payOptions?.paymentInfo?.sellerAddress;
    const receiverAddress = defaultRecipientAddress || props.activeAccount.address;
    const { drawerRef, drawerOverlayRef, isOpen, setIsOpen } = useDrawer();
    const [drawerScreen, setDrawerScreen] = useState("fees");
    const fromTokenBalanceQuery = useWalletBalance({
        address: payer.account.address,
        chain: fromChain,
        tokenAddress: isNativeToken(fromToken) ? undefined : fromToken?.address,
        client,
    }, {
        enabled: !!fromChain && !!fromToken,
    });
    const fromTokenId = isNativeToken(fromToken)
        ? NATIVE_TOKEN_ADDRESS
        : fromToken?.address?.toLowerCase();
    const toTokenId = isNativeToken(toToken)
        ? NATIVE_TOKEN_ADDRESS
        : toToken.address.toLowerCase();
    const swapRequired = !!tokenAmount &&
        !!fromChain &&
        !!fromTokenId &&
        !(fromChain?.id === toChain.id && fromTokenId === toTokenId);
    const quoteParams = fromChain && fromToken && swapRequired
        ? {
            // wallets
            fromAddress: payer.account.address,
            toAddress: receiverAddress,
            // from
            fromChainId: fromChain.id,
            fromTokenAddress: isNativeToken(fromToken)
                ? NATIVE_TOKEN_ADDRESS
                : fromToken.address,
            // to
            toChainId: toChain.id,
            toTokenAddress: isNativeToken(toToken)
                ? NATIVE_TOKEN_ADDRESS
                : toToken.address,
            toAmount: tokenAmount,
            client,
            purchaseData: payOptions.purchaseData,
        }
        : undefined;
    const quoteQuery = useBuyWithCryptoQuote(quoteParams, {
        // refetch every 30 seconds
        staleTime: 30 * 1000,
        refetchInterval: 30 * 1000,
        gcTime: 30 * 1000,
    });
    const allowanceQuery = useQuery({
        queryKey: [
            "allowance",
            payer.account.address,
            quoteQuery.data?.approvalData,
        ],
        queryFn: () => {
            if (!quoteQuery.data?.approvalData) {
                return null;
            }
            return allowance({
                contract: getContract({
                    client: props.client,
                    address: quoteQuery.data.swapDetails.fromToken.tokenAddress,
                    chain: getCachedChain(quoteQuery.data.swapDetails.fromToken.chainId),
                }),
                spender: quoteQuery.data.approvalData.spenderAddress,
                owner: props.payer.account.address,
            });
        },
        enabled: !!quoteQuery.data?.approvalData,
        refetchOnMount: true,
    });
    const sourceTokenAmount = swapRequired
        ? quoteQuery.data?.swapDetails.fromAmount
        : tokenAmount;
    const isNotEnoughBalance = !!sourceTokenAmount &&
        !!fromTokenBalanceQuery.data &&
        Number(fromTokenBalanceQuery.data.displayValue) < Number(sourceTokenAmount);
    const disableContinue = !fromChain ||
        !fromToken ||
        (swapRequired && !quoteQuery.data) ||
        isNotEnoughBalance ||
        allowanceQuery.isLoading;
    const switchChainRequired = props.payer.wallet.getChain()?.id !== fromChain?.id;
    const errorMsg = !quoteQuery.isLoading && quoteQuery.error
        ? getErrorMessage(quoteQuery.error)
        : undefined;
    function showSwapFlow() {
        if ((props.payOptions.mode === "direct_payment" ||
            props.payOptions.mode === "fund_wallet") &&
            !isNotEnoughBalance &&
            !swapRequired) {
            // same currency, just direct transfer
            setScreen({
                id: "transfer-flow",
            });
        }
        else if (props.payOptions.mode === "transaction" &&
            !isNotEnoughBalance &&
            !swapRequired) {
            if (payer.account.address !== receiverAddress) {
                // needs transfer from another wallet before executing the transaction
                setScreen({
                    id: "transfer-flow",
                });
            }
            else {
                // has enough balance to just do the transaction directly
                props.onDone();
            }
            return;
        }
        if (!quoteQuery.data) {
            return;
        }
        setScreen({
            id: "swap-flow",
            quote: quoteQuery.data,
            approvalAmount: allowanceQuery.data ?? undefined,
        });
    }
    function showFees() {
        if (!quoteQuery.data) {
            return;
        }
        setIsOpen(true);
        setDrawerScreen("fees");
    }
    return (_jsxs(Container, { flex: "column", gap: "lg", animate: "fadein", children: [isOpen && (_jsxs(_Fragment, { children: [_jsx(DrawerOverlay, { ref: drawerOverlayRef }), _jsx(Drawer, { ref: drawerRef, close: () => setIsOpen(false), children: drawerScreen === "fees" && quoteQuery.data && (_jsxs("div", { children: [_jsx(Text, { size: "lg", color: "primaryText", children: "Fees" }), _jsx(Spacer, { y: "lg" }), _jsx(SwapFees, { quote: quoteQuery.data })] })) })] })), _jsxs(Container, { flex: "column", gap: "sm", children: [_jsxs(Container, { flex: "row", gap: "xxs", center: "y", children: [_jsx(Text, { size: "sm", children: "Pay with" }), fromToken && fromChain ? (_jsx(TokenSymbol, { token: fromToken, chain: fromChain, size: "sm", color: "secondaryText" })) : ("crypto")] }), _jsxs("div", { children: [_jsx(PayWithCryptoQuoteInfo, { value: sourceTokenAmount || "", chain: fromChain, token: fromToken, isLoading: quoteQuery.isLoading && !sourceTokenAmount, client: client, freezeChainAndTokenSelection: disableTokenSelection, payerAccount: props.payer.account, swapRequired: swapRequired, onSelectToken: props.showFromTokenSelector }), swapRequired && fromChain && fromToken && (_jsx(EstimatedTimeAndFees, { quoteIsLoading: quoteQuery.isLoading, estimatedSeconds: quoteQuery.data?.swapDetails.estimated.durationSeconds, onViewFees: showFees }))] }), errorMsg && (_jsx("div", { children: errorMsg.data?.minimumAmountEth ? (_jsxs(Text, { color: "danger", size: "xs", center: true, multiline: true, children: ["Minimum amount is", " ", formatNumber(Number(errorMsg.data.minimumAmountEth), 6), " ", _jsx(TokenSymbol, { token: toToken, chain: toChain, size: "sm", inline: true, color: "danger" })] })) : (_jsxs("div", { children: [_jsx(Text, { color: "danger", size: "xs", center: true, multiline: true, children: errorMsg.title }), _jsx(Text, { size: "xs", center: true, multiline: true, children: errorMsg.message })] })) })), !errorMsg && isNotEnoughBalance && (_jsxs("div", { children: [_jsx(Text, { color: "danger", size: "xs", center: true, multiline: true, children: "Insufficient Funds" }), _jsx(Text, { size: "xs", center: true, multiline: true, children: "Select another token or pay with card." })] }))] }), errorMsg?.data?.minimumAmountEth ? (_jsx(Button, { variant: "accent", fullWidth: true, onClick: () => {
                    props.setTokenAmount(formatNumber(Number(errorMsg.data?.minimumAmountEth), 6).toString());
                    props.setHasEditedAmount(true);
                }, children: "Set Minimum" })) : isNotEnoughBalance || errorMsg ? (_jsx(Button, { variant: "accent", fullWidth: true, onClick: () => props.showFromTokenSelector(), children: "Pay with another token" })) : switchChainRequired &&
                fromChain &&
                !quoteQuery.isLoading &&
                !allowanceQuery.isLoading &&
                !isNotEnoughBalance &&
                !quoteQuery.error ? (_jsx(SwitchNetworkButton, { variant: "accent", fullWidth: true, switchChain: async () => {
                    await props.payer.wallet.switchChain(fromChain);
                } })) : (_jsx(Button, { variant: disableContinue ? "outline" : "accent", fullWidth: true, "data-disabled": disableContinue, disabled: disableContinue, onClick: async () => {
                    if (!disableContinue) {
                        showSwapFlow();
                        trackPayEvent({
                            event: "confirm_swap_quote",
                            client: client,
                            walletAddress: payer.account.address,
                            walletType: payer.wallet.id,
                            chainId: fromChain.id,
                            fromToken: isNativeToken(fromToken)
                                ? undefined
                                : fromToken.address,
                            toChainId: toChain.id,
                            toToken: isNativeToken(toToken) ? undefined : toToken.address,
                        });
                    }
                }, gap: "xs", children: quoteQuery.isLoading ? (_jsxs(_Fragment, { children: ["Getting price quote", _jsx(Spinner, { size: "sm", color: "accentText" })] })) : ("Continue") }))] }));
}
//# sourceMappingURL=SwapScreenContent.js.map