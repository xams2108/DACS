import { prepareTransaction } from "../../../transaction/prepare-transaction.js";
import { computeContractAddress } from "../../../utils/any-evm/compute-published-contract-address.js";
import { computeDeploymentInfoFromMetadata } from "../../../utils/any-evm/compute-published-contract-deploy-info.js";
import { isContractDeployed } from "../../../utils/bytecode/is-contract-deployed.js";
import { getContract } from "../../contract.js";
import { fetchPublishedContractMetadata } from "../publisher.js";
import { computeCreate2FactoryAddress } from "./create-2-factory.js";
/**
 * Retrieves a deployed infrastructure contract instance for the specified contract ID
 * @param options - Configuration options for locating the infrastructure contract
 * @param options.client - ThirdwebClient instance
 * @param options.chain - Target blockchain network
 * @param options.contractId - Identifier for the infrastructure contract (e.g. "WETH9", "Forwarder")
 * @param options.constructorParams - Optional constructor parameters for contract initialization
 * @param options.publisher - Optional custom publisher address
 * @param options.version - Optional specific contract version to retrieve
 * @returns Promise that resolves to the contract instance if deployed, null otherwise
 *
 * @internal
 */
export async function getDeployedInfraContract(options) {
    const contractMetadata = await fetchPublishedContractMetadata({
        client: options.client,
        contractId: options.contractId,
        publisher: options.publisher,
        version: options.version,
    });
    return getDeployedInfraContractFromMetadata({
        client: options.client,
        chain: options.chain,
        contractMetadata,
        constructorParams: options.constructorParams,
    });
}
/**
 * @internal
 */
export async function getDeployedInfraContractFromMetadata(options) {
    const address = await computeContractAddress(options);
    const factory = getContract({
        ...options,
        address,
    });
    if (await isContractDeployed(factory)) {
        return factory;
    }
    return null;
}
/**
 * @internal
 */
export function prepareInfraContractDeployTransactionFromMetadata(options) {
    const { client, chain } = options;
    return prepareTransaction({
        client,
        chain,
        to: () => computeCreate2FactoryAddress({
            client,
            chain,
        }),
        data: async () => {
            const infraContractInfo = await computeDeploymentInfoFromMetadata(options);
            return infraContractInfo.initCalldata;
        },
    });
}
//# sourceMappingURL=infra.js.map