import { client, parsers } from "@passwordless-id/webauthn";
import { webLocalStorage } from "../../../../../utils/storage/webStorage.js";
import { base64ToString, base64UrlToBase64, } from "../../../../../utils/uint8-array.js";
import { ClientScopedStorage } from "../../../core/authentication/client-scoped-storage.js";
export class PasskeyWebClient {
    isAvailable() {
        return client.isAvailable();
    }
    async register(args) {
        const { name, challenge, rp } = args;
        const registration = await client.register({
            user: name,
            challenge,
            userVerification: "required",
            domain: rp.id,
            attestation: true,
        });
        const clientDataB64 = base64UrlToBase64(registration.response.clientDataJSON);
        const clientDataParsed = JSON.parse(base64ToString(clientDataB64));
        return {
            authenticatorData: registration.response.authenticatorData,
            credentialId: registration.id,
            clientData: registration.response.clientDataJSON,
            credential: {
                publicKey: registration.response.publicKey,
                algorithm: parsers.getAlgoName(registration.response.publicKeyAlgorithm),
            },
            origin: clientDataParsed.origin,
        };
    }
    async authenticate(args) {
        const { credentialId, challenge, rp } = args;
        const result = await client.authenticate({
            allowCredentials: credentialId ? [credentialId] : [],
            challenge,
            userVerification: "required",
            domain: rp.id,
        });
        const clientDataB64 = base64UrlToBase64(result.response.clientDataJSON);
        const clientDataParsed = JSON.parse(base64ToString(clientDataB64));
        return {
            authenticatorData: result.response.authenticatorData,
            credentialId: result.id,
            clientData: result.response.clientDataJSON,
            signature: result.response.signature,
            origin: clientDataParsed.origin,
        };
    }
}
/**
 * Returns whether this device has a stored passkey ready to be used for sign-in
 * @param client - the thirdweb client
 * @returns whether the device has a stored passkey
 * @walletUtils
 */
export async function hasStoredPasskey(client, ecosystemId, storage) {
    const clientStorage = new ClientScopedStorage({
        storage: storage ?? webLocalStorage, // TODO (passkey) react native variant of this fn
        clientId: client.clientId,
        ecosystem: ecosystemId ? { id: ecosystemId } : undefined,
    });
    const credId = await clientStorage.getPasskeyCredentialId();
    return !!credId;
}
//# sourceMappingURL=passkeys.js.map