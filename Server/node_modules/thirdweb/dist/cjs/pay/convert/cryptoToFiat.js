"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertCryptoToFiat = convertCryptoToFiat;
const addresses_js_1 = require("../../constants/addresses.js");
const get_bytecode_js_1 = require("../../contract/actions/get-bytecode.js");
const contract_js_1 = require("../../contract/contract.js");
const address_js_1 = require("../../utils/address.js");
const fetch_js_1 = require("../../utils/fetch.js");
const definitions_js_1 = require("../utils/definitions.js");
/**
 * Get a price of a token (using tokenAddress + chainId) in fiat.
 * Only USD is supported at the moment.
 * @example
 * ### Basic usage
 * For native token (non-ERC20), you should use NATIVE_TOKEN_ADDRESS as the value for `tokenAddress`
 * ```ts
 * import { convertCryptoToFiat } from "thirdweb/pay";
 *
 * // Get Ethereum price
 * const result = convertCryptoToFiat({
 *   fromTokenAddress: NATIVE_TOKEN_ADDRESS,
 *   to: "USD",
 *   chain: ethereum,
 *   fromAmount: 1,
 * });
 *
 * // Result: `{ result: 3404.11 }`
 * ```
 * @buyCrypto
 * @returns a number representing the price (in selected fiat) of "x" token, with "x" being the `fromAmount`.
 */
async function convertCryptoToFiat(options) {
    const { client, fromTokenAddress, to, chain, fromAmount } = options;
    if (Number(fromAmount) === 0) {
        return { result: 0 };
    }
    // Testnets just don't work with our current provider(s)
    if (chain.testnet === true) {
        throw new Error(`Cannot fetch price for a testnet (chainId: ${chain.id})`);
    }
    // Some provider that we are using will return `0` for unsupported token
    // so we should do some basic input validations before sending the request
    // Make sure it's a valid EVM address
    if (!(0, address_js_1.isAddress)(fromTokenAddress)) {
        throw new Error("Invalid fromTokenAddress. Expected a valid EVM contract address");
    }
    // Make sure it's either a valid contract or a native token address
    if (fromTokenAddress.toLowerCase() !== addresses_js_1.NATIVE_TOKEN_ADDRESS.toLowerCase()) {
        const bytecode = await (0, get_bytecode_js_1.getBytecode)((0, contract_js_1.getContract)({
            address: fromTokenAddress,
            chain,
            client,
        })).catch(() => undefined);
        if (!bytecode || bytecode === "0x") {
            throw new Error(`Error: ${fromTokenAddress} on chainId: ${chain.id} is not a valid contract address.`);
        }
    }
    const params = {
        fromTokenAddress,
        to,
        chainId: String(chain.id),
        fromAmount: String(fromAmount),
    };
    const queryString = new URLSearchParams(params).toString();
    const url = `${(0, definitions_js_1.getPayConvertCryptoToFiatEndpoint)()}?${queryString}`;
    const response = await (0, fetch_js_1.getClientFetch)(client)(url);
    if (!response.ok) {
        throw new Error(`Failed to fetch ${to} value for token (${fromTokenAddress}) on chainId: ${chain.id}`);
    }
    const data = await response.json();
    return data;
}
//# sourceMappingURL=cryptoToFiat.js.map