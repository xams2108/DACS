"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.autoConnectCore = void 0;
exports.handleWalletConnection = handleWalletConnection;
const timeoutPromise_js_1 = require("../../utils/timeoutPromise.js");
const is_ecosystem_wallet_js_1 = require("../ecosystem/is-ecosystem-wallet.js");
const client_scoped_storage_js_1 = require("../in-app/core/authentication/client-scoped-storage.js");
const is_in_app_signer_js_1 = require("../in-app/core/wallet/is-in-app-signer.js");
const get_url_token_js_1 = require("../in-app/web/lib/get-url-token.js");
const index_js_1 = require("../manager/index.js");
let lastAutoConnectionResultPromise = undefined;
/**
 * @internal
 */
const autoConnectCore = async (props) => {
    // if an auto connect was attempted already
    if (lastAutoConnectionResultPromise && !props.force) {
        // wait for its resolution
        const lastResult = await lastAutoConnectionResultPromise;
        // if it was successful, return true
        // if not continue with the new auto connect
        if (lastResult) {
            return true;
        }
    }
    const resultPromise = _autoConnectCore(props);
    lastAutoConnectionResultPromise = resultPromise;
    return resultPromise;
};
exports.autoConnectCore = autoConnectCore;
const _autoConnectCore = async ({ storage, props, createWalletFn, manager, connectOverride, getInstalledWallets, setLastAuthProvider, }) => {
    const { wallets, onConnect } = props;
    const timeout = props.timeout ?? 15000;
    let autoConnected = false;
    manager.isAutoConnecting.setValue(true);
    let [lastConnectedWalletIds, lastActiveWalletId] = await Promise.all([
        (0, index_js_1.getStoredConnectedWalletIds)(storage),
        (0, index_js_1.getStoredActiveWalletId)(storage),
    ]);
    const urlToken = (0, get_url_token_js_1.getUrlToken)();
    // If an auth cookie is found and this site supports the wallet, we'll set the auth cookie in the client storage
    const wallet = wallets.find((w) => w.id === urlToken?.walletId);
    if (urlToken?.authCookie && wallet) {
        const clientStorage = new client_scoped_storage_js_1.ClientScopedStorage({
            storage,
            clientId: props.client.clientId,
            ecosystem: (0, is_ecosystem_wallet_js_1.isEcosystemWallet)(wallet)
                ? {
                    id: wallet.id,
                    partnerId: wallet.getConfig()?.partnerId,
                }
                : undefined,
        });
        await clientStorage.saveAuthCookie(urlToken.authCookie);
    }
    if (urlToken?.walletId) {
        lastActiveWalletId = urlToken.walletId;
        lastConnectedWalletIds = lastConnectedWalletIds?.includes(urlToken.walletId)
            ? lastConnectedWalletIds
            : [urlToken.walletId, ...(lastConnectedWalletIds || [])];
    }
    if (urlToken?.authProvider) {
        await setLastAuthProvider?.(urlToken.authProvider, storage);
    }
    // if no wallets were last connected or we didn't receive an auth token
    if (!lastConnectedWalletIds) {
        return autoConnected;
    }
    // this flow can actually be used for a first connection in the case of a redirect
    // in that case, we default to the passed chain to connect to
    const lastConnectedChain = (await (0, index_js_1.getLastConnectedChain)(storage)) || props.chain;
    const availableWallets = [...wallets, ...(getInstalledWallets?.() ?? [])];
    const activeWallet = lastActiveWalletId &&
        (availableWallets.find((w) => w.id === lastActiveWalletId) ||
            createWalletFn(lastActiveWalletId));
    if (activeWallet) {
        manager.activeWalletConnectionStatusStore.setValue("connecting"); // only set connecting status if we are connecting the last active EOA
        await (0, timeoutPromise_js_1.timeoutPromise)(handleWalletConnection({
            wallet: activeWallet,
            client: props.client,
            lastConnectedChain,
            authResult: urlToken?.authResult,
        }), {
            ms: timeout,
            message: `AutoConnect timeout: ${timeout}ms limit exceeded.`,
        }).catch((err) => {
            console.warn(err.message);
            if (props.onTimeout) {
                props.onTimeout();
            }
        });
        try {
            // connected wallet could be activeWallet or smart wallet
            const connectedWallet = await (connectOverride
                ? connectOverride(activeWallet)
                : manager.connect(activeWallet, {
                    client: props.client,
                    accountAbstraction: props.accountAbstraction,
                }));
            if (connectedWallet) {
                autoConnected = true;
                try {
                    onConnect?.(connectedWallet);
                }
                catch {
                    // ignore
                }
            }
            else {
                manager.activeWalletConnectionStatusStore.setValue("disconnected");
            }
        }
        catch (e) {
            if (e instanceof Error) {
                console.warn("Error auto connecting wallet:", e.message);
            }
            manager.activeWalletConnectionStatusStore.setValue("disconnected");
        }
    }
    else {
        manager.activeWalletConnectionStatusStore.setValue("disconnected");
    }
    // then connect wallets that were last connected but were not set as active
    const otherWallets = availableWallets.filter((w) => w.id !== lastActiveWalletId && lastConnectedWalletIds.includes(w.id));
    for (const wallet of otherWallets) {
        try {
            await handleWalletConnection({
                wallet,
                client: props.client,
                lastConnectedChain,
                authResult: urlToken?.authResult,
            });
            manager.addConnectedWallet(wallet);
        }
        catch {
            // no-op
        }
    }
    // Auto-login with SIWE
    const isIAW = activeWallet &&
        (0, is_in_app_signer_js_1.isInAppSigner)({
            wallet: activeWallet,
            connectedWallets: activeWallet
                ? [activeWallet, ...otherWallets]
                : otherWallets,
        });
    if (isIAW &&
        props.siweAuth?.requiresAuth &&
        !props.siweAuth?.isLoggedIn &&
        !props.siweAuth?.isLoggingIn) {
        await props.siweAuth?.doLogin().catch((err) => {
            console.warn("Error signing in with SIWE:", err.message);
        });
    }
    manager.isAutoConnecting.setValue(false);
    return autoConnected; // useQuery needs a return value
};
/**
 * @internal
 */
async function handleWalletConnection(props) {
    return props.wallet.autoConnect({
        client: props.client,
        chain: props.lastConnectedChain,
        authResult: props.authResult,
    });
}
//# sourceMappingURL=autoConnectCore.js.map