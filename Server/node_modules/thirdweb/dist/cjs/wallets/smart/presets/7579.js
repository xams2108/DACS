"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.erc7579 = erc7579;
const ox__AbiParameters = require("ox/AbiParameters");
const ox__Hex = require("ox/Hex");
const serialize_erc6492_signature_js_1 = require("../../../auth/serialize-erc6492-signature.js");
const verify_hash_js_1 = require("../../../auth/verify-hash.js");
const addresses_js_1 = require("../../../constants/addresses.js");
const contract_js_1 = require("../../../contract/contract.js");
const getNonce_js_1 = require("../../../extensions/erc4337/__generated__/IEntryPoint/read/getNonce.js");
const execute_js_1 = require("../../../extensions/erc7579/__generated__/IERC7579Account/write/execute.js");
const createAccountWithModules_js_1 = require("../../../extensions/erc7579/__generated__/ModularAccountFactory/write/createAccountWithModules.js");
const encode_js_1 = require("../../../transaction/actions/encode.js");
const read_contract_js_1 = require("../../../transaction/read-contract.js");
const encodeAbiParameters_js_1 = require("../../../utils/abi/encodeAbiParameters.js");
const address_js_1 = require("../../../utils/address.js");
const hashMessage_js_1 = require("../../../utils/hashing/hashMessage.js");
const hashTypedData_js_1 = require("../../../utils/hashing/hashTypedData.js");
const constants_js_1 = require("../lib/constants.js");
const utils_js_1 = require("../lib/utils.js");
/**
 * Config for a ERC7579 modular smart wallet.
 *
 * This configuration is in BETA, expect breaking changes.
 *
 * @param options - Optional overrides for the smart wallet.
 * @returns The smart wallet options.
 *
 * @example
 * ```typescript
 * import { sepolia } from "thirdweb/chains";
 * import { smartWallet, Config } from "thirdweb/wallets/smart";
 *
 * const modularSmartWallet = smartWallet(
 *   Config.erc7579({
 *     chain: sepolia,
 *     sponsorGas: true,
 *     factoryAddress: "0x...", // the 7579 factory address
 *     validatorAddress: "0x...", // the default validator module address
 *   }),
 * });
 * ```
 *
 * @wallet
 * @extension ERC7579
 * @beta
 */
function erc7579(options) {
    const saltHex = options.overrides?.accountSalt &&
        ox__Hex.validate(options.overrides.accountSalt)
        ? options.overrides.accountSalt
        : ox__Hex.fromString(options.overrides?.accountSalt ?? "");
    const defaultValidator = (0, address_js_1.getAddress)(options.validatorAddress);
    const modularAccountOptions = {
        ...options,
        factoryAddress: options.factoryAddress,
        overrides: {
            entrypointAddress: constants_js_1.ENTRYPOINT_ADDRESS_v0_7,
            createAccount(factoryContract, admin) {
                // TODO (msa) - let ppl pass whatever modules they want here
                return (0, createAccountWithModules_js_1.createAccountWithModules)({
                    contract: factoryContract,
                    asyncParams: async () => {
                        // default validator
                        const modules = [
                            {
                                moduleTypeId: 1n, // validator type id
                                module: defaultValidator,
                                initData: ox__Hex.fromString(""),
                            },
                        ];
                        return {
                            owner: admin,
                            salt: saltHex,
                            modules,
                        };
                    },
                });
            },
            async predictAddress(factoryContract, admin) {
                return (0, read_contract_js_1.readContract)({
                    contract: factoryContract,
                    method: "function getAddress(address owner, bytes salt) returns (address)",
                    params: [admin, saltHex],
                });
            },
            execute(accountContract, transaction) {
                return (0, execute_js_1.execute)({
                    contract: accountContract,
                    async asyncParams() {
                        return {
                            mode: ox__Hex.padRight("0x00", 32), // single execution
                            executionCalldata: ox__AbiParameters.encodePacked(["address", "uint256", "bytes"], [
                                transaction.to || addresses_js_1.ZERO_ADDRESS,
                                transaction.value || 0n,
                                transaction.data || "0x",
                            ]),
                        };
                    },
                });
            },
            executeBatch(accountContract, transactions) {
                return (0, execute_js_1.execute)({
                    contract: accountContract,
                    async asyncParams() {
                        return {
                            mode: ox__Hex.padRight("0x01", 32), // batch execution
                            executionCalldata: ox__AbiParameters.encode([
                                {
                                    type: "tuple[]",
                                    components: [
                                        { type: "address", name: "to" },
                                        { type: "uint256", name: "value" },
                                        { type: "bytes", name: "data" },
                                    ],
                                },
                            ], [
                                transactions.map((t) => ({
                                    to: t.to || addresses_js_1.ZERO_ADDRESS,
                                    value: t.value || 0n,
                                    data: t.data || "0x",
                                })),
                            ]),
                        };
                    },
                });
            },
            async getAccountNonce(accountContract) {
                const entryPointNonce = await (0, getNonce_js_1.getNonce)({
                    contract: (0, contract_js_1.getContract)({
                        address: constants_js_1.ENTRYPOINT_ADDRESS_v0_7,
                        chain: accountContract.chain,
                        client: accountContract.client,
                    }),
                    key: (0, utils_js_1.generateRandomUint192)(),
                    sender: accountContract.address,
                });
                // TODO (msa) - could be different if validator for the deployed account is different
                const withValidator = ox__Hex.from(`${defaultValidator}${ox__Hex.fromNumber(entryPointNonce).slice(42)}`);
                return ox__Hex.toBigInt(withValidator);
            },
            async signMessage(options) {
                const { accountContract, factoryContract, adminAccount, message } = options;
                const originalMsgHash = (0, hashMessage_js_1.hashMessage)(message);
                const createAccount = modularAccountOptions.overrides?.createAccount;
                if (!createAccount) {
                    throw new Error("Create account override not provided");
                }
                return generateSignature({
                    accountContract,
                    factoryContract,
                    adminAccount,
                    originalMsgHash,
                    defaultValidator,
                    createAccount,
                });
            },
            async signTypedData(options) {
                const { accountContract, factoryContract, adminAccount, typedData } = options;
                const originalMsgHash = (0, hashTypedData_js_1.hashTypedData)(typedData);
                const createAccount = modularAccountOptions.overrides?.createAccount;
                if (!createAccount) {
                    throw new Error("Create account override not provided");
                }
                return generateSignature({
                    accountContract,
                    factoryContract,
                    adminAccount,
                    originalMsgHash,
                    defaultValidator,
                    createAccount,
                });
            },
            ...options.overrides,
        },
    };
    return modularAccountOptions;
}
async function generateSignature(options) {
    const { accountContract, factoryContract, adminAccount, originalMsgHash, defaultValidator, createAccount, } = options;
    const wrappedMessageHash = (0, encodeAbiParameters_js_1.encodeAbiParameters)([{ type: "bytes32" }], [originalMsgHash]);
    const rawSig = await adminAccount.signTypedData({
        domain: {
            // TODO (msa) - assumes our default validator here
            name: "DefaultValidator",
            version: "1",
            chainId: accountContract.chain.id,
            verifyingContract: defaultValidator,
        },
        primaryType: "AccountMessage",
        types: { AccountMessage: [{ name: "message", type: "bytes" }] },
        message: { message: wrappedMessageHash },
    });
    // add the validator address to the signature
    const sig = (0, encodeAbiParameters_js_1.encodeAbiParameters)([{ type: "address" }, { type: "bytes" }], [defaultValidator, rawSig]);
    const deployTx = createAccount(factoryContract, adminAccount.address);
    if (!deployTx) {
        throw new Error("Create account override not provided");
    }
    const initCode = await (0, encode_js_1.encode)(deployTx);
    const erc6492Sig = (0, serialize_erc6492_signature_js_1.serializeErc6492Signature)({
        address: factoryContract.address,
        data: initCode,
        signature: sig,
    });
    // check if the signature is valid
    const isValid = await (0, verify_hash_js_1.verifyHash)({
        hash: originalMsgHash,
        signature: erc6492Sig,
        address: accountContract.address,
        chain: accountContract.chain,
        client: accountContract.client,
    });
    if (!isValid) {
        throw new Error(`Something went wrong generating the signature for modular smart account: ${accountContract.address} on chain ${accountContract.chain.id}`);
    }
    return erc6492Sig;
}
//# sourceMappingURL=7579.js.map