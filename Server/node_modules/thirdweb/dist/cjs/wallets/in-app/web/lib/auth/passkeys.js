"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PasskeyWebClient = void 0;
exports.hasStoredPasskey = hasStoredPasskey;
const webauthn_1 = require("@passwordless-id/webauthn");
const webStorage_js_1 = require("../../../../../utils/storage/webStorage.js");
const uint8_array_js_1 = require("../../../../../utils/uint8-array.js");
const client_scoped_storage_js_1 = require("../../../core/authentication/client-scoped-storage.js");
class PasskeyWebClient {
    isAvailable() {
        return webauthn_1.client.isAvailable();
    }
    async register(args) {
        const { name, challenge, rp } = args;
        const registration = await webauthn_1.client.register({
            user: name,
            challenge,
            userVerification: "required",
            domain: rp.id,
            attestation: true,
        });
        const clientDataB64 = (0, uint8_array_js_1.base64UrlToBase64)(registration.response.clientDataJSON);
        const clientDataParsed = JSON.parse((0, uint8_array_js_1.base64ToString)(clientDataB64));
        return {
            authenticatorData: registration.response.authenticatorData,
            credentialId: registration.id,
            clientData: registration.response.clientDataJSON,
            credential: {
                publicKey: registration.response.publicKey,
                algorithm: webauthn_1.parsers.getAlgoName(registration.response.publicKeyAlgorithm),
            },
            origin: clientDataParsed.origin,
        };
    }
    async authenticate(args) {
        const { credentialId, challenge, rp } = args;
        const result = await webauthn_1.client.authenticate({
            allowCredentials: credentialId ? [credentialId] : [],
            challenge,
            userVerification: "required",
            domain: rp.id,
        });
        const clientDataB64 = (0, uint8_array_js_1.base64UrlToBase64)(result.response.clientDataJSON);
        const clientDataParsed = JSON.parse((0, uint8_array_js_1.base64ToString)(clientDataB64));
        return {
            authenticatorData: result.response.authenticatorData,
            credentialId: result.id,
            clientData: result.response.clientDataJSON,
            signature: result.response.signature,
            origin: clientDataParsed.origin,
        };
    }
}
exports.PasskeyWebClient = PasskeyWebClient;
/**
 * Returns whether this device has a stored passkey ready to be used for sign-in
 * @param client - the thirdweb client
 * @returns whether the device has a stored passkey
 * @walletUtils
 */
async function hasStoredPasskey(client, ecosystemId, storage) {
    const clientStorage = new client_scoped_storage_js_1.ClientScopedStorage({
        storage: storage ?? webStorage_js_1.webLocalStorage, // TODO (passkey) react native variant of this fn
        clientId: client.clientId,
        ecosystem: ecosystemId ? { id: ecosystemId } : undefined,
    });
    const credId = await clientStorage.getPasskeyCredentialId();
    return !!credId;
}
//# sourceMappingURL=passkeys.js.map