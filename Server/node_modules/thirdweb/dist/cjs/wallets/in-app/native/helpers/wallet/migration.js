"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.migrateToEnclaveWallet = migrateToEnclaveWallet;
const client_kms_1 = require("@aws-sdk/client-kms");
const credential_providers_1 = require("@aws-sdk/credential-providers");
const react_native_quick_crypto_1 = require("react-native-quick-crypto");
const domains_js_1 = require("../../../../../utils/domains.js");
const to_bytes_js_1 = require("../../../../../utils/encoding/to-bytes.js");
const json_js_1 = require("../../../../../utils/json.js");
const random_js_1 = require("../../../../../utils/random.js");
const uint8_array_js_1 = require("../../../../../utils/uint8-array.js");
const private_key_js_1 = require("../../../../private-key.js");
const fetchers_js_1 = require("../api/fetchers.js");
const middleware_js_1 = require("../auth/middleware.js");
const constants_js_1 = require("../constants.js");
const retrieval_js_1 = require("./retrieval.js");
/**
 * Migrate a sharded wallet to an enclave wallet.
 *
 * @param args - The arguments for the migration process.
 * @returns The migrated user wallet.
 */
async function migrateToEnclaveWallet(args) {
    // setup sharded wallet first, so we have the shares available
    await (0, middleware_js_1.postAuth)({
        storedToken: args.storedToken,
        client: args.client,
        storage: args.storage,
        encryptionKey: args.encryptionKey,
    });
    const { authShare, deviceShare } = await (0, retrieval_js_1.getShares)({
        client: args.client,
        authShare: { toRetrieve: true },
        deviceShare: { toRetrieve: true },
        recoveryShare: { toRetrieve: false },
        storage: args.storage,
    });
    // construct the sharded wallet
    const privateKey = await (0, retrieval_js_1.getWalletPrivateKeyFromShares)([
        authShare,
        deviceShare,
    ]);
    const account = (0, private_key_js_1.privateKeyToAccount)({
        client: args.client,
        privateKey,
    });
    const address = account.address;
    // get cognito identity
    const idTokenResponse = await (0, fetchers_js_1.authFetchEmbeddedWalletUser)({
        client: args.client,
        url: constants_js_1.ROUTE_AUTH_COGNITO_ID_TOKEN_V2,
        props: {
            method: "GET",
        },
        storage: args.storage,
    });
    if (!idTokenResponse.ok) {
        throw new Error(`Failed to fetch id token from Cognito: ${(0, json_js_1.stringify)(await idTokenResponse.json(), null, 2)}`);
    }
    const idTokenResult = await idTokenResponse.json();
    const { token, identityId } = idTokenResult;
    const cognitoIdentity = (0, credential_providers_1.fromCognitoIdentity)({
        clientConfig: {
            region: constants_js_1.AWS_REGION,
        },
        identityId,
        logins: {
            "cognito-identity.amazonaws.com": token,
        },
    });
    // get kms key
    const kmsClient = new client_kms_1.KMSClient({
        region: constants_js_1.AWS_REGION,
        credentials: cognitoIdentity,
    });
    const generateDataKeyCommand = new client_kms_1.GenerateDataKeyCommand({
        KeyId: constants_js_1.ENCLAVE_KMS_KEY_ARN,
        KeySpec: "AES_256",
    });
    const encryptedKeyResult = await kmsClient.send(generateDataKeyCommand);
    const plaintextKeyBlob = encryptedKeyResult.Plaintext;
    const cipherTextBlob = encryptedKeyResult.CiphertextBlob;
    if (!plaintextKeyBlob || !cipherTextBlob) {
        throw new Error("No migration key found. Please try again.");
    }
    // encrypt private key
    const iv = (0, random_js_1.randomBytesBuffer)(16);
    // @ts-ignore - default import buils but ts doesn't like it
    const key = await react_native_quick_crypto_1.default.subtle.importKey("raw", plaintextKeyBlob, "AES-CBC", false, ["encrypt", "decrypt"]);
    // @ts-ignore - default import buils but ts doesn't like it
    const encryptedPrivateKey = await react_native_quick_crypto_1.default.subtle.encrypt({
        name: "AES-CBC",
        iv,
    }, key, (0, to_bytes_js_1.stringToBytes)(privateKey));
    const encryptedData = (0, uint8_array_js_1.concatUint8Arrays)([
        iv,
        new Uint8Array(encryptedPrivateKey),
    ]);
    const ivB64 = (0, uint8_array_js_1.uint8ArrayToBase64)(iv);
    const cipherTextB64 = (0, uint8_array_js_1.uint8ArrayToBase64)(cipherTextBlob);
    const encryptedPrivateKeyB64 = (0, uint8_array_js_1.uint8ArrayToBase64)(encryptedData);
    // execute migration
    const result = await executeMigration({
        client: args.client,
        storage: args.storage,
        address,
        kmsCiphertextB64: cipherTextB64,
        encryptedPrivateKeyB64: encryptedPrivateKeyB64,
        ivB64,
    });
    return result;
}
async function executeMigration(args) {
    const migrationResponse = await (0, fetchers_js_1.authFetchEmbeddedWalletUser)({
        client: args.client,
        url: `${(0, domains_js_1.getThirdwebBaseUrl)("inAppWallet")}/api/v1/enclave-wallet/migrate`,
        props: {
            method: "POST",
            body: (0, json_js_1.stringify)({
                address: args.address,
                kmsCiphertextB64: args.kmsCiphertextB64,
                encryptedPrivateKeyB64: args.encryptedPrivateKeyB64,
                ivB64: args.ivB64,
            }),
        },
        storage: args.storage,
    });
    if (!migrationResponse.ok) {
        throw new Error(`Failed to migrate to enclave wallet: ${(0, json_js_1.stringify)(await migrationResponse.json())}`);
    }
    const migrationResult = (await migrationResponse.json());
    return migrationResult;
}
//# sourceMappingURL=migration.js.map