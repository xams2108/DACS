"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useReadContract = useReadContract;
const react_query_1 = require("@tanstack/react-query");
const read_contract_js_1 = require("../../../../transaction/read-contract.js");
const function_id_js_1 = require("../../../../utils/function-id.js");
const json_js_1 = require("../../../../utils/json.js");
function useReadContract(extensionOrOptions, options) {
    let queryKey;
    let queryFn;
    let queryOpts;
    // extension case
    if (typeof extensionOrOptions === "function") {
        if (!options) {
            throw new Error(`Missing second argument for "useReadContract(<extension>, <options>)" hook.`);
        }
        const { queryOptions, contract, ...params } = options;
        queryOpts = queryOptions;
        queryKey = [
            "readContract",
            contract.chain.id,
            contract.address,
            (0, function_id_js_1.getFunctionId)(extensionOrOptions),
            (0, json_js_1.stringify)(params),
        ];
        queryFn = () => extensionOrOptions({
            ...params,
            contract,
        });
    }
    // raw tx case
    if ("method" in extensionOrOptions) {
        const { queryOptions, ...tx } = extensionOrOptions;
        queryOpts = queryOptions;
        queryKey = [
            "readContract",
            tx.contract.chain.id,
            tx.contract.address,
            tx.method,
            (0, json_js_1.stringify)(tx.params),
        ];
        queryFn = () => (0, read_contract_js_1.readContract)(extensionOrOptions);
    }
    if (!queryKey || !queryFn) {
        throw new Error(`Invalid "useReadContract" options. Expected either a read extension or a transaction object.`);
    }
    return (0, react_query_1.useQuery)((0, react_query_1.queryOptions)({
        queryKey: queryKey,
        queryFn: queryFn,
        ...(queryOpts ?? {}),
    }));
}
//# sourceMappingURL=useReadContract.js.map