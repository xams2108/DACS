"use strict";
"use client";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenIcon = TokenIcon;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_query_1 = require("@tanstack/react-query");
const utils_js_1 = require("../../../../../chains/utils.js");
const addresses_js_1 = require("../../../../../constants/addresses.js");
const contract_js_1 = require("../../../../../contract/contract.js");
const getContractMetadata_js_1 = require("../../../../../extensions/common/read/getContractMetadata.js");
const function_id_js_1 = require("../../../../../utils/function-id.js");
const ipfs_js_1 = require("../../../../../utils/ipfs.js");
const provider_js_1 = require("./provider.js");
/**
 * This component tries to resolve the icon of a given token, then return an image.
 * @returns an <img /> with the src of the token icon
 *
 * @example
 * ### Basic usage
 * ```tsx
 * import { TokenProvider, TokenIcon } from "thirdweb/react";
 *
 * <TokenProvider address="0x-token-address" chain={chain} client={client}>
 *   <TokenIcon />
 * </TokenProvider>
 * ```
 *
 * Result: An <img /> component with the src of the icon
 * ```html
 * <img src="token-icon.png" />
 * ```
 *
 * ### Override the icon with the `iconResolver` prop
 * If you already have the icon url, you can skip the network requests and pass it directly to the TokenIcon
 * ```tsx
 * <TokenIcon iconResolver="/usdc.png" />
 * ```
 *
 * You can also pass in your own custom (async) function that retrieves the icon url
 * ```tsx
 * const getIcon = async () => {
 *   const icon = getIconFromCoinMarketCap(tokenAddress, etc);
 *   return icon;
 * };
 *
 * <TokenIcon iconResolver={getIcon} />
 * ```
 *
 * ### Show a loading sign while the icon is being loaded
 * ```tsx
 * <TokenIcon loadingComponent={<Spinner />} />
 * ```
 *
 * ### Fallback to a dummy image if the token icon fails to resolve
 * ```tsx
 * <TokenIcon fallbackComponent={<img src="blank-image.png" />} />
 * ```
 *
 * ### Usage with queryOptions
 * TokenIcon uses useQuery() from tanstack query internally.
 * It allows you to pass a custom queryOptions of your choice for more control of the internal fetching logic
 * ```tsx
 * <TokenIcon queryOptions={{ enabled: someLogic, retry: 3, }} />
 * ```
 *
 * @component
 * @token
 * @beta
 */
function TokenIcon({ iconResolver, loadingComponent, fallbackComponent, queryOptions, ...restProps }) {
    const { address, client, chain } = (0, provider_js_1.useTokenContext)();
    const iconQuery = (0, react_query_1.useQuery)({
        queryKey: [
            "_internal_token_icon_",
            chain.id,
            address,
            {
                resolver: typeof iconResolver === "string"
                    ? iconResolver
                    : typeof iconResolver === "function"
                        ? (0, function_id_js_1.getFunctionId)(iconResolver)
                        : undefined,
            },
        ],
        queryFn: async () => {
            if (typeof iconResolver === "string") {
                return iconResolver;
            }
            if (typeof iconResolver === "function") {
                return iconResolver();
            }
            if (address.toLowerCase() === addresses_js_1.NATIVE_TOKEN_ADDRESS.toLowerCase()) {
                const possibleUrl = await (0, utils_js_1.getChainMetadata)(chain).then((data) => data.icon?.url);
                if (!possibleUrl) {
                    throw new Error("Failed to resolve icon for native token");
                }
                return (0, ipfs_js_1.resolveScheme)({ uri: possibleUrl, client });
            }
            // Try to get the icon from the contractURI
            const contractMetadata = await (0, getContractMetadata_js_1.getContractMetadata)({
                contract: (0, contract_js_1.getContract)({
                    address,
                    chain,
                    client,
                }),
            });
            if (!contractMetadata.image ||
                typeof contractMetadata.image !== "string") {
                throw new Error("Failed to resolve token icon from contract metadata");
            }
            return (0, ipfs_js_1.resolveScheme)({
                uri: contractMetadata.image,
                client,
            });
        },
        ...queryOptions,
    });
    if (iconQuery.isLoading) {
        return loadingComponent || null;
    }
    if (!iconQuery.data) {
        return fallbackComponent || null;
    }
    return (0, jsx_runtime_1.jsx)("img", { src: iconQuery.data, ...restProps, alt: restProps.alt });
}
//# sourceMappingURL=icon.js.map