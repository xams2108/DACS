"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useWalletsAndBalances = useWalletsAndBalances;
const react_query_1 = require("@tanstack/react-query");
const utils_js_1 = require("../../../../../../../chains/utils.js");
const addresses_js_1 = require("../../../../../../../constants/addresses.js");
const common_js_1 = require("../../../../../../../insight/common.js");
const get_tokens_js_1 = require("../../../../../../../insight/get-tokens.js");
const getWalletBalance_js_1 = require("../../../../../../../wallets/utils/getWalletBalance.js");
const useChainQuery_js_1 = require("../../../../../../core/hooks/others/useChainQuery.js");
const useActiveAccount_js_1 = require("../../../../../../core/hooks/wallets/useActiveAccount.js");
const useConnectedWallets_js_1 = require("../../../../../../core/hooks/wallets/useConnectedWallets.js");
const nativeToken_js_1 = require("../../nativeToken.js");
const CHUNK_SIZE = 5;
function chunkChains(chains) {
    const chunks = [];
    for (let i = 0; i < chains.length; i += CHUNK_SIZE) {
        chunks.push(chains.slice(i, i + CHUNK_SIZE));
    }
    return chunks;
}
function useWalletsAndBalances(props) {
    const activeAccount = (0, useActiveAccount_js_1.useActiveAccount)();
    const connectedWallets = (0, useConnectedWallets_js_1.useConnectedWallets)();
    const chainInfo = (0, useChainQuery_js_1.useChainMetadata)(props.toChain);
    return (0, react_query_1.useQuery)({
        queryKey: [
            "wallets-and-balances",
            props.sourceSupportedTokens,
            props.toChain.id,
            props.toToken,
            props.mode,
            activeAccount?.address,
            connectedWallets.map((w) => w.getAccount()?.address),
        ],
        enabled: !!props.sourceSupportedTokens && !!chainInfo.data && !!activeAccount,
        queryFn: async () => {
            const entries = await Promise.all(connectedWallets.map(async (wallet) => {
                const balances = await fetchBalancesForWallet({
                    wallet,
                    accountAddress: activeAccount?.address,
                    sourceSupportedTokens: props.sourceSupportedTokens || [],
                    toChain: props.toChain,
                    toToken: props.toToken,
                    mode: props.mode,
                    client: props.client,
                });
                return [
                    {
                        id: wallet.id,
                        address: wallet.getAccount()?.address || "",
                    },
                    balances,
                ];
            }));
            const map = new Map();
            for (const entry of entries) {
                map.set(entry[0], entry[1]);
            }
            return map;
        },
    });
}
async function fetchBalancesForWallet({ wallet, accountAddress, sourceSupportedTokens, toChain, toToken, mode, client, }) {
    const account = wallet.getAccount();
    if (!account) {
        return [];
    }
    const balances = [];
    // 1. Resolve all unique chains in the supported token map
    const uniqueChains = Object.keys(sourceSupportedTokens).map((id) => (0, utils_js_1.getCachedChain)(Number(id)));
    // 2. Check insight availability once per chain
    const insightSupport = await Promise.all(uniqueChains.map(async (c) => ({
        chain: c,
        enabled: await (0, common_js_1.isInsightEnabled)(c),
    })));
    const insightEnabledChains = insightSupport
        .filter((c) => c.enabled)
        .map((c) => c.chain);
    // 3. ERC-20 balances for insight-enabled chains (batched 5 chains / call)
    const insightChunks = chunkChains(insightEnabledChains);
    await Promise.all(insightChunks.map(async (chunk) => {
        const owned = await (0, get_tokens_js_1.getOwnedTokens)({
            ownerAddress: account.address,
            chains: chunk,
            client,
        });
        for (const b of owned) {
            const matching = sourceSupportedTokens[b.chainId]?.find((t) => t.address.toLowerCase() === b.tokenAddress.toLowerCase());
            if (matching) {
                balances.push({
                    balance: b,
                    chain: (0, utils_js_1.getCachedChain)(b.chainId),
                    token: matching,
                });
            }
        }
    }));
    // 4. Build a token map that also includes the destination token so it can be used to pay
    const destinationToken = (0, nativeToken_js_1.isNativeToken)(toToken)
        ? {
            address: addresses_js_1.NATIVE_TOKEN_ADDRESS,
            name: toChain.nativeCurrency?.name || "",
            symbol: toChain.nativeCurrency?.symbol || "",
            icon: toChain.icon?.url,
        }
        : toToken;
    const tokenMap = {
        ...sourceSupportedTokens,
        [toChain.id]: [
            destinationToken,
            ...(sourceSupportedTokens[toChain.id] || []),
        ],
    };
    // 5. Fallback RPC balances (native currency & ERC-20 that we couldn't fetch from insight)
    const rpcCalls = [];
    for (const [chainIdStr, tokens] of Object.entries(tokenMap)) {
        const chainId = Number(chainIdStr);
        const chain = (0, utils_js_1.getCachedChain)(chainId);
        for (const token of tokens) {
            const isNative = (0, nativeToken_js_1.isNativeToken)(token);
            const isAlreadyFetched = balances.some((b) => b.chain.id === chainId &&
                b.token.address.toLowerCase() === token.address.toLowerCase());
            if (isAlreadyFetched && !isNative) {
                // ERC20 on insight-enabled chain already handled by insight call
                continue;
            }
            rpcCalls.push((async () => {
                try {
                    const balance = await (0, getWalletBalance_js_1.getWalletBalance)({
                        address: account.address,
                        chain,
                        tokenAddress: isNative ? undefined : token.address,
                        client,
                    });
                    const include = token.address.toLowerCase() ===
                        destinationToken.address.toLowerCase() &&
                        chain.id === toChain.id
                        ? !(mode === "fund_wallet" && account.address === accountAddress)
                        : balance.value > 0n;
                    if (include) {
                        balances.push({ balance, chain, token });
                    }
                }
                catch (err) {
                    console.warn(`Failed to fetch balance for ${token.symbol} on chain ${chainId}`, err);
                }
            })());
        }
    }
    await Promise.all(rpcCalls);
    // Remove duplicates (same chainId + token address)
    {
        const uniq = {};
        for (const b of balances) {
            const k = `${b.chain.id}-${b.token.address.toLowerCase()}`;
            if (!uniq[k]) {
                uniq[k] = b;
            }
        }
        balances.splice(0, balances.length, ...Object.values(uniq));
    }
    // 6. Sort so that the destination token always appears first, then tokens on the destination chain, then by chain id
    balances.sort((a, b) => {
        const destAddress = destinationToken.address;
        if (a.chain.id === toChain.id && a.token.address === destAddress)
            return -1;
        if (b.chain.id === toChain.id && b.token.address === destAddress)
            return 1;
        if (a.chain.id === toChain.id)
            return -1;
        if (b.chain.id === toChain.id)
            return 1;
        return a.chain.id - b.chain.id;
    });
    return balances;
}
//# sourceMappingURL=fetchBalancesForWallet.js.map