"use strict";
"use client";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountAvatar = AccountAvatar;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_query_1 = require("@tanstack/react-query");
const resolve_avatar_js_1 = require("../../../../../extensions/ens/resolve-avatar.js");
const resolve_name_js_1 = require("../../../../../extensions/ens/resolve-name.js");
const profiles_js_1 = require("../../../../../social/profiles.js");
const avatar_js_1 = require("../../../../../utils/ens/avatar.js");
const provider_js_1 = require("../../../../core/account/provider.js");
/**
 * The component for showing the avatar of the account.
 * If fetches all the social profiles linked to your wallet, including: Farcaster, ENS, Lens (more to be added)
 * You can choose which social profile you want to display. Defaults to the first item in the list.
 *
 * @example
 * ### Basic usage
 * ```tsx
 * import { AccountProvider, AccountAvatar } from "thirdweb/react";
 *
 * <AccountProvider address="0x...">
 *   <AccountAvatar />
 * </AccountProvider>
 * ```
 * Result: An <img /> component, if the avatar is resolved successfully
 * ```html
 * <img alt="" src="resolved-url-for-the-avatar" />
 * ```
 *
 * ### Show a loading sign when the avatar is being resolved
 * ```tsx
 * import { AccountProvider, AccountAvatar } from "thirdweb/react";
 *
 * <AccountProvider address="0x...">
 *   <AccountAvatar
 *     loadingComponent={<YourLoadingComponent />}
 *   />
 * </AccountProvider>
 * ```
 *
 * ### Fallback to something when the avatar fails to resolve
 * ```tsx
 * import { AccountProvider, AccountAvatar } from "thirdweb/react";
 *
 * <AccountProvider address="0x...">
 *   <AccountAvatar
 *     fallbackComponent={<DummyImage />}
 *   />
 * </AccountProvider>
 * ```
 *
 * ### Select a social profile to display
 * If you wallet associates with more than one social profiles (Lens, Farcaster, ENS, etc.)
 * You can specify which service you want to prioritize using the `socialType` props
 * ```tsx
 * import { AccountProvider, AccountAvatar } from "thirdweb/react";
 *
 * <AccountProvider address="0x...">
 *   <AccountAvatar
 *     // Choose between: "farcaster" | "lens" | "ens"
 *     socialType={"ens"}
 *   />
 * </AccountProvider>
 * ```
 *
 * ### Custom ENS resolver chain
 * This component shares the same props with the ENS extension `resolveAvatar`
 * ```tsx
 * import { AccountProvider, AccountAvatar } from "thirdweb/react";
 * import { base } from "thirdweb/chains";
 *
 * <AccountProvider address="0x...">
 *   <AccountAvatar
 *     resolverAddress={"0x..."}
 *     resolverChain={base}
 *   />
 * </AccountProvider>
 * ```
 *
 * ### Custom query options for useQuery
 * This component uses `@tanstack-query`'s useQuery internally.
 * You can use the `queryOptions` prop for more fine-grained control
 * ```tsx
 * <AccountAvatar
 *   queryOptions={{
 *     enabled: isEnabled,
 *     retry: 3,
 *   }}
 * />
 * ```
 * @returns An <img /> if the avatar is resolved successfully
 * @component
 * @wallet
 * @beta
 */
function AccountAvatar({ socialType, resolverAddress, resolverChain, loadingComponent, fallbackComponent, queryOptions, ...restProps }) {
    const { address, client } = (0, provider_js_1.useAccountContext)();
    const avatarQuery = (0, react_query_1.useQuery)({
        queryKey: [
            "account-avatar",
            address,
            { socialType },
            { resolverAddress, resolverChain },
        ],
        queryFn: async () => {
            const [socialData, ensName] = await Promise.all([
                (0, profiles_js_1.getSocialProfiles)({ address, client }),
                (0, resolve_name_js_1.resolveName)({
                    client,
                    address: address || "",
                    resolverAddress,
                    resolverChain,
                }),
            ]);
            const uri = socialData?.filter((p) => p.avatar && (socialType ? p.type === socialType : true))[0]?.avatar;
            const [resolvedSocialAvatar, resolvedENSAvatar] = await Promise.all([
                uri ? (0, avatar_js_1.parseAvatarRecord)({ client, uri }) : undefined,
                ensName
                    ? (0, resolve_avatar_js_1.resolveAvatar)({
                        client,
                        name: ensName,
                    })
                    : undefined,
            ]);
            // If no social image + ens name found -> exit and show <Blobbie />
            if (!resolvedSocialAvatar && !resolvedENSAvatar) {
                throw new Error("Failed to resolve social + ens avatar");
            }
            // else, prioritize the social image first
            if (resolvedSocialAvatar) {
                return resolvedSocialAvatar;
            }
            if (resolvedENSAvatar) {
                return resolvedENSAvatar;
            }
            throw new Error("Failed to resolve social + ens avatar");
        },
        retry: false,
        ...queryOptions,
    });
    if (avatarQuery.isLoading) {
        return loadingComponent || null;
    }
    if (!avatarQuery.data) {
        return fallbackComponent || null;
    }
    return (0, jsx_runtime_1.jsx)("img", { src: avatarQuery.data, ...restProps, alt: restProps.alt });
}
//# sourceMappingURL=avatar.js.map