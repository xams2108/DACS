"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SwapScreenContent = SwapScreenContent;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_query_1 = require("@tanstack/react-query");
const react_1 = require("react");
const pay_js_1 = require("../../../../../../../analytics/track/pay.js");
const utils_js_1 = require("../../../../../../../chains/utils.js");
const addresses_js_1 = require("../../../../../../../constants/addresses.js");
const contract_js_1 = require("../../../../../../../contract/contract.js");
const allowance_js_1 = require("../../../../../../../extensions/erc20/__generated__/IERC20/read/allowance.js");
const formatNumber_js_1 = require("../../../../../../../utils/formatNumber.js");
const useWalletBalance_js_1 = require("../../../../../../core/hooks/others/useWalletBalance.js");
const useBuyWithCryptoQuote_js_1 = require("../../../../../../core/hooks/pay/useBuyWithCryptoQuote.js");
const errors_js_1 = require("../../../../../utils/errors.js");
const Drawer_js_1 = require("../../../../components/Drawer.js");
const Spacer_js_1 = require("../../../../components/Spacer.js");
const Spinner_js_1 = require("../../../../components/Spinner.js");
const SwitchNetwork_js_1 = require("../../../../components/SwitchNetwork.js");
const basic_js_1 = require("../../../../components/basic.js");
const buttons_js_1 = require("../../../../components/buttons.js");
const text_js_1 = require("../../../../components/text.js");
const TokenSymbol_js_1 = require("../../../../components/token/TokenSymbol.js");
const nativeToken_js_1 = require("../../nativeToken.js");
const EstimatedTimeAndFees_js_1 = require("../EstimatedTimeAndFees.js");
const Fees_js_1 = require("./Fees.js");
const PayWithCrypto_js_1 = require("./PayWithCrypto.js");
function SwapScreenContent(props) {
    const { setScreen, payer, client, toChain, tokenAmount, toToken, fromChain, fromToken, payOptions, disableTokenSelection, } = props;
    const defaultRecipientAddress = props.payOptions?.paymentInfo?.sellerAddress;
    const receiverAddress = defaultRecipientAddress || props.activeAccount.address;
    const { drawerRef, drawerOverlayRef, isOpen, setIsOpen } = (0, Drawer_js_1.useDrawer)();
    const [drawerScreen, setDrawerScreen] = (0, react_1.useState)("fees");
    const fromTokenBalanceQuery = (0, useWalletBalance_js_1.useWalletBalance)({
        address: payer.account.address,
        chain: fromChain,
        tokenAddress: (0, nativeToken_js_1.isNativeToken)(fromToken) ? undefined : fromToken?.address,
        client,
    }, {
        enabled: !!fromChain && !!fromToken,
    });
    const fromTokenId = (0, nativeToken_js_1.isNativeToken)(fromToken)
        ? addresses_js_1.NATIVE_TOKEN_ADDRESS
        : fromToken?.address?.toLowerCase();
    const toTokenId = (0, nativeToken_js_1.isNativeToken)(toToken)
        ? addresses_js_1.NATIVE_TOKEN_ADDRESS
        : toToken.address.toLowerCase();
    const swapRequired = !!tokenAmount &&
        !!fromChain &&
        !!fromTokenId &&
        !(fromChain?.id === toChain.id && fromTokenId === toTokenId);
    const quoteParams = fromChain && fromToken && swapRequired
        ? {
            // wallets
            fromAddress: payer.account.address,
            toAddress: receiverAddress,
            // from
            fromChainId: fromChain.id,
            fromTokenAddress: (0, nativeToken_js_1.isNativeToken)(fromToken)
                ? addresses_js_1.NATIVE_TOKEN_ADDRESS
                : fromToken.address,
            // to
            toChainId: toChain.id,
            toTokenAddress: (0, nativeToken_js_1.isNativeToken)(toToken)
                ? addresses_js_1.NATIVE_TOKEN_ADDRESS
                : toToken.address,
            toAmount: tokenAmount,
            client,
            purchaseData: payOptions.purchaseData,
        }
        : undefined;
    const quoteQuery = (0, useBuyWithCryptoQuote_js_1.useBuyWithCryptoQuote)(quoteParams, {
        // refetch every 30 seconds
        staleTime: 30 * 1000,
        refetchInterval: 30 * 1000,
        gcTime: 30 * 1000,
    });
    const allowanceQuery = (0, react_query_1.useQuery)({
        queryKey: [
            "allowance",
            payer.account.address,
            quoteQuery.data?.approvalData,
        ],
        queryFn: () => {
            if (!quoteQuery.data?.approvalData) {
                return null;
            }
            return (0, allowance_js_1.allowance)({
                contract: (0, contract_js_1.getContract)({
                    client: props.client,
                    address: quoteQuery.data.swapDetails.fromToken.tokenAddress,
                    chain: (0, utils_js_1.getCachedChain)(quoteQuery.data.swapDetails.fromToken.chainId),
                }),
                spender: quoteQuery.data.approvalData.spenderAddress,
                owner: props.payer.account.address,
            });
        },
        enabled: !!quoteQuery.data?.approvalData,
        refetchOnMount: true,
    });
    const sourceTokenAmount = swapRequired
        ? quoteQuery.data?.swapDetails.fromAmount
        : tokenAmount;
    const isNotEnoughBalance = !!sourceTokenAmount &&
        !!fromTokenBalanceQuery.data &&
        Number(fromTokenBalanceQuery.data.displayValue) < Number(sourceTokenAmount);
    const disableContinue = !fromChain ||
        !fromToken ||
        (swapRequired && !quoteQuery.data) ||
        isNotEnoughBalance ||
        allowanceQuery.isLoading;
    const switchChainRequired = props.payer.wallet.getChain()?.id !== fromChain?.id;
    const errorMsg = !quoteQuery.isLoading && quoteQuery.error
        ? (0, errors_js_1.getErrorMessage)(quoteQuery.error)
        : undefined;
    function showSwapFlow() {
        if ((props.payOptions.mode === "direct_payment" ||
            props.payOptions.mode === "fund_wallet") &&
            !isNotEnoughBalance &&
            !swapRequired) {
            // same currency, just direct transfer
            setScreen({
                id: "transfer-flow",
            });
        }
        else if (props.payOptions.mode === "transaction" &&
            !isNotEnoughBalance &&
            !swapRequired) {
            if (payer.account.address !== receiverAddress) {
                // needs transfer from another wallet before executing the transaction
                setScreen({
                    id: "transfer-flow",
                });
            }
            else {
                // has enough balance to just do the transaction directly
                props.onDone();
            }
            return;
        }
        if (!quoteQuery.data) {
            return;
        }
        setScreen({
            id: "swap-flow",
            quote: quoteQuery.data,
            approvalAmount: allowanceQuery.data ?? undefined,
        });
    }
    function showFees() {
        if (!quoteQuery.data) {
            return;
        }
        setIsOpen(true);
        setDrawerScreen("fees");
    }
    return ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", gap: "lg", animate: "fadein", children: [isOpen && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(Drawer_js_1.DrawerOverlay, { ref: drawerOverlayRef }), (0, jsx_runtime_1.jsx)(Drawer_js_1.Drawer, { ref: drawerRef, close: () => setIsOpen(false), children: drawerScreen === "fees" && quoteQuery.data && ((0, jsx_runtime_1.jsxs)("div", { children: [(0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "lg", color: "primaryText", children: "Fees" }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "lg" }), (0, jsx_runtime_1.jsx)(Fees_js_1.SwapFees, { quote: quoteQuery.data })] })) })] })), (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", gap: "sm", children: [(0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", gap: "xxs", center: "y", children: [(0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "sm", children: "Pay with" }), fromToken && fromChain ? ((0, jsx_runtime_1.jsx)(TokenSymbol_js_1.TokenSymbol, { token: fromToken, chain: fromChain, size: "sm", color: "secondaryText" })) : ("crypto")] }), (0, jsx_runtime_1.jsxs)("div", { children: [(0, jsx_runtime_1.jsx)(PayWithCrypto_js_1.PayWithCryptoQuoteInfo, { value: sourceTokenAmount || "", chain: fromChain, token: fromToken, isLoading: quoteQuery.isLoading && !sourceTokenAmount, client: client, freezeChainAndTokenSelection: disableTokenSelection, payerAccount: props.payer.account, swapRequired: swapRequired, onSelectToken: props.showFromTokenSelector }), swapRequired && fromChain && fromToken && ((0, jsx_runtime_1.jsx)(EstimatedTimeAndFees_js_1.EstimatedTimeAndFees, { quoteIsLoading: quoteQuery.isLoading, estimatedSeconds: quoteQuery.data?.swapDetails.estimated.durationSeconds, onViewFees: showFees }))] }), errorMsg && ((0, jsx_runtime_1.jsx)("div", { children: errorMsg.data?.minimumAmountEth ? ((0, jsx_runtime_1.jsxs)(text_js_1.Text, { color: "danger", size: "xs", center: true, multiline: true, children: ["Minimum amount is", " ", (0, formatNumber_js_1.formatNumber)(Number(errorMsg.data.minimumAmountEth), 6), " ", (0, jsx_runtime_1.jsx)(TokenSymbol_js_1.TokenSymbol, { token: toToken, chain: toChain, size: "sm", inline: true, color: "danger" })] })) : ((0, jsx_runtime_1.jsxs)("div", { children: [(0, jsx_runtime_1.jsx)(text_js_1.Text, { color: "danger", size: "xs", center: true, multiline: true, children: errorMsg.title }), (0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "xs", center: true, multiline: true, children: errorMsg.message })] })) })), !errorMsg && isNotEnoughBalance && ((0, jsx_runtime_1.jsxs)("div", { children: [(0, jsx_runtime_1.jsx)(text_js_1.Text, { color: "danger", size: "xs", center: true, multiline: true, children: "Insufficient Funds" }), (0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "xs", center: true, multiline: true, children: "Select another token or pay with card." })] }))] }), errorMsg?.data?.minimumAmountEth ? ((0, jsx_runtime_1.jsx)(buttons_js_1.Button, { variant: "accent", fullWidth: true, onClick: () => {
                    props.setTokenAmount((0, formatNumber_js_1.formatNumber)(Number(errorMsg.data?.minimumAmountEth), 6).toString());
                    props.setHasEditedAmount(true);
                }, children: "Set Minimum" })) : isNotEnoughBalance || errorMsg ? ((0, jsx_runtime_1.jsx)(buttons_js_1.Button, { variant: "accent", fullWidth: true, onClick: () => props.showFromTokenSelector(), children: "Pay with another token" })) : switchChainRequired &&
                fromChain &&
                !quoteQuery.isLoading &&
                !allowanceQuery.isLoading &&
                !isNotEnoughBalance &&
                !quoteQuery.error ? ((0, jsx_runtime_1.jsx)(SwitchNetwork_js_1.SwitchNetworkButton, { variant: "accent", fullWidth: true, switchChain: async () => {
                    await props.payer.wallet.switchChain(fromChain);
                } })) : ((0, jsx_runtime_1.jsx)(buttons_js_1.Button, { variant: disableContinue ? "outline" : "accent", fullWidth: true, "data-disabled": disableContinue, disabled: disableContinue, onClick: async () => {
                    if (!disableContinue) {
                        showSwapFlow();
                        (0, pay_js_1.trackPayEvent)({
                            event: "confirm_swap_quote",
                            client: client,
                            walletAddress: payer.account.address,
                            walletType: payer.wallet.id,
                            chainId: fromChain.id,
                            fromToken: (0, nativeToken_js_1.isNativeToken)(fromToken)
                                ? undefined
                                : fromToken.address,
                            toChainId: toChain.id,
                            toToken: (0, nativeToken_js_1.isNativeToken)(toToken) ? undefined : toToken.address,
                        });
                    }
                }, gap: "xs", children: quoteQuery.isLoading ? ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: ["Getting price quote", (0, jsx_runtime_1.jsx)(Spinner_js_1.Spinner, { size: "sm", color: "accentText" })] })) : ("Continue") }))] }));
}
//# sourceMappingURL=SwapScreenContent.js.map