"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serverWallet = serverWallet;
const engine_1 = require("@thirdweb-dev/engine");
const encode_js_1 = require("../transaction/actions/encode.js");
const to_serializable_transaction_js_1 = require("../transaction/actions/to-serializable-transaction.js");
const domains_js_1 = require("../utils/domains.js");
const hex_js_1 = require("../utils/encoding/hex.js");
const fetch_js_1 = require("../utils/fetch.js");
const json_js_1 = require("../utils/json.js");
const resolve_promised_value_js_1 = require("../utils/promise/resolve-promised-value.js");
const get_status_js_1 = require("./get-status.js");
/**
 * Create a server wallet for sending transactions and signing messages via engine (v3+).
 * @param options - The server wallet options.
 * @returns An account object that can be used to send transactions and sign messages.
 * @engine
 * @example
 * ### Creating a server wallet
 * ```ts
 * import { Engine } from "thirdweb";
 *
 * const client = createThirdwebClient({
 *   secretKey: "<your-project-secret-key>",
 * });
 *
 * const myServerWallet = Engine.serverWallet({
 *   client,
 *   address: "<your-server-wallet-address>",
 *   vaultAccessToken: "<your-vault-access-token>",
 * });
 * ```
 *
 * ### Sending a transaction
 * ```ts
 * // prepare the transaction
 * const transaction = claimTo({
 *   contract,
 *   to: "0x...",
 *   quantity: 1n,
 * });
 *
 * // enqueue the transaction
 * const { transactionId } = await myServerWallet.enqueueTransaction({
 *   transaction,
 * });
 * ```
 *
 * ### Polling for the transaction to be submitted onchain
 * ```ts
 * // optionally poll for the transaction to be submitted onchain
 * const { transactionHash } = await Engine.waitForTransactionHash({
 *   client,
 *   transactionId,
 * });
 * console.log("Transaction sent:", transactionHash);
 * ```
 *
 * ### Getting the execution status of a transaction
 * ```ts
 * const executionResult = await Engine.getTransactionStatus({
 *   client,
 *   transactionId,
 * });
 * console.log("Transaction status:", executionResult.status);
 * ```
 */
function serverWallet(options) {
    const { client, vaultAccessToken, address, chain, executionOptions } = options;
    const headers = {
        "x-vault-access-token": vaultAccessToken,
    };
    const getExecutionOptions = (chainId) => {
        return executionOptions
            ? {
                ...executionOptions,
                chainId: chainId.toString(),
            }
            : {
                from: address,
                chainId: chainId.toString(),
            };
    };
    const enqueueTx = async (transaction) => {
        const body = {
            executionOptions: getExecutionOptions(transaction.chainId),
            params: [
                {
                    to: transaction.to ?? undefined,
                    data: transaction.data,
                    value: transaction.value?.toString(),
                },
            ],
        };
        const result = await (0, engine_1.sendTransaction)({
            baseUrl: (0, domains_js_1.getThirdwebBaseUrl)("engineCloud"),
            fetch: (0, fetch_js_1.getClientFetch)(client),
            headers,
            body,
        });
        if (result.error) {
            throw new Error(`Error sending transaction: ${result.error}`);
        }
        const data = result.data?.result;
        if (!data) {
            throw new Error("No data returned from engine");
        }
        const transactionId = data.transactions?.[0]?.id;
        if (!transactionId) {
            throw new Error("No transactionId returned from engine");
        }
        return transactionId;
    };
    return {
        address,
        enqueueTransaction: async (args) => {
            let serializedTransaction;
            if (args.simulate) {
                serializedTransaction = await (0, to_serializable_transaction_js_1.toSerializableTransaction)({
                    transaction: args.transaction,
                });
            }
            else {
                const [to, data, value] = await Promise.all([
                    args.transaction.to
                        ? (0, resolve_promised_value_js_1.resolvePromisedValue)(args.transaction.to)
                        : null,
                    (0, encode_js_1.encode)(args.transaction),
                    args.transaction.value
                        ? (0, resolve_promised_value_js_1.resolvePromisedValue)(args.transaction.value)
                        : null,
                ]);
                serializedTransaction = {
                    chainId: args.transaction.chain.id,
                    data,
                    to: to ?? undefined,
                    value: value ?? undefined,
                };
            }
            const transactionId = await enqueueTx(serializedTransaction);
            return { transactionId };
        },
        sendTransaction: async (transaction) => {
            const transactionId = await enqueueTx(transaction);
            return (0, get_status_js_1.waitForTransactionHash)({
                client,
                transactionId,
            });
        },
        signMessage: async (data) => {
            const { message, chainId } = data;
            let engineMessage;
            let isBytes = false;
            if (typeof message === "string") {
                engineMessage = message;
            }
            else {
                engineMessage = (0, hex_js_1.toHex)(message.raw);
                isBytes = true;
            }
            const signingChainId = chainId || chain?.id;
            if (!signingChainId) {
                throw new Error("Chain ID is required for signing messages");
            }
            const signResult = await (0, engine_1.signMessage)({
                baseUrl: (0, domains_js_1.getThirdwebBaseUrl)("engineCloud"),
                fetch: (0, fetch_js_1.getClientFetch)(client),
                headers,
                body: {
                    executionOptions: getExecutionOptions(signingChainId),
                    params: [
                        {
                            message: engineMessage,
                            messageFormat: isBytes ? "hex" : "text",
                        },
                    ],
                },
            });
            if (signResult.error) {
                throw new Error(`Error signing message: ${(0, json_js_1.stringify)(signResult.error)}`);
            }
            const signatureResult = signResult.data?.result.results[0];
            if (signatureResult?.success) {
                return signatureResult.result.signature;
            }
            throw new Error(`Failed to sign message: ${signatureResult?.error?.message || "Unknown error"}`);
        },
        signTypedData: async (typedData) => {
            const signingChainId = chain?.id;
            if (!signingChainId) {
                throw new Error("Chain ID is required for signing messages");
            }
            const signResult = await (0, engine_1.signTypedData)({
                baseUrl: (0, domains_js_1.getThirdwebBaseUrl)("engineCloud"),
                fetch: (0, fetch_js_1.getClientFetch)(client),
                headers,
                body: {
                    executionOptions: getExecutionOptions(signingChainId),
                    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix ts / hey-api type clash
                    params: [typedData],
                },
            });
            if (signResult.error) {
                throw new Error(`Error signing message: ${(0, json_js_1.stringify)(signResult.error)}`);
            }
            const signatureResult = signResult.data?.result.results[0];
            if (signatureResult?.success) {
                return signatureResult.result.signature;
            }
            throw new Error(`Failed to sign message: ${signatureResult?.error?.message || "Unknown error"}`);
        },
    };
}
//# sourceMappingURL=server-wallet.js.map