"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTransactionStatus = getTransactionStatus;
exports.waitForTransactionHash = waitForTransactionHash;
const engine_1 = require("@thirdweb-dev/engine");
const utils_js_1 = require("../chains/utils.js");
const domains_js_1 = require("../utils/domains.js");
const fetch_js_1 = require("../utils/fetch.js");
const json_js_1 = require("../utils/json.js");
/**
 * Get the execution status of a transaction.
 * @param args - The arguments for the transaction.
 * @param args.client - The thirdweb client to use.
 * @param args.transactionId - The id of the transaction to get the status of.
 * @engine
 * @example
 * ```ts
 * import { Engine } from "thirdweb";
 *
 * const executionResult = await Engine.getTransactionStatus({
 *   client,
 *   transactionId,
 * });
 * console.log(executionResult.status);
 * ```
 */
async function getTransactionStatus(args) {
    const { client, transactionId } = args;
    const searchResult = await (0, engine_1.searchTransactions)({
        baseUrl: (0, domains_js_1.getThirdwebBaseUrl)("engineCloud"),
        fetch: (0, fetch_js_1.getClientFetch)(client),
        body: {
            filters: [
                {
                    field: "id",
                    values: [transactionId],
                    operation: "OR",
                },
            ],
        },
    });
    if (searchResult.error) {
        throw new Error(`Error searching for transaction ${transactionId}: ${(0, json_js_1.stringify)(searchResult.error)}`);
    }
    const data = searchResult.data?.result?.transactions?.[0];
    if (!data) {
        throw new Error(`Transaction ${transactionId} not found`);
    }
    const executionResult = data.executionResult;
    return {
        ...executionResult,
        createdAt: data.createdAt,
        confirmedAt: data.confirmedAt,
        cancelledAt: data.cancelledAt,
        chain: (0, utils_js_1.getCachedChain)(Number(data.chainId)),
        from: data.from ?? undefined,
        id: data.id,
    };
}
/**
 * Wait for a transaction to be submitted onchain and return the transaction hash.
 * @param args - The arguments for the transaction.
 * @param args.client - The thirdweb client to use.
 * @param args.transactionId - The id of the transaction to wait for.
 * @param args.timeoutInSeconds - The timeout in seconds.
 * @engine
 * @example
 * ```ts
 * import { Engine } from "thirdweb";
 *
 * const { transactionHash } = await Engine.waitForTransactionHash({
 *   client,
 *   transactionId, // the transaction id returned from enqueueTransaction
 * });
 * ```
 */
async function waitForTransactionHash(args) {
    const startTime = Date.now();
    const TIMEOUT_IN_MS = args.timeoutInSeconds
        ? args.timeoutInSeconds * 1000
        : 5 * 60 * 1000; // 5 minutes in milliseconds
    while (Date.now() - startTime < TIMEOUT_IN_MS) {
        const executionResult = await getTransactionStatus(args);
        const status = executionResult.status;
        switch (status) {
            case "FAILED": {
                throw new Error(`Transaction failed: ${executionResult.error || "Unknown error"}`);
            }
            case "CONFIRMED": {
                const onchainStatus = executionResult && "onchainStatus" in executionResult
                    ? executionResult.onchainStatus
                    : null;
                if (onchainStatus === "REVERTED") {
                    const revertData = "revertData" in executionResult
                        ? executionResult.revertData
                        : undefined;
                    throw new Error(`Transaction reverted: ${revertData?.errorName || ""} ${revertData?.errorArgs ? (0, json_js_1.stringify)(revertData.errorArgs) : ""}`);
                }
                return {
                    transactionHash: executionResult.transactionHash,
                    client: args.client,
                    chain: executionResult.chain,
                };
            }
            default: {
                // wait for the transaction to be confirmed
                await new Promise((resolve) => setTimeout(resolve, 1000));
            }
        }
    }
    throw new Error(`Transaction timed out after ${TIMEOUT_IN_MS / 1000} seconds`);
}
//# sourceMappingURL=get-status.js.map