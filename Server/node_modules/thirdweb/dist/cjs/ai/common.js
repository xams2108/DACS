"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nebulaFetch = nebulaFetch;
const utils_js_1 = require("../chains/utils.js");
const prepare_transaction_js_1 = require("../transaction/prepare-transaction.js");
const bigint_js_1 = require("../utils/bigint.js");
const fetch_js_1 = require("../utils/fetch.js");
const NEBULA_API_URL = "https://nebula-api.thirdweb.com";
async function nebulaFetch(mode, input) {
    const fetch = (0, fetch_js_1.getClientFetch)(input.client);
    const response = await fetch(`${NEBULA_API_URL}/${mode}`, {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
        },
        body: JSON.stringify({
            ...("messages" in input
                ? {
                    messages: input.messages,
                }
                : {
                    message: input.message,
                }),
            session_id: input.sessionId,
            ...(input.account
                ? {
                    execute_config: {
                        mode: "client",
                        signer_wallet_address: input.account.address,
                    },
                }
                : {}),
            ...(input.contextFilter
                ? {
                    context_filter: {
                        chain_ids: input.contextFilter.chains?.map((c) => c.id.toString()) || [],
                        wallet_addresses: input.contextFilter.walletAddresses ||
                            (input.account ? [input.account.address] : []),
                        contract_addresses: input.contextFilter.contractAddresses || [],
                    },
                }
                : {}),
        }),
    });
    if (!response.ok) {
        const error = await response.text();
        throw new Error(`Nebula API error: ${error}`);
    }
    const data = (await response.json());
    // parse transactions if present
    let transactions = [];
    if (data.actions) {
        transactions = data.actions
            .map((action) => {
            // only parse sign_transaction actions
            if (action.type === "sign_transaction") {
                const tx = JSON.parse(action.data);
                return (0, prepare_transaction_js_1.prepareTransaction)({
                    chain: (0, utils_js_1.getCachedChain)(tx.chainId),
                    client: input.client,
                    to: tx.to,
                    value: tx.value ? (0, bigint_js_1.toBigInt)(tx.value) : undefined,
                    data: tx.data,
                });
            }
            return undefined;
        })
            .filter((tx) => tx !== undefined);
    }
    return {
        message: data.message,
        sessionId: data.session_id,
        transactions,
    };
}
//# sourceMappingURL=common.js.map