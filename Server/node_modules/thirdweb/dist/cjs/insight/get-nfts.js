"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOwnedNFTs = getOwnedNFTs;
exports.getContractNFTs = getContractNFTs;
exports.getNFT = getNFT;
const utils_js_1 = require("../chains/utils.js");
const contract_js_1 = require("../contract/contract.js");
const address_js_1 = require("../utils/address.js");
/**
 * Get NFTs owned by an address
 * @example
 * ```ts
 * import { Insight } from "thirdweb";
 *
 * const nfts = await Insight.getOwnedNFTs({
 *   client,
 *   chains: [sepolia],
 *   ownerAddress: "0x1234567890123456789012345678901234567890",
 * });
 * ```
 * @insight
 */
async function getOwnedNFTs(args) {
    const [{ getV1Nfts }, { getThirdwebDomains }, { getClientFetch }, { assertInsightEnabled }, { stringify },] = await Promise.all([
        Promise.resolve().then(() => require("@thirdweb-dev/insight")),
        Promise.resolve().then(() => require("../utils/domains.js")),
        Promise.resolve().then(() => require("../utils/fetch.js")),
        Promise.resolve().then(() => require("./common.js")),
        Promise.resolve().then(() => require("viem")),
    ]);
    // TODO (insight): add support for contract address filters
    const { client, chains, ownerAddress, queryOptions } = args;
    await assertInsightEnabled(chains);
    const defaultQueryOptions = {
        chain: chains.map((chain) => chain.id),
        // metadata: includeMetadata ? "true" : "false", TODO (insight): add support for this
        limit: 50,
        owner_address: ownerAddress,
    };
    const result = await getV1Nfts({
        baseUrl: `https://${getThirdwebDomains().insight}`,
        fetch: getClientFetch(client),
        query: {
            ...defaultQueryOptions,
            ...queryOptions,
        },
    });
    if (result.error) {
        throw new Error(`${result.response.status} ${result.response.statusText} - ${result.error ? stringify(result.error) : "Unknown error"}`);
    }
    const transformedNfts = await transformNFTModel(result.data?.data ?? [], client, ownerAddress);
    return transformedNfts.map((nft) => ({
        ...nft,
        quantityOwned: nft.quantityOwned ?? 1n,
    }));
}
/**
 * Get all NFTs from a contract
 * @example
 * ```ts
 * import { Insight } from "thirdweb";
 *
 * const nfts = await Insight.getContractNFTs({
 *   client,
 *   chains: [sepolia],
 *   contractAddress: "0x1234567890123456789012345678901234567890",
 * });
 * ```
 * @insight
 */
async function getContractNFTs(args) {
    const [{ getV1NftsByContractAddress }, { getThirdwebDomains }, { getClientFetch }, { assertInsightEnabled }, { stringify },] = await Promise.all([
        Promise.resolve().then(() => require("@thirdweb-dev/insight")),
        Promise.resolve().then(() => require("../utils/domains.js")),
        Promise.resolve().then(() => require("../utils/fetch.js")),
        Promise.resolve().then(() => require("./common.js")),
        Promise.resolve().then(() => require("../utils/json.js")),
    ]);
    const { client, chains, contractAddress, includeOwners = true, queryOptions, } = args;
    const defaultQueryOptions = {
        chain: chains.map((chain) => chain.id),
        // metadata: includeMetadata ? "true" : "false", TODO (insight): add support for this
        limit: 50,
        include_owners: includeOwners === true ? "true" : "false",
    };
    await assertInsightEnabled(chains);
    const result = await getV1NftsByContractAddress({
        baseUrl: `https://${getThirdwebDomains().insight}`,
        fetch: getClientFetch(client),
        path: {
            contract_address: contractAddress,
        },
        query: {
            ...defaultQueryOptions,
            ...queryOptions,
        },
    });
    if (result.error) {
        throw new Error(`${result.response.status} ${result.response.statusText} - ${result.error ? stringify(result.error) : "Unknown error"}`);
    }
    return transformNFTModel(result.data?.data ?? [], client);
}
/**
 * Get NFT metadata by contract address and token id
 * @example
 * ```ts
 * import { Insight } from "thirdweb";
 *
 * const nft = await Insight.getNFT({
 *   client,
 *   chain: sepolia,
 *   contractAddress: "0x1234567890123456789012345678901234567890",
 *   tokenId: 1n,
 * });
 * ```
 * @insight
 */
async function getNFT(args) {
    const [{ getV1NftsByContractAddressByTokenId }, { getThirdwebDomains }, { getClientFetch }, { assertInsightEnabled }, { stringify },] = await Promise.all([
        Promise.resolve().then(() => require("@thirdweb-dev/insight")),
        Promise.resolve().then(() => require("../utils/domains.js")),
        Promise.resolve().then(() => require("../utils/fetch.js")),
        Promise.resolve().then(() => require("./common.js")),
        Promise.resolve().then(() => require("../utils/json.js")),
    ]);
    const { client, chain, contractAddress, tokenId, includeOwners = true, queryOptions, } = args;
    await assertInsightEnabled([chain]);
    const defaultQueryOptions = {
        chain: chain.id,
        include_owners: includeOwners === true ? "true" : "false",
    };
    const result = await getV1NftsByContractAddressByTokenId({
        baseUrl: `https://${getThirdwebDomains().insight}`,
        fetch: getClientFetch(client),
        path: {
            contract_address: contractAddress,
            token_id: tokenId.toString(),
        },
        query: {
            ...defaultQueryOptions,
            ...queryOptions,
        },
    });
    if (result.error) {
        throw new Error(`${result.response.status} ${result.response.statusText} - ${result.error ? stringify(result.error) : "Unknown error"}`);
    }
    const transformedNfts = await transformNFTModel(result.data?.data ?? [], client);
    return transformedNfts?.[0];
}
async function transformNFTModel(nfts, client, ownerAddress) {
    const [{ parseNFT }, { totalSupply }] = await Promise.all([
        Promise.resolve().then(() => require("../utils/nft/parseNft.js")),
        Promise.resolve().then(() => require("../extensions/erc1155/__generated__/IERC1155/read/totalSupply.js")),
    ]);
    return await Promise.all(nfts.map(async (nft) => {
        let parsedNft;
        const { contract, extra_metadata, collection, metadata_url, chain_id, token_id, status, balance, token_type, ...rest } = nft;
        let metadataToUse = rest;
        let owners = ownerAddress
            ? [(0, address_js_1.getAddress)(ownerAddress)]
            : undefined;
        if ("owner_addresses" in rest) {
            const { owner_addresses, ...restWithoutOwnerAddresses } = rest;
            metadataToUse = restWithoutOwnerAddresses;
            owners = owners ?? owner_addresses?.map((o) => (0, address_js_1.getAddress)(o));
        }
        const metadata = replaceIPFSGatewayRecursively({
            uri: nft.metadata_url ?? "",
            image: nft.image_url,
            attributes: nft.extra_metadata?.attributes ?? undefined,
            ...metadataToUse,
        });
        if (contract?.type === "erc1155") {
            // TODO (insight): this needs to be added in the API
            const supply = await totalSupply({
                contract: (0, contract_js_1.getContract)({
                    address: contract.address,
                    chain: (0, utils_js_1.getCachedChain)(contract.chain_id),
                    client: client,
                }),
                id: BigInt(token_id),
            }).catch(() => 0n);
            parsedNft = parseNFT(metadata, {
                tokenId: BigInt(token_id),
                tokenUri: replaceIPFSGateway(metadata_url) ?? "",
                type: "ERC1155",
                owner: owners?.[0],
                tokenAddress: contract?.address ?? "",
                chainId: contract?.chain_id ?? 0,
                supply: supply,
            });
        }
        else {
            parsedNft = parseNFT(metadata, {
                tokenId: BigInt(token_id),
                type: "ERC721",
                owner: owners?.[0],
                tokenUri: replaceIPFSGateway(metadata_url) ?? "",
                tokenAddress: contract?.address ?? "",
                chainId: contract?.chain_id ?? 0,
            });
        }
        return parsedNft;
    }));
}
// biome-ignore lint/suspicious/noExplicitAny: this should be fixed in the API
function replaceIPFSGatewayRecursively(obj) {
    if (typeof obj !== "object" || obj === null) {
        return obj;
    }
    for (const key in obj) {
        if (typeof obj[key] === "string") {
            obj[key] = replaceIPFSGateway(obj[key]);
        }
        else {
            replaceIPFSGatewayRecursively(obj[key]);
        }
    }
    return obj;
}
function replaceIPFSGateway(url) {
    if (!url || typeof url !== "string") {
        return url;
    }
    try {
        const parsedUrl = new URL(url);
        if (parsedUrl.host.endsWith(".ipfscdn.io")) {
            const paths = parsedUrl.pathname.split("/");
            const index = paths.findIndex((path) => path === "ipfs");
            if (index === -1) {
                return url;
            }
            const ipfsHash = paths.slice(index + 1).join("/");
            if (ipfsHash) {
                return `ipfs://${ipfsHash}`;
            }
            return url;
        }
    }
    catch {
        // If the URL is invalid, return it as is
        return url;
    }
    return url;
}
//# sourceMappingURL=get-nfts.js.map