"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyHash = verifyHash;
exports.verifyEip1271Signature = verifyEip1271Signature;
const ox__Abi = require("ox/Abi");
const ox__AbiConstructor = require("ox/AbiConstructor");
const ox__AbiFunction = require("ox/AbiFunction");
const ox__Signature = require("ox/Signature");
const erc6492_1 = require("ox/erc6492");
const contract_js_1 = require("../contract/contract.js");
const isValidSignature_js_1 = require("../extensions/erc1271/__generated__/isValidSignature/read/isValidSignature.js");
const eth_call_js_1 = require("../rpc/actions/eth_call.js");
const rpc_js_1 = require("../rpc/rpc.js");
const isZkSyncChain_js_1 = require("../utils/any-evm/zksync/isZkSyncChain.js");
const is_contract_deployed_js_1 = require("../utils/bytecode/is-contract-deployed.js");
const from_bytes_js_1 = require("../utils/encoding/from-bytes.js");
const hex_js_1 = require("../utils/encoding/hex.js");
const serialize_erc6492_signature_js_1 = require("./serialize-erc6492-signature.js");
const ZKSYNC_VALIDATOR_ADDRESS = "0xfB688330379976DA81eB64Fe4BF50d7401763B9C";
/**
 * Verify that an address created the provided signature for a given hash using [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492). This function is interoperable with all wallet types, including EOAs.
 * This function should rarely be used directly, instead use @see {import("./verify-signature.js")} and @see {import("./verify-typed-data.js")}}
 *
 * @param {Hex} options.hash The hash that was signed
 * @param {string | Uint8Array | Signature} options.signature The signature that was signed
 * @param {string} options.address The address that signed the hash
 * @param {ThirdwebClient} options.client The Thirdweb client
 * @param {Chain} options.chain The chain that the address is on. For an EOA, this can be any chain.
 * @param {string} [options.accountFactory.address] The address of the account factory that created the account if using a smart account with a custom account factory
 * @param {Hex} [options.accountFactory.verificationCalldata] The calldata that was used to create the account if using a smart account with a custom account factory
 *
 * @returns {Promise<boolean>} A promise that resolves to `true` if the signature is valid, or `false` otherwise.
 *
 * @example
 * ```ts
 * import { verifyHash } from "thirdweb/utils";
 * const isValid = await verifyHash({
 *   hash: "0x1234",
 *   signature: "0x1234",
 *   address: "0x1234",
 *   client,
 *   chain,
 * });
 * ```
 *
 * @auth
 */
async function verifyHash({ hash, signature, address, client, chain, accountFactory, }) {
    const signatureHex = (() => {
        if ((0, hex_js_1.isHex)(signature))
            return signature;
        if (typeof signature === "object" && "r" in signature && "s" in signature)
            return ox__Signature.toHex(signature);
        if (signature instanceof Uint8Array)
            return (0, from_bytes_js_1.fromBytes)(signature, "hex");
        // We should never hit this but TS doesn't know that
        throw new Error(`Invalid signature type for signature ${signature}: ${typeof signature}`);
    })();
    const isDeployed = await (0, is_contract_deployed_js_1.isContractDeployed)((0, contract_js_1.getContract)({
        address,
        client,
        chain,
    }));
    if (isDeployed) {
        const validEip1271 = await verifyEip1271Signature({
            hash,
            signature: signatureHex,
            contract: (0, contract_js_1.getContract)({
                chain,
                address,
                client,
            }),
        }).catch((err) => {
            console.error("Error verifying EIP-1271 signature", err);
            return false;
        });
        if (validEip1271) {
            return true;
        }
    }
    // contract not deployed, use erc6492 validator to verify signature
    const wrappedSignature = await (async () => {
        // If no factory is provided, we have to assume its already deployed or is an EOA
        // TODO: Figure out how to automatically tell if our default factory was used
        if (!accountFactory)
            return signatureHex;
        // If this sigature was already wrapped for ERC-6492, carry on
        if (erc6492_1.WrappedSignature.validate(signatureHex))
            return signatureHex;
        // Otherwise, serialize the signature for ERC-6492 validation
        return (0, serialize_erc6492_signature_js_1.serializeErc6492Signature)({
            address: accountFactory.address,
            data: accountFactory.verificationCalldata,
            signature: signatureHex,
        });
    })();
    let verificationData;
    const zkSyncChain = await (0, isZkSyncChain_js_1.isZkSyncChain)(chain);
    const abi = ox__Abi.from(erc6492_1.WrappedSignature.universalSignatureValidatorAbi);
    if (zkSyncChain) {
        // zksync chains dont support deploying code with eth_call
        // need to call a deployed contract instead
        verificationData = {
            to: ZKSYNC_VALIDATOR_ADDRESS,
            data: ox__AbiFunction.encodeData(ox__AbiFunction.fromAbi(abi, "isValidSig"), [address, hash, wrappedSignature]),
        };
    }
    else {
        const validatorConstructor = ox__AbiConstructor.fromAbi(abi);
        verificationData = {
            data: ox__AbiConstructor.encode(validatorConstructor, {
                args: [address, hash, wrappedSignature],
                bytecode: erc6492_1.WrappedSignature.universalSignatureValidatorBytecode,
            }),
        };
    }
    const rpcRequest = (0, rpc_js_1.getRpcClient)({
        chain,
        client,
    });
    try {
        const result = await (0, eth_call_js_1.eth_call)(rpcRequest, verificationData);
        return (0, hex_js_1.hexToBool)(result);
    }
    catch {
        // Some chains do not support the eth_call simulation and will fail, so we fall back to regular EIP1271 validation
        const validEip1271 = await verifyEip1271Signature({
            hash,
            signature: signatureHex,
            contract: (0, contract_js_1.getContract)({
                chain,
                address,
                client,
            }),
        }).catch((err) => {
            console.error("Error verifying EIP-1271 signature", err);
            return false;
        });
        if (validEip1271) {
            return true;
        }
        // TODO: Improve overall RPC error handling so we can tell if this was an actual verification failure or some other error
        // Verification failed somehow
        return false;
    }
}
const EIP_1271_MAGIC_VALUE = "0x1626ba7e";
async function verifyEip1271Signature({ hash, signature, contract, }) {
    try {
        const result = await (0, isValidSignature_js_1.isValidSignature)({
            hash,
            signature,
            contract,
        });
        return result === EIP_1271_MAGIC_VALUE;
    }
    catch (err) {
        console.error("Error verifying EIP-1271 signature", err);
        return false;
    }
}
//# sourceMappingURL=verify-hash.js.map