"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNFTs = getNFTs;
exports.isGetNFTsSupported = isGetNFTsSupported;
const index_js_1 = require("../../../insight/index.js");
const bigint_js_1 = require("../../../utils/bigint.js");
const startTokenId_js_1 = require("../__generated__/IERC721A/read/startTokenId.js");
const totalSupply_js_1 = require("../__generated__/IERC721A/read/totalSupply.js");
const nextTokenIdToMint_js_1 = require("../__generated__/IERC721Enumerable/read/nextTokenIdToMint.js");
const getNFT_js_1 = require("./getNFT.js");
const DEFAULT_QUERY_ALL_COUNT = 100n;
/**
 * Retrieves an array of NFTs ("ERC721") based on the provided options.
 * @param options - The options for retrieving the NFTs.
 * @returns A promise that resolves to an array of NFTs.
 * @throws An error if the contract requires either `nextTokenIdToMint` or `totalSupply` function to determine the next token ID to mint.
 * @extension ERC721
 * @example
 * ```ts
 * import { getNFTs } from "thirdweb/extensions/erc721";
 * const nfts = await getNFTs({
 *  contract,
 *  start: 0,
 *  count: 10,
 * });
 * ```
 */
async function getNFTs(options) {
    const { useIndexer = true } = options;
    if (useIndexer) {
        try {
            return await getNFTsFromInsight(options);
        }
        catch {
            return await getNFTsFromRPC(options);
        }
    }
    return await getNFTsFromRPC(options);
}
/**
 * Checks if the `getNFTs` method is supported by the given contract.
 * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using "whatsabi" or if you have the ABI of the contract available you can use it to generate the selectors.
 * @returns A boolean indicating if the `getNFTs` method is supported.
 * @extension ERC721
 * @example
 * ```ts
 * import { isGetNFTsSupported } from "thirdweb/extensions/erc721";
 *
 * const supported = isGetNFTsSupported(["0x..."]);
 * ```
 */
function isGetNFTsSupported(availableSelectors) {
    return ((0, getNFT_js_1.isGetNFTSupported)(availableSelectors) &&
        ((0, totalSupply_js_1.isTotalSupplySupported)(availableSelectors) ||
            (0, nextTokenIdToMint_js_1.isNextTokenIdToMintSupported)(availableSelectors)));
}
async function getNFTsFromInsight(options) {
    const { contract, start, count = Number(DEFAULT_QUERY_ALL_COUNT) } = options;
    const [result, supplyInfo] = await Promise.all([
        (0, index_js_1.getContractNFTs)({
            client: contract.client,
            chains: [contract.chain],
            contractAddress: contract.address,
            includeOwners: options.includeOwners ?? false,
            queryOptions: {
                limit: count,
                page: start ? Math.floor(start / count) : undefined,
            },
        }),
        getSupplyInfo(options).catch(() => ({
            maxSupply: 0,
            startTokenId: 0,
        })),
    ]);
    const currentOffset = start ?? 0;
    const expectedResultLength = Math.min(count, Math.max(0, Number(supplyInfo.maxSupply) -
        Number(supplyInfo.startTokenId) -
        currentOffset));
    if (result.length < expectedResultLength) {
        // fresh contracts might be delayed in indexing, so we fallback to RPC
        return getNFTsFromRPC(options);
    }
    return result;
}
async function getNFTsFromRPC(options) {
    const { startTokenId, maxSupply } = await getSupplyInfo(options);
    const start = BigInt(options.start ?? 0) + startTokenId;
    const count = BigInt(options.count ?? DEFAULT_QUERY_ALL_COUNT);
    const maxId = (0, bigint_js_1.min)(maxSupply, start + count);
    const promises = [];
    for (let i = start; i < maxId; i++) {
        promises.push((0, getNFT_js_1.getNFT)({
            ...options,
            tokenId: i,
            includeOwner: options.includeOwners ?? false,
            useIndexer: false,
        }));
    }
    return await Promise.all(promises);
}
async function getSupplyInfo(options) {
    const [startTokenId_, maxSupply] = await Promise.allSettled([
        (0, startTokenId_js_1.startTokenId)(options),
        (0, nextTokenIdToMint_js_1.nextTokenIdToMint)(options),
        (0, totalSupply_js_1.totalSupply)(options),
    ]).then(([_startTokenId, _next, _total]) => {
        // default to 0 if startTokenId is not available
        const startTokenId__ = _startTokenId.status === "fulfilled" ? _startTokenId.value : 0n;
        let maxSupply_;
        // prioritize nextTokenIdToMint
        if (_next.status === "fulfilled") {
            // because we always default the startTokenId to 0 we can safely just always subtract here
            maxSupply_ = _next.value - startTokenId__;
        }
        // otherwise use totalSupply
        else if (_total.status === "fulfilled") {
            maxSupply_ = _total.value;
        }
        else {
            throw new Error("Contract requires either `nextTokenIdToMint` or `totalSupply` function available to determine the next token ID to mint");
        }
        return [startTokenId__, maxSupply_];
    });
    return {
        startTokenId: startTokenId_,
        maxSupply,
    };
}
//# sourceMappingURL=getNFTs.js.map