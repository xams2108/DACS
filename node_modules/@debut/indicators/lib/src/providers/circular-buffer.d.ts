/**
 * Circular buffers (also known as ring buffers) are fixed-size buffers that work as if the memory is contiguous & circular in nature.
 * As memory is generated and consumed, data does not need to be reshuffled â€“ rather, the head/tail pointers are adjusted.
 * When data is added, the head pointer advances. When data is consumed, the tail pointer advances.
 * If you reach the end of the buffer, the pointers simply wrap around to the beginning.
 */
export declare class CircularBuffer<T = number> {
    length: number;
    filled: boolean;
    protected pointer: number;
    protected buffer: Array<T>;
    protected maxIndex: number;
    /**
     * Constructor
     * @param length fixed buffer length
     */
    constructor(length: number);
    /**
     * Push item to buffer, when buffer length is overflow, push will rewrite oldest item
     */
    push(item: T): T;
    /**
     * Replace last added item in buffer (reversal push). May be used for revert push removed item.
     * @deprecated use peek instead
     */
    pushback(item: T): T;
    /**
     * Get item for replacing, does not modify anything
     */
    peek(): T;
    /**
     * Array like forEach loop
     */
    forEach(callback: (value: T, index?: number) => void): void;
    /**
     * Array like forEach loop, but from last to first (reversal forEach)
     */
    forEachRight(callback: (value: T, index?: number) => void): void;
    /**
     * Fill buffer
     */
    fill(item: T): void;
    /**
     * Get array from buffer
     */
    toArray(): T[];
    /**
     * Move iterator to next position
     */
    private iteratorNext;
    /**
     * Move iterator to prev position
     */
    private iteratorPrev;
}
