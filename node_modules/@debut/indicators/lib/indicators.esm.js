/**
 * Line Model class.
 * this.index - index in lineDirectives array
 */
class LineModel {
    constructor(h, l, i, step, index, prevPoint = null) {
        this.forked = false; // Flag of bounced line
        this.forkedAt = 0;
        this.lastForkY = null; // Last fork or extremum point
        this.step = step;
        this.index = index;
        this.length = 0;
        // TODO On fork startPoint is the fork point not the candle point
        this.startPoint = prevPoint
            ? {
                y: h ? prevPoint.h : prevPoint.l,
                x: prevPoint.x,
            }
            : {
                y: h || l,
                x: i,
            };
        this.init(h, l, i);
        this.thisPoint = this.startPoint;
    }
    init(h, l, i) {
        if (!this.type)
            this.type = h ? 'h' : 'l';
        this.candlePoint = {
            y: this.type == 'h' ? h : l,
            x: i,
        };
        // Shift window if data exists
        if (this.thisPoint) {
            this.prevPoint = this.thisPoint;
            if (this.nextPoint)
                this.thisPoint = this.nextPoint;
            this.nextPoint = {
                y: this.k * (this.candlePoint.x + this.step) + this.b,
                x: this.candlePoint.x + this.step,
            };
        }
    }
    /**
     * Update line object. Returns LineDirectives - actions list for the next candle based on prediction
     * @param h
     * @param l
     * @param i
     */
    update(h, l, i) {
        let result = null;
        this.length++;
        this.init(h, l, i);
        // Init К b
        if (!this.k || isNaN(this.k)) {
            this.k = (this.candlePoint.y - this.startPoint.y) / (this.candlePoint.x - this.startPoint.x);
            this.b = this.candlePoint.y - this.k * this.candlePoint.x;
            this.prevPoint = this.startPoint;
            this.thisPoint = this.candlePoint;
            this.nextPoint = {
                y: this.k * (this.candlePoint.x + this.step) + this.b,
                x: this.candlePoint.x + this.step,
            };
            result = {
                condition: this.type == 'h' ? 'lt' : 'gt',
                value: this.nextPoint.y,
                action: 'fork',
                lineIndex: this.index,
            };
        }
        // Update incline
        if ((this.type == 'h' && this.thisPoint.y <= this.candlePoint.y) ||
            (this.type == 'l' && this.thisPoint.y >= this.candlePoint.y)) {
            this.k = (this.candlePoint.y - this.startPoint.y) / (this.candlePoint.x - this.startPoint.x);
            this.b = this.candlePoint.y - this.k * this.candlePoint.x;
            this.thisPoint = this.candlePoint;
            this.length = 0;
            this.nextPoint = {
                y: this.k * (this.candlePoint.x + this.step) + this.b,
                x: this.candlePoint.x + this.step,
            };
            let rollbackTime = this.rollback ? this.rollback.length : 0;
            let rollbackIncline = this.candlePoint.y - this.prevPoint.y; // Take only one candle
            // Set rollback flag if moving away from the middle of price
            if (this.type == 'h' ? rollbackIncline > 0 : rollbackIncline < 0) {
                this.rollback = {
                    k: rollbackIncline,
                    b: this.candlePoint.y - rollbackIncline * this.candlePoint.x,
                    length: rollbackTime + 1,
                    lastForkTime: this.forkedAt || (this.rollback ? this.rollback.lastForkTime : 0),
                    lastForkValue: this.forkedValue || (this.rollback ? this.rollback.lastForkValue : 0),
                };
                // If rollback then the line lost the fork point
                // TODO Use accuracy to reset the forked value
                this.forked = false;
                this.forkedAt = null;
                this.forkedValue = null;
            }
            else {
                this.forkedAt = this.candlePoint.x;
                this.forkedValue = this.candlePoint.y;
                this.forked = true;
                this.rollback = null;
            }
            // Wait for bounce
            result = {
                condition: this.type == 'h' ? 'lt' : 'gt',
                value: this.nextPoint.y,
                action: 'fork',
                lineIndex: this.index,
            };
        }
        else {
            this.rollback = null;
        }
        return result;
    }
    /**
     * Update timescale
     * TODO operate in different time scale
     * @param step
     */
    updateStep(step) {
        this.step = step;
    }
}

/**
 * Lines Model class.
 * this.index - index in lineDirectives array
 */
class LinesModel {
    constructor(step) {
        this.lineIndex = 0;
        this.forkDiffH = null;
        this.forkDiffL = null;
        this.step = step;
        this.list = [[], []];
        this.id = {};
    }
    add(h, l, i, prevPoint = null, lineID = null) {
        // Если lineID определена - это экстремум
        let curIndex, holdLastForkY = null;
        if (lineID == null) {
            curIndex = this.lineIndex;
            this.lineIndex++;
            if (h != null)
                this.list[0].push(curIndex);
            else
                this.list[1].push(curIndex);
        }
        else {
            curIndex = lineID;
            // Сохраняем прежнюю точку ветвления или берем предыдущую
            holdLastForkY = this.id[curIndex].lastForkY || (h != null ? prevPoint.h : prevPoint.l);
        }
        this.id[curIndex] = new LineModel(h, l, i, this.step, curIndex, prevPoint);
        // Restore lastForkY from previous state
        if (holdLastForkY) {
            this.id[curIndex].lastForkY = holdLastForkY;
        }
        /**
         * Метод 3. Ищем последовательность: fork, rollback, fork, trade, wait same on opposite side
         */
        /**
         * Метод 2. Для линии в начале ее ветвления сохраняем y и сравниваем. Сигнализируем, когда разница больше или меньше нуля
         * Метод дает слишком много сигналов из которых сложно выделить значимые. Стоит поискать более эффективный метод поиска разворота
         */
        let sourceLineID, preSourceLineID;
        if (curIndex > 1 || (lineID != null && this.id[lineID] != null)) {
            sourceLineID =
                lineID != null
                    ? lineID
                    : this.list[this.id[curIndex].type == 'h' ? 0 : 1][this.list[this.id[curIndex].type == 'h' ? 0 : 1].indexOf(curIndex) - 1];
            preSourceLineID =
                lineID != null
                    ? lineID
                    : this.list[this.id[curIndex].type == 'h' ? 0 : 1][this.list[this.id[curIndex].type == 'h' ? 0 : 1].indexOf(curIndex) - 2];
            let lastForkVal = this.id[sourceLineID].lastForkY;
            // Если линия только создана, то берем экстремум у предыдущей в массиве линии preSourceLineID
            if (preSourceLineID && !lastForkVal)
                lastForkVal = this.id[preSourceLineID].lastForkY;
            let prevForkValue = h != null ? prevPoint.h : prevPoint.l;
            if (lastForkVal) {
                if (h)
                    this.forkDiffH = lastForkVal >= prevForkValue ? -sourceLineID - 1 : sourceLineID + 1;
                else
                    this.forkDiffL = lastForkVal >= prevForkValue ? -sourceLineID - 1 : sourceLineID + 1;
            }
            this.id[sourceLineID].lastForkY = prevForkValue;
        }
        return curIndex;
    }
    update(lineID, h, l, t) {
        return this.id[lineID].update(h, l, t);
    }
    delete(lineID) {
        if (!this.id[lineID])
            return;
        if (this.id[lineID].type == 'h')
            this.list[0].splice(this.list[0].indexOf(lineID), 1);
        else
            this.list[1].splice(this.list[1].indexOf(lineID), 1);
        delete this.id[lineID];
    }
}

/**
 * Trend state Model
 * The trendModel object use Lines and lineDirectives to estimate current trend state
 */
class TrendStateModel {
    constructor(lines, env) {
        this.kdiff = [];
        this.env = env;
        this.lines = lines;
        this.in = {
            state: null,
            lineIndex: null,
            line: null,
        };
        this.is = {
            state: null,
            lineIndex: null,
            line: null,
            start: null,
            size: 0,
        };
        this.was = {
            state: null,
            lineIndex: null,
            line: null,
            size: null,
        };
        this.width = 0;
        this.speed = 0;
        this.at = 0;
    }
    update(hLinesIDs, lLinesIDs) {
        //Wait for the first turn
        //Init
        // Search of the longest line begun from this.is
        // TODO longest is just the first in array of forked lines
        if (hLinesIDs.length > 1)
            this.hlMaxDuration = hLinesIDs
                .map((lineID) => this.lines.id[lineID])
                .filter((line) => this.is.line
                ? line.forkedAt
                    ? line.forkedAt > this.is.line.startPoint.x
                    : line.rollback
                        ? line.rollback.lastForkTime > this.is.line.startPoint.x
                        : false
                : true)
                .reduce((prev, current) => {
                return prev.length > current.length ? prev : current;
            }, this.lines.id[hLinesIDs[0]]);
        else
            this.hlMaxDuration = this.lines.id[hLinesIDs[0]];
        if (lLinesIDs.length > 1)
            this.llMaxDuration = lLinesIDs
                .map((lineID) => this.lines.id[lineID])
                .filter((line) => this.is.line
                ? line.forkedAt
                    ? line.forkedAt > this.is.line.startPoint.x
                    : line.rollback
                        ? line.rollback.lastForkTime > this.is.line.startPoint.x
                        : false
                : true)
                .reduce((prev, current) => {
                return prev.length > current.length ? prev : current;
            }, this.lines.id[lLinesIDs[0]]);
        else
            this.llMaxDuration = this.lines.id[lLinesIDs[0]];
        if (this.is.state == null && this.was.state == null) {
            // Take the minimum trend duration = 5 candles
            this.is.line =
                this.llMaxDuration &&
                    this.llMaxDuration.length > this.env.minLength &&
                    this.hlMaxDuration.length < this.env.minLength
                    ? this.llMaxDuration //hLines
                    : this.hlMaxDuration &&
                        this.hlMaxDuration.length > this.env.minLength &&
                        this.llMaxDuration.length < this.env.minLength
                        ? this.hlMaxDuration
                        : null;
            if (this.is.line) {
                this.is.lineIndex = this.is.line.index;
                this.is.state = this.is.line.type == 'h' ? 'fall' : 'rise';
                this.is.start = this.is.line.candlePoint;
            }
        }
        if (this.is.state) {
            // Wait for any line good break
            this.is.size = Math.max(this.is.size, Math.abs(this.is.start.y - this.is.line.candlePoint.y));
            let selectedLine = this.lines.id[this.is.lineIndex] || this.lines.id[this.is.line.type == 'h' ? 0 : 1];
            let foundBreak = null;
            let delta = null;
            let prevLineID;
            let oppositeLines = this.lines.list[selectedLine.type == 'h' ? 1 : 0].filter((id) => this.lines.id[id].forked && this.lines.id[id].thisPoint.x - this.lines.id[id].forkedAt > 12);
            oppositeLines.length > 1 ? oppositeLines[1] : oppositeLines.length > 0 ? oppositeLines[0] : null;
            let oppositeLinesInsideTrend = oppositeLines.filter((id) => this.lines.id[id].forkedAt > this.is.start.x);
            if (selectedLine)
                this.lines.list[selectedLine.type == 'h' ? 0 : 1].forEach((lineID, index) => {
                    let theLine = this.lines.id[lineID];
                    // Trend change conditions
                    if (lineID >= selectedLine.index && theLine.rollback != null) {
                        // when break on inner lines
                        // Get distance from the last fork on previous or current line
                        prevLineID = this.lines.list[selectedLine.type == 'h' ? 0 : 1][index - 1];
                        const cond = this.env.deltaModel == 1 && index > 1 && prevLineID && this.lines.id[prevLineID]
                            ? index > 1 && prevLineID && this.lines.id[prevLineID].lastForkY
                            : this.lines.id[lineID > 0 ? lineID - 1 : 0];
                        if (cond)
                            delta =
                                this.lines.id[lineID > 1 ? prevLineID : selectedLine.type == 'h' ? 0 : 1].lastForkY -
                                    theLine.candlePoint.y;
                        else if (theLine.rollback)
                            delta = theLine.rollback.lastForkValue - theLine.candlePoint.y;
                        else
                            delta = 0;
                        if (theLine.rollback.lastForkValue > 0 && // Only if break of forked line
                            // The line lasts more then this.env.minRightLeg
                            theLine.thisPoint.x - theLine.rollback.lastForkTime > this.env.minRightLeg &&
                            // TODO Maybe we should choose shortest and bounced line instead longest
                            (this.is.state == 'fall' ? this.llMaxDuration.length > 1 : this.hlMaxDuration.length > 1) && // Превышены граничные параметры
                            // - По предыдущему экстремуму. Пробита величина прошлого экстремума
                            ((selectedLine.type == 'h' ? delta < 0 : delta > 0) ||
                                // - По времени. текущая лития столкнулась с длительным пробоем
                                theLine.rollback.length > this.env.rollbackLength ||
                                //  - По амплитуде. Откат до установленной доли между ценой начала тренда и ценой от начала обратной линии
                                ((this.is.size * 2) / 3 > Math.abs(this.is.start.y - this.is.line.candlePoint.y) &&
                                    this.is.size > this.is.line.candlePoint.y * this.env.minIsSizeOnRollback &&
                                    oppositeLinesInsideTrend.length > 1) ||
                                (selectedLine.type == 'h'
                                    ? theLine.candlePoint.y > this.is.start.y && this.lines.list[0].length == 1
                                    : theLine.candlePoint.y < this.is.start.y && this.lines.list[1].length == 1)) && // сохраняются разрешенные диапазоны
                            // - предыдущее ветвление (экстремум) был в заданном диапазоне
                            ((theLine.candlePoint.x - theLine.rollback.lastForkTime > this.env.forkDurationMin &&
                                theLine.candlePoint.x - theLine.rollback.lastForkTime < this.env.forkDurationMax) ||
                                // - текущая цена вышла из тренда
                                (selectedLine.type == 'h'
                                    ? theLine.candlePoint.y > theLine.startPoint.y
                                    : theLine.candlePoint.y < theLine.startPoint.y) ||
                                (selectedLine.type == 'h'
                                    ? theLine.candlePoint.y > this.is.start.y && this.lines.list[0].length == 1
                                    : theLine.candlePoint.y < this.is.start.y && this.lines.list[1].length == 1)))
                            foundBreak = lineID + 1;
                    }
                });
            if (foundBreak) {
                // Calculate and compare was and is
                this.in.size = (this.was.size || 0) + this.is.size;
                // Estimate in state
                const dif = this.lines.id[0].candlePoint.y - this.is.start.y;
                const isSuccess = this.is.state == 'rise' ? dif >= 0 : dif < 0;
                if (this.was.size)
                    this.in.state = this.was.size > this.is.size ? this.was.state : this.is.state;
                // Copy is to was
                this.was = { ...this.is };
                this.was.success = isSuccess;
                // Update is
                // if exists opposite line with length > ?5 && length < thisLine.length then createOrder
                this.is.line = this.is.state == 'fall' ? this.llMaxDuration : this.hlMaxDuration;
                this.is.state = this.is.line.type == 'h' ? 'fall' : 'rise';
                this.is.lineIndex = this.is.line.index;
                this.is.start = this.lines.id[0].candlePoint;
                this.is.size = 0;
            }
            //
        }
        return;
    }
}

class Indicator {
    /**
     *
     * @param pars type of Env
     */
    constructor(pars) {
        this.hLineDirectives = [];
        this.lLineDirectives = [];
        this.step = 1; // TODO operate in different time scale
        this.i = 0;
        // Settings
        // Debug values
        this.localCounter = 0;
        this.prevPoint = null;
        // Assign defaults
        this.env = Object.assign({
            step: 1,
            minLength: 5,
            minRightLeg: 3,
            maxForks: 500,
            minLog: 0,
            maxLog: 0,
            rollbackLength: 3,
            deltaModel: 1,
            minIsSizeOnRollback: 0.05,
        }, pars);
        this.env.minLength = Math.round(this.env.minLength / this.env.step) || 1;
        this.env.minRightLeg = Math.round(this.env.minRightLeg / this.env.step) || 1;
        this.env.rollbackLength = Math.round(this.env.rollbackLength / this.env.step) || 1;
        this.env.forkDurationMin = Math.round(this.env.forkDurationMin / this.env.step) || 1;
        this.env.forkDurationMax = Math.round(this.env.forkDurationMax / this.env.step) || 1;
        this.lines = new LinesModel(this.step);
        this.trend = new TrendStateModel(this.lines, this.env);
    }
    log(title, ...data) {
        this.consoleWindow = this.env.minLog < this.localCounter && this.localCounter < this.env.maxLog;
        if (this.consoleWindow)
            console.log(title, ...data);
    }
    /**
     * Operate next candle method
     * @param o
     * @param c
     * @param h
     * @param l
     * @returns - arrow of 6 lines points
     */
    nextValue(o, c, h, l) {
        this.localCounter++;
        // Apply line directives got on prevues step
        if (this.lLineDirectives.length > 0) {
            // TODO Fork only last line in Array
            this.lLineDirectives.forEach((d, i) => {
                let theLine = this.lines.id[d.lineIndex];
                if (d.condition == 'gt' && l > d.value && d.action == 'fork') {
                    if (theLine) {
                        if (d.lineIndex != undefined && theLine != undefined && theLine.k < 0)
                            this.lines.add(null, l, this.i - 1, this.prevPoint, d.lineIndex); // New extremum found
                        else {
                            theLine.forked = true;
                            theLine.forkedAt = theLine.thisPoint.x;
                            theLine.forkedValue = theLine.thisPoint.y;
                            this.lines.add(null, l, this.i - 1, this.prevPoint);
                        }
                    }
                }
            });
        }
        if (this.hLineDirectives.length > 0) {
            this.hLineDirectives.forEach((d, i) => {
                let theLine = this.lines.id[d.lineIndex];
                if (d.condition == 'lt' && h < d.value && d.action == 'fork') {
                    if (theLine) {
                        if (theLine.k > 0)
                            // New extremum found
                            this.lines.add(h, null, this.i - 1, this.prevPoint, d.lineIndex);
                        else {
                            theLine.forked = true;
                            theLine.forkedAt = theLine.thisPoint.x;
                            theLine.forkedValue = theLine.thisPoint.y;
                            this.lines.add(h, null, this.i - 1, this.prevPoint);
                        }
                    }
                }
            });
        }
        // Update lines and get future directives
        this.hLineDirectives.length = 0;
        this.lLineDirectives.length = 0;
        if (this.lines.list[0].length < 1) {
            this.lines.add(h, null, this.i);
            this.lines.add(null, l, this.i);
        }
        else {
            let updated;
            this.lines.list.forEach((ofLines) => ofLines.forEach((lineID) => {
                let theLine = this.lines.id[lineID];
                if (theLine && theLine.type) {
                    updated = null;
                    if (theLine && theLine.startPoint.x < this.i)
                        // Skip the case if line was just created. TODO make it gracefully
                        updated = this.lines.update(lineID, h, l, this.i);
                    let type = theLine.type;
                    if (updated)
                        type == 'h' ? this.hLineDirectives.push(updated) : this.lLineDirectives.push(updated);
                }
            }));
        }
        //Delete passed lines
        let toDelete = [];
        this.lines.list.forEach((ofLines) => {
            if (ofLines) {
                toDelete = [];
                ofLines.forEach((lineID, i) => {
                    let thisLine = this.lines.id[ofLines[i]];
                    let prevLine = this.lines.id[ofLines[i - 1]];
                    if ((i > 0 &&
                        thisLine &&
                        prevLine &&
                        thisLine.type == 'h' &&
                        thisLine.thisPoint &&
                        prevLine.thisPoint.y <= thisLine.thisPoint.y) ||
                        i > this.env.maxForks ||
                        (i > 0 &&
                            thisLine &&
                            prevLine &&
                            thisLine.type == 'l' &&
                            thisLine.thisPoint &&
                            prevLine.thisPoint.y >= thisLine.thisPoint.y) ||
                        i > this.env.maxForks) {
                        toDelete.push(lineID);
                    }
                });
                toDelete.forEach((lineID) => this.lines.delete(lineID));
            }
        });
        this.prevPoint = {
            x: this.i,
            h: h,
            l: l,
        };
        // Estimate trend
        this.trend.update(this.lines.list[0], this.lines.list[1]);
        this.i++;
        // Return result
        return this.lines;
    }
}

var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Indicator: Indicator
});

/**
 * Circular buffers (also known as ring buffers) are fixed-size buffers that work as if the memory is contiguous & circular in nature.
 * As memory is generated and consumed, data does not need to be reshuffled – rather, the head/tail pointers are adjusted.
 * When data is added, the head pointer advances. When data is consumed, the tail pointer advances.
 * If you reach the end of the buffer, the pointers simply wrap around to the beginning.
 */
class CircularBuffer {
    /**
     * Constructor
     * @param length fixed buffer length
     */
    constructor(length) {
        this.length = length;
        this.filled = false;
        this.pointer = 0;
        this.buffer = new Array(length);
        this.maxIndex = length - 1;
    }
    /**
     * Push item to buffer, when buffer length is overflow, push will rewrite oldest item
     */
    push(item) {
        const overwrited = this.buffer[this.pointer];
        this.buffer[this.pointer] = item;
        this.iteratorNext();
        return overwrited;
    }
    /**
     * Replace last added item in buffer (reversal push). May be used for revert push removed item.
     * @deprecated use peek instead
     */
    pushback(item) {
        this.iteratorPrev();
        const overwrited = this.buffer[this.pointer];
        this.buffer[this.pointer] = item;
        return overwrited;
    }
    /**
     * Get item for replacing, does not modify anything
     */
    peek() {
        return this.buffer[this.pointer];
    }
    /**
     * Array like forEach loop
     */
    forEach(callback) {
        let idx = this.pointer;
        let virtualIdx = 0;
        while (virtualIdx !== this.length) {
            callback(this.buffer[idx], virtualIdx);
            idx = (this.length + idx + 1) % this.length;
            virtualIdx++;
        }
    }
    /**
     * Array like forEach loop, but from last to first (reversal forEach)
     */
    forEachRight(callback) {
        let idx = (this.length + this.pointer - 1) % this.length;
        let virtualIdx = this.length - 1;
        while (virtualIdx !== this.length) {
            callback(this.buffer[idx], virtualIdx);
            idx = (this.length + idx - 1) % this.length;
            virtualIdx--;
        }
    }
    /**
     * Fill buffer
     */
    fill(item) {
        this.buffer.fill(item);
        this.filled = true;
    }
    /**
     * Get array from buffer
     */
    toArray() {
        return this.buffer;
    }
    /**
     * Move iterator to next position
     */
    iteratorNext() {
        this.pointer++;
        if (this.pointer > this.maxIndex) {
            this.pointer = 0;
            this.filled = true;
        }
    }
    /**
     * Move iterator to prev position
     */
    iteratorPrev() {
        this.pointer--;
        if (this.pointer < 0) {
            this.pointer = this.maxIndex;
        }
    }
}

class Extremums extends CircularBuffer {
    constructor(period = 100, mode) {
        super(period);
        this.period = period;
        this.mode = mode;
        this.comparator = mode === 'max' ? this.maxComporator : this.mminComporator;
    }
    nextValue(value) {
        this.push(value);
        return this.getExtremum();
    }
    momentValue(value) {
        const rm = this.push(value);
        const extr = this.getExtremum();
        this.pushback(rm);
        return extr;
    }
    maxComporator(a, b) {
        if (a > b) {
            return true;
        }
        return false;
    }
    mminComporator(a, b) {
        if (a < b) {
            return true;
        }
        return false;
    }
    getExtremum(shallow) {
        let extremumIdx = (this.length + this.pointer - 2) % this.length;
        let extremum = this.mode === 'max' ? -Infinity : Infinity;
        if (!this.filled) {
            return 0;
        }
        while (extremumIdx !== this.pointer) {
            const before = this.buffer[(this.length + extremumIdx - 1) % this.length];
            const after = this.buffer[(this.length + extremumIdx + 1) % this.length];
            const foundExtremum = this.buffer[extremumIdx];
            if (this.comparator(foundExtremum, extremum) &&
                this.comparator(foundExtremum, before) &&
                this.comparator(foundExtremum, after)) {
                extremum = foundExtremum;
                if (this.prevIx === extremumIdx) {
                    return null;
                }
                this.prevIx = extremumIdx;
                if (shallow) {
                    return extremum;
                }
            }
            extremumIdx = (this.length + extremumIdx - 1) % this.length;
        }
        if (isFinite(extremum)) {
            return extremum;
        }
        this.prevIx = null;
        return null;
    }
}

// console.log(sma([1, 2, 3, 4, 5, 6, 7, 8, 9], 4));
//=> [ '2.50', '3.50', '4.50', '5.50', '6.50', '7.50' ]
//=>   │       │       │       │       │       └─(6+7+8+9)/4
//=>   │       │       │       │       └─(5+6+7+8)/4
//=>   │       │       │       └─(4+5+6+7)/4
//=>   │       │       └─(3+4+5+6)/4
//=>   │       └─(2+3+4+5)/4
//=>   └─(1+2+3+4)/4
class SMA {
    constructor(period) {
        this.period = period;
        this.sum = 0;
        this.circular = new CircularBuffer(period);
    }
    nextValue(value) {
        this.circular.push(value);
        this.sum += value;
        if (!this.circular.filled) {
            return;
        }
        this.nextValue = (value) => {
            this.sum = this.sum - this.circular.push(value) + value;
            return this.sum / this.period;
        };
        this.momentValue = (value) => {
            return (this.sum - this.circular.peek() + value) / this.period;
        };
        return this.sum / this.period;
    }
    momentValue(value) {
        return;
    }
}

/**
 * The WEMA (Wilder's Smoothed Moving Average) is a powerful indicator based on the Simple Moving Average indicator.
 * The Simple Moving Average (SMA) indicator is useful to identify the start and reversal of a trend.
 */
class WEMA {
    constructor(period) {
        this.period = period;
        this.smooth = 1 / this.period;
        this.sma = new SMA(this.period);
    }
    /**
     * Get next value for closed candle hlc
     * affect all next calculations
     */
    nextValue(value) {
        if (!this.wema) {
            return (this.wema = this.sma.nextValue(value));
        }
        return (this.wema = (value - this.wema) * this.smooth + this.wema);
    }
    /**
     * Get next value for non closed (tick) candle hlc
     * does not affect any next calculations
     */
    momentValue(value) {
        if (!this.wema) {
            return this.sma.momentValue(value);
        }
        return (value - this.wema) * this.smooth + this.wema;
    }
}

/**
 * An exponential moving average (EMA) is a type of moving average (MA)
 * that places a greater weight and significance on the most recent data points.
 * The exponential moving average is also referred to as the exponentially weighted moving average.
 * An exponentially weighted moving average reacts more significantly to recent price changes
 * than a simple moving average (SMA), which applies an equal weight to all observations in the period.
 */
class EMA {
    constructor(period) {
        this.period = period;
        this.smooth = 2 / (this.period + 1);
        this.sma = new SMA(this.period);
    }
    /**
     * Get next value for closed candle hlc
     * affect all next calculations
     */
    nextValue(value) {
        const sma = this.sma.nextValue(value);
        if (sma) {
            this.ema = sma;
            this.nextValue = (value) => {
                return (this.ema = (value - this.ema) * this.smooth + this.ema);
            };
            this.momentValue = (value) => {
                return (value - this.ema) * this.smooth + this.ema;
            };
        }
        return sma;
    }
    /**
     * Get next value for non closed (tick) candle hlc
     * does not affect any next calculations
     */
    momentValue(value) {
        return;
    }
}

/**
 * Sampler class for using with simple indicators like SMA, EMA, which nextValue arguments is number and
 * return type also number. Can be user for replace SMA(SMA(SMA(SMA))) calls (sma x4 sample)
 */
class Sampler {
    constructor(indicator, samples) {
        this.indicator = indicator;
        this.samples = samples;
        this._indicators = [];
    }
    /**
     * Create indicator instances for next usage, pass period and other
     * indicator constructor parameters
     */
    create(...args) {
        for (let i = 0; i < this.samples; i++) {
            this._indicators.push(new this.indicator(...args));
        }
    }
    /**
     * Calculate next values to get all samples of current idicator
     */
    nextValue(value) {
        for (let i = 0; i < this.samples; i++) {
            value = this._indicators[i].nextValue(value);
            if (value === undefined) {
                return value;
            }
        }
        return value;
    }
    /**
     * Get immediate value
     */
    momentValue(value) {
        for (let i = 0; i < this.samples; i++) {
            value = this._indicators[i].momentValue(value);
            if (value === undefined || value === null) {
                return value;
            }
        }
        return value;
    }
}

/**
 * Level creation for dynamic data, upper and lower (configurated)
 */
class UniLevel {
    constructor(redunant = 0.85, indicator, samples, multiplier = 1, offset = 1) {
        this.redunant = redunant;
        this.multiplier = multiplier;
        this.offset = offset;
        this.prevValue = 0;
        this.lastUpperValue = 0;
        this.lastLowerValue = 0;
        this.samplerUp = new Sampler(indicator, samples);
        this.samplerLow = new Sampler(indicator, samples);
    }
    create(...args) {
        this.samplerUp.create(...args);
        this.samplerLow.create(...args);
    }
    nextValue(value) {
        if (value > 0) {
            this.lastUpperValue = Math.max(value, this.prevValue);
        }
        else {
            this.lastUpperValue = Math.max(0, this.lastUpperValue) * this.redunant;
        }
        if (value <= 0)
            this.lastLowerValue = Math.min(value, this.prevValue);
        else {
            this.lastLowerValue = Math.min(0, this.lastLowerValue) * this.redunant;
        }
        const low = (value <= 0 ? value : this.lastLowerValue) * this.multiplier;
        const up = (value >= 0 ? value : this.lastUpperValue) * this.multiplier;
        return [this.samplerUp.nextValue(up) + this.offset, this.samplerLow.nextValue(low) - this.offset];
    }
}
/**
 * Smoothed level creation for dynamic data
 * @deprecated
 */
class Level {
    constructor(period, samples, redunant = 0.85, type = 'WEMA') {
        this.period = period;
        this.samples = samples;
        this.redunant = redunant;
        this.type = type;
        this.upper = 0;
        this.lower = 0;
        this.lastUpperValue = 0;
        this.lastLowerValue = 0;
        this.sample1Up = this.createSample();
        this.sample2Up = this.createSample();
        this.sample3Up = this.createSample();
        this.sample1Low = this.createSample();
        this.sample2Low = this.createSample();
        this.sample3Low = this.createSample();
    }
    nextValue(value) {
        if (value > 0) {
            this.upper = this.getUp(value);
            this.lastLowerValue *= this.redunant;
            this.lower = this.getDown(this.lastLowerValue);
            this.lastUpperValue = value;
        }
        else if (value < 0) {
            this.lower = this.getDown(value);
            this.lastUpperValue *= this.redunant;
            this.upper = this.getUp(this.lastUpperValue);
            this.lastLowerValue = value;
        }
        return { upper: this.upper, lower: this.lower };
    }
    getUp(value) {
        const sample1 = this.sample1Up.nextValue(value);
        let sample2 = null;
        if (this.samples === 1) {
            return sample1;
        }
        if (sample1) {
            sample2 = this.sample2Up.nextValue(sample1);
        }
        if (this.samples === 2) {
            return sample2;
        }
        if (sample2) {
            return this.sample3Up.nextValue(sample2);
        }
        return null;
    }
    getDown(value) {
        const sample1 = this.sample1Low.nextValue(value);
        let sample2 = null;
        if (this.samples === 1) {
            return sample1;
        }
        if (sample1) {
            sample2 = this.sample2Low.nextValue(sample1);
        }
        if (this.samples === 2) {
            return sample2;
        }
        if (sample2) {
            return this.sample3Low.nextValue(sample2);
        }
        return null;
    }
    createSample() {
        switch (this.type) {
            case 'EMA':
                return new EMA(this.period);
            case 'WEMA':
                return new WEMA(this.period);
            case 'SMA':
                return new SMA(this.period);
        }
    }
}

class Correlation {
    constructor(period) {
        this.period = period;
        this.SMAx = new SMA(this.period);
        this.SMAy = new SMA(this.period);
        this.pricesX = new CircularBuffer(this.period);
        this.pricesY = new CircularBuffer(this.period);
    }
    nextValue(priceX, priceY) {
        this.pricesX.push(priceX);
        this.pricesY.push(priceY);
        this.SMAxValue = this.SMAx.nextValue(priceX);
        this.SMAyValue = this.SMAy.nextValue(priceY);
        let SSxy = 0;
        let SSxx = 0;
        let SSyy = 0;
        for (let i = 0; i < this.period; i++) {
            const xPrice = this.pricesX.toArray()[i];
            const yPrice = this.pricesY.toArray()[i];
            SSxy += (xPrice - this.SMAxValue) * (yPrice - this.SMAyValue);
            SSxx += (xPrice - this.SMAxValue) ** 2;
            SSyy += (yPrice - this.SMAyValue) ** 2;
        }
        return SSxy / Math.sqrt(SSxx * SSyy);
    }
}

/**
 * Weighted moving average (WMA) assign a heavier weighting to more current data points since they are more relevant than data points
 * in the distant past. The sum of the weighting should add up to 1 (or 100%).
 * In the case of the simple moving average, the weightings are equally distributed, which is why they are not shown in the table above.
 */
class WMA {
    constructor(period) {
        this.period = period;
        this.denominator = (period * (period + 1)) / 2;
        this.buffer = new CircularBuffer(period);
        this.values = [];
    }
    /**
     * Get next value for closed candle hlc
     * affect all next calculations
     */
    nextValue(value) {
        this.buffer.push(value);
        if (!this.buffer.filled) {
            return;
        }
        let result = 0;
        this.buffer.forEach((v, idx) => {
            result += (v * (idx + 1)) / this.denominator;
        });
        return result;
    }
    /**
     * Get next value for non closed (tick) candle hlc
     * does not affect any next calculations
     */
    momentValue(value) {
        const removed = this.buffer.push(value);
        if (!this.buffer.filled) {
            this.buffer.pushback(removed);
            return;
        }
        let result = 0;
        this.buffer.forEach((v, idx) => {
            result += (v * (idx + 1)) / this.denominator;
        });
        this.buffer.pushback(removed);
        return result;
    }
}

/**
 * The Exponentially Weighted Moving Average (EWMA) is a quantitative or statistical measure used to model or describe
 * a time series. The EWMA is widely used in finance, the main applications being technical analysis and volatility modeling.
 * The moving average is designed as such that older observations are given lower weights.
 * The weights fall exponentially as the data point gets older – hence the name exponentially weighted.
 * The only decision a user of the EWMA must make is the parameter alpha.
 * The parameter decides how important the current observation is in the calculation of the EWMA.
 * The higher the value of alpha, the more closely the EWMA tracks the original time series.
 * @param alpha must be from 0 to 1
 */
class EWMA {
    constructor(alpha = 0.2) {
        this.alpha = alpha;
        this.filled = false;
    }
    nextValue(value) {
        const ewma = this.alpha * value + (1 - this.alpha) * (this.prevValue || 1);
        this.filled = this.filled || this.prevValue !== undefined;
        this.prevValue = ewma;
        if (this.filled) {
            return ewma;
        }
    }
    momentValue(value) {
        if (this.filled) {
            return this.alpha * value + (1 - this.alpha) * (this.prevValue || 1);
        }
    }
}

/**
 * SMMA (Smoothed Moving Average) is another popular and widely used moving average indicator.
 * As all the other moving average indicators, to achieve the goals, the indicator filters
 * out the market fluctuations (noises) by averaging the price values of the periods, over which it is calculated.
 */
class SMMA {
    constructor(period) {
        this.period = period;
        this.sum = 0;
        this.avg = 0;
        this.filled = false;
        this.fill = 0;
    }
    nextValue(value) {
        if (this.filled) {
            this.nextValue = (value) => (this.avg = (this.avg * (this.period - 1) + value) / this.period);
            return this.nextValue(value);
        }
        this.sum += value;
        this.fill++;
        if (this.fill === this.period) {
            this.filled = true;
            this.avg = this.sum / this.period;
            return this.avg;
        }
    }
    momentValue(value) {
        if (!this.filled) {
            return;
        }
        return (this.avg * (this.period - 1) + value) / this.period;
    }
}

/**
 * Relative Moving Average adds more weight to recent data (and gives less importance to older data).
 * This makes the RMA similar to the Exponential Moving Average, although it’s somewhat slower to respond than an EMA is.
 */
class RMA {
    constructor(period = 14) {
        this.period = period;
        this.alpha = 1 / period;
        this.sma = new SMA(this.period);
    }
    nextValue(value) {
        if (!this.prevValue) {
            this.prevValue = this.sma.nextValue(value);
        }
        else {
            this.prevValue = this.alpha * value + (1 - this.alpha) * this.prevValue;
            this.nextValue = (value) => {
                this.prevValue = this.alpha * value + (1 - this.alpha) * this.prevValue;
                return this.prevValue;
            };
        }
        return this.prevValue;
    }
    momentValue(value) {
        if (this.prevValue) {
            return this.alpha * value + (1 - this.alpha) * this.prevValue;
        }
    }
}

/**
 Awesome Oscillator (AO) is an indicator that is non-limiting oscillator,
 providing insight into the weakness or the strength of a stock.
 The Awesome Oscillator is used to measure market momentum and
 to affirm trends or to anticipate possible reversals.
 */
class AO {
    constructor(fastPeriod = 5, slowPeriod = 34) {
        this.smaSlow = new SMA(slowPeriod);
        this.smaFast = new SMA(fastPeriod);
    }
    nextValue(high, low) {
        this.smaSlowValue = this.smaSlow.nextValue((high + low) / 2);
        this.smaFastValue = this.smaFast.nextValue((high + low) / 2);
        if (this.smaSlowValue === undefined || this.smaFastValue === undefined) {
            return;
        }
        this.nextValue = (high, low) => {
            this.smaSlowValue = this.smaSlow.nextValue((high + low) / 2);
            this.smaFastValue = this.smaFast.nextValue((high + low) / 2);
            return this.smaFastValue - this.smaSlowValue;
        };
        this.momentValue = (high, low) => {
            return this.smaFast.momentValue((high + low) / 2) - this.smaSlow.momentValue((high + low) / 2);
        };
        return this.smaFastValue - this.smaSlowValue;
    }
    momentValue(high, low) {
        return;
    }
}

/**
 The Accelerator Oscillator (AC indicator) is a technical analysis tool that helps
 to gauge the momentum in the market. It also helps to predict when the momentum will change.
 */
class AC {
    constructor() {
        this.sma = new SMA(5);
        this.ao = new AO();
    }
    nextValue(high, low) {
        this.aoValue = this.ao.nextValue(high, low);
        if (this.aoValue === undefined) {
            return;
        }
        this.smaValue = this.sma.nextValue(this.aoValue);
        if (this.smaValue === undefined) {
            return;
        }
        // Performance hack with method overrides speed up +30_000 op/sec
        this.nextValue = (high, low) => {
            this.aoValue = this.ao.nextValue(high, low);
            this.smaValue = this.sma.nextValue(this.aoValue);
            return this.aoValue - this.smaValue;
        };
        // Performance hack with method overrides
        this.momentValue = (high, low) => {
            return this.ao.momentValue(high, low) - this.sma.momentValue(this.aoValue);
        };
        return this.aoValue - this.smaValue;
    }
    momentValue(high, low) {
        return;
    }
}

/**
 * Money Flow Index (MFI) is a movement indicator used in technical analysis that looks at time and price
 * to measure the trading pressure — buying or selling. It is also called volume-weighted
 * Relative Strength Index (RSI), as it includes volume, unlike RSI, which only incorporates price.
 */
class MFI {
    constructor(period = 14) {
        this.positiveMoneyFlowSum = 0;
        this.negativeMoneyFlowSum = 0;
        this.pevTypicalPrice = 0;
        this.posCircular = new CircularBuffer(period);
        this.negCircular = new CircularBuffer(period);
    }
    nextValue(high, low, close, volume) {
        const typicalPrice = (high + low + close) / 3;
        const moneyFlow = typicalPrice * volume;
        if (!this.pevTypicalPrice) {
            this.pevTypicalPrice = typicalPrice;
            return;
        }
        const positiveMoneyFlow = typicalPrice > this.pevTypicalPrice ? moneyFlow : 0;
        const negativeMoneyFlow = typicalPrice < this.pevTypicalPrice ? moneyFlow : 0;
        this.pevTypicalPrice = typicalPrice;
        this.negativeMoneyFlowSum += negativeMoneyFlow;
        this.positiveMoneyFlowSum += positiveMoneyFlow;
        const posRedunant = this.posCircular.push(positiveMoneyFlow);
        const negRedunant = this.negCircular.push(negativeMoneyFlow);
        if (!this.posCircular.filled) {
            return;
        }
        this.negativeMoneyFlowSum -= negRedunant || 0;
        this.positiveMoneyFlowSum -= posRedunant || 0;
        const moneyFlowRatio = this.positiveMoneyFlowSum / this.negativeMoneyFlowSum;
        return 100 - 100 / (1 + moneyFlowRatio);
    }
    momentValue(high, low, close, volume) {
        const typicalPrice = (high + low + close) / 3;
        const moneyFlow = typicalPrice * volume;
        if (!this.pevTypicalPrice) {
            return;
        }
        const positiveMoneyFlow = typicalPrice > this.pevTypicalPrice ? moneyFlow : 0;
        const negativeMoneyFlow = typicalPrice < this.pevTypicalPrice ? moneyFlow : 0;
        if (!this.posCircular.filled) {
            return;
        }
        const posRedunant = this.posCircular.peek();
        const negRedunant = this.negCircular.peek();
        const negativeMoneyFlowSum = this.negativeMoneyFlowSum + negativeMoneyFlow - negRedunant;
        const positiveMoneyFlowSum = this.positiveMoneyFlowSum + positiveMoneyFlow - posRedunant;
        const moneyFlowRatio = positiveMoneyFlowSum / negativeMoneyFlowSum;
        return 100 - 100 / (1 + moneyFlowRatio);
    }
}

function sum(arr) {
    let sum = 0;
    let i = arr.length;
    while (i > 0) {
        sum += arr[--i];
    }
    return sum;
}
const percentChange = (current, prev) => ((current - prev) / prev) * 100;
const getMax = (arr) => {
    let max = -Infinity;
    for (let i = arr.length - 1; i >= 0; i--) {
        const item = arr[i];
        if (max < item) {
            max = item;
        }
    }
    return max;
};
const getMin = (arr) => {
    let min = Infinity;
    for (let i = arr.length - 1; i >= 0; i--) {
        const item = arr[i];
        if (min > item) {
            min = item;
        }
    }
    return min;
};

class Move {
    /**
     * Конструктор
     * @param period - целочисленное значение от 1 до  12
     * @param period - период
     */
    constructor(period) {
        this.period = period;
        this.value = 0;
        this.changes = new CircularBuffer(period);
    }
    nextValue(close) {
        if (this.prevPrice) {
            const change = percentChange(close, this.prevPrice);
            this.calculate(change);
            this.prevPrice = close;
            return this.value;
        }
        this.prevPrice = close;
    }
    calculate(change) {
        this.value += change;
        this.value -= this.changes.push(change);
        return this.value;
    }
}

function clenWave(wave) {
    wave.consolidate = 0;
    wave.power = 0;
    wave.streak = 0;
    wave.diff = 0;
    wave.startPrice = 0;
    wave.prevPeak = 0;
    return wave;
}
class Wave {
    /**
     * Конструктор
     */
    constructor() {
        this.up = { consolidate: 0, power: 0, streak: 0, startPrice: 0, diff: 0, prevPeak: 0 };
        this.down = { consolidate: 0, power: 0, streak: 0, startPrice: 0, diff: 0, prevPeak: 0 };
    }
    nextValue(open, close, high, low) {
        // bullish
        if (open < close || (this.up.streak && this.up.prevPeak < low)) {
            if (!this.up.startPrice) {
                this.up.startPrice = open;
            }
            if (this.down.streak) {
                clenWave(this.down);
            }
            const diff = close - open;
            this.up.streak++;
            this.up.prevPeak = low;
            if (this.up.diff > diff) {
                this.up.consolidate++;
            }
            else {
                this.up.consolidate = 0;
            }
            this.up.diff = diff;
            this.up.power = percentChange(close, this.up.startPrice);
        }
        // bearish
        if (open > close || (this.down.streak && this.down.prevPeak > high)) {
            if (!this.down.startPrice) {
                this.down.startPrice = open;
            }
            if (this.up.streak) {
                clenWave(this.up);
            }
            const diff = open - close;
            this.down.streak++;
            this.down.prevPeak = high;
            if (this.down.diff > diff) {
                this.down.consolidate++;
            }
            else {
                this.down.consolidate = 0;
            }
            this.down.diff = diff;
            this.down.power = percentChange(close, this.down.startPrice);
        }
        // doji is neutral
        if (open === close) {
            this.up.streak++;
            this.down.streak++;
            this.up.diff = this.down.diff = 0;
        }
        if (this.up.streak > this.down.streak) {
            return { ...this.up };
        }
        else {
            return { ...this.down };
        }
    }
}

/**
 * Provider for fast detection highs and lows in period
 */
class MaxProvider {
    constructor(period) {
        this.max = -Infinity;
        this.highest = new CircularBuffer(period);
    }
    filled() {
        return this.highest.filled;
    }
    nextValue(high) {
        if (this.max < high) {
            this.max = high;
        }
        const rmMax = this.highest.push(high);
        // Most perf degrade case
        if (rmMax === this.max && high !== this.max) {
            // console.count('degrade_max');
            this.max = getMax(this.highest.toArray());
        }
        return this.max;
    }
    momentValue(high) {
        return this.max > high ? this.max : high;
    }
}

/**
 * Provider for fast detection highs and lows in period
 */
class MinProvider {
    constructor(period) {
        this.min = Infinity;
        this.lowest = new CircularBuffer(period);
    }
    filled() {
        return this.lowest.filled;
    }
    nextValue(low) {
        if (this.min > low) {
            this.min = low;
        }
        const rmMin = this.lowest.push(low);
        // Most perf degrade case
        if (rmMin === this.min && low !== this.min) {
            this.min = getMin(this.lowest.toArray());
            // console.count('degrade_min');
        }
        return this.min;
    }
    momentValue(low) {
        return this.min < low ? this.min : low;
    }
}

/**
 * A stochastic oscillator is a momentum indicator comparing a particular closing price
 * of a security to a range of its prices over a certain period of time.
 * The sensitivity of the oscillator to market movements is reducible by adjusting that
 * time period or by taking a moving average of the result.
 * It is used to generate overbought and oversold trading signals,
 * utilizing a 0-100 bounded range of values.
 */
class Stochastic {
    constructor(period = 14, smaPeriod = 3) {
        this.period = period;
        this.smaPeriod = smaPeriod;
        this.sma = new SMA(this.smaPeriod);
        this.max = new MaxProvider(period);
        this.min = new MinProvider(period);
    }
    /**
     * Get next value for closed candle hlc
     * affect all next calculations
     */
    nextValue(high, low, close) {
        const max = this.max.nextValue(high);
        const min = this.min.nextValue(low);
        if (!this.max.filled()) {
            return;
        }
        const k = ((close - min) / (max - min)) * 100;
        const d = this.sma.nextValue(k);
        return { k, d };
    }
    /**
     * Get next value for non closed (tick) candle hlc
     * does not affect any next calculations
     */
    momentValue(high, low, close) {
        if (!this.max.filled()) {
            return;
        }
        const max = this.max.momentValue(high);
        const min = this.min.momentValue(low);
        const k = ((close - min) / (max - min)) * 100;
        const d = this.sma.momentValue(k);
        return { k, d };
    }
}

class AvgChangeProvider {
    constructor(period) {
        this.avgGain = new SMMA(period);
        this.avgLoss = new SMMA(period);
    }
    nextValue(value) {
        const change = value - this.prev;
        if (!this.prev) {
            this.prev = value;
            return;
        }
        const isPositive = change > 0;
        const isNegative = change < 0;
        const localGain = isPositive ? change : 0;
        const localLoss = isNegative ? change : 0;
        const upAvg = this.avgGain.nextValue(localGain);
        const downAvg = this.avgLoss.nextValue(localLoss);
        this.prev = value;
        return { upAvg, downAvg };
    }
    momentValue(value) {
        const change = value - this.prev;
        const isPositive = change > 0;
        const isNegative = change < 0;
        const localGain = isPositive ? change : 0;
        const localLoss = isNegative ? change : 0;
        const upAvg = this.avgGain.momentValue(localGain);
        const downAvg = this.avgLoss.momentValue(localLoss);
        return { upAvg, downAvg };
    }
}

/**
 * The relative strength index (RSI) is a momentum indicator used in technical analysis
 * that measures the magnitude of recent price changes to evaluate overbought or oversold conditions
 * in the price of a stock or other asset. The RSI is displayed as an oscillator
 * (a line graph that moves between two extremes) and can have a reading from 0 to 100.
 * The indicator was originally developed by J. Welles Wilder Jr. and introduced in his seminal 1978 book,
 * "New Concepts in Technical Trading Systems."
 *
 * Traditional interpretation and usage of the RSI are that values of 70 or above indicate
 * that a security is becoming overbought or overvalued and may be primed
 * for a trend reversal or corrective pullback in price.
 * An RSI reading of 30 or below indicates an oversold or undervalued condition.
 */
class RSI {
    constructor(period = 14) {
        this.period = period;
        this.change = new AvgChangeProvider(this.period);
    }
    nextValue(value) {
        const { downAvg, upAvg } = this.change.nextValue(value) || {};
        if (upAvg === undefined || downAvg === undefined) {
            return;
        }
        const RS = upAvg / -downAvg;
        return 100 - 100 / (1 + RS);
    }
    momentValue(value) {
        const { downAvg, upAvg } = this.change.momentValue(value) || {};
        if (upAvg === undefined || downAvg === undefined) {
            return;
        }
        const RS = upAvg / -downAvg;
        return 100 - 100 / (1 + RS);
    }
}

/**
 * Developed by Tushar Chande and Stanley Kroll, StochRSI is an oscillator that measures the level of RSI relative
 * to its high-low range over a set time period. StochRSI applies the Stochastics formula to RSI values, rather
 * than price values, making it an indicator of an indicator. The result is an oscillator that
 * fluctuates between 0 and 1.
 */
class StochasticRSI {
    constructor(rsiPeriod = 14, kPeriod = 3, dPeriod = 3, stochPeriod = 14) {
        this.rsi = new RSI(rsiPeriod);
        this.sma1 = new SMA(kPeriod);
        this.sma2 = new SMA(dPeriod);
        this.max = new MaxProvider(stochPeriod);
        this.min = new MinProvider(stochPeriod);
    }
    /**
     * Get next value for closed candle
     * affect all next calculations
     */
    nextValue(close) {
        const rsi = this.rsi.nextValue(close);
        if (rsi === undefined) {
            return;
        }
        const max = this.max.nextValue(rsi);
        const min = this.min.nextValue(rsi);
        if (!this.max.filled()) {
            return;
        }
        const stochRsi = ((rsi - min) / (max - min)) * 100;
        const k = this.sma1.nextValue(stochRsi);
        if (k === undefined) {
            return;
        }
        const d = this.sma2.nextValue(k);
        return { k, d, stochRsi };
    }
    /**
     * Get next value for non closed (tick) candle hlc
     * does not affect any next calculations
     */
    momentValue(close) {
        if (!this.max.filled()) {
            return;
        }
        const rsi = this.rsi.momentValue(close);
        const max = this.max.momentValue(rsi);
        const min = this.min.momentValue(rsi);
        const stochRsi = ((rsi - min) / (max - min)) * 100;
        const k = this.sma1.momentValue(stochRsi);
        const d = this.sma2.momentValue(k);
        return { k, d, stochRsi };
    }
}

class MeanDeviationProvider {
    constructor(period) {
        this.period = period;
        this.values = new CircularBuffer(period);
    }
    nextValue(typicalPrice, average) {
        if (!average) {
            this.values.push(typicalPrice);
            return void 0;
        }
        this.nextValue = this.pureNextValue;
        this.momentValue = this.pureMomentValue;
        return this.pureNextValue(typicalPrice, average);
    }
    momentValue(typicalPrice, average) {
        return void 0;
    }
    pureNextValue(typicalPrice, average) {
        this.values.push(typicalPrice);
        return this.values.toArray().reduce((acc, value) => acc + this.positiveDelta(average, value), 0) / this.period;
    }
    pureMomentValue(typicalPrice, average) {
        const rm = this.values.push(typicalPrice);
        const mean = this.values.toArray().reduce((acc, value) => acc + this.positiveDelta(average, value), 0);
        this.values.pushback(rm);
        return mean / this.period;
    }
    positiveDelta(a, b) {
        return a > b ? a - b : b - a;
    }
}

/**
 * The CCI, or Commodity Channel Index, was developed by Donald Lambert,
 * a technical analyst who originally published the indicator in Commodities magazine (now Futures)
 * in 1980.1 Despite its name, the CCI can be used in any market and is not just for commodities
 */
class CCI {
    constructor(period = 20) {
        this.md = new MeanDeviationProvider(period);
        this.sma = new SMA(period);
    }
    nextValue(high, low, close) {
        const typicalPrice = (high + low + close) / 3;
        const average = this.sma.nextValue(typicalPrice);
        const meanDeviation = this.md.nextValue(typicalPrice, average);
        return meanDeviation && (typicalPrice - average) / (0.015 * meanDeviation);
    }
    momentValue(high, low, close) {
        const typicalPrice = (high + low + close) / 3;
        const average = this.sma.momentValue(typicalPrice);
        const meanDeviation = this.md.momentValue(typicalPrice, average);
        return meanDeviation && (typicalPrice - average) / (0.015 * meanDeviation);
    }
}

/**
 * A linearly weighted moving average (LWMA) is a moving average calculation that more heavily weights recent price data.
 * The most recent price has the highest weighting, and each prior price has progressively less weight.
 * The weights drop in a linear fashion.
 * LWMAs are quicker to react to price changes than simple moving averages (SMA) and exponential moving averages (EMA).
 */
class LWMA {
    constructor(period) {
        this.period = period;
        // Circular buffer ned foreach or reduce for that case
        this.arr = [];
        this.filled = false;
        this.devider = 0;
        this.lastSum = 0;
        this.devider = sum(Array.from(Array(this.period).keys()).map((i) => i + 1));
    }
    nextValue(value) {
        this.filled = this.filled || this.arr.length === this.period;
        this.arr.push(value);
        if (this.filled) {
            this.arr.shift();
            return this.arr.reduce((sum, value, idx) => sum + value * (idx + 1), 0) / this.devider;
        }
    }
    momentValue(value) {
        if (this.filled) {
            const arr = this.arr.slice(1);
            arr.push(value);
            return arr.reduce((sum, value, idx) => sum + value * (idx + 1), 0) / this.devider;
        }
    }
}

/**
 * True range calculation
 */
function getTrueRange(high, low, prevClose) {
    if (prevClose) {
        // Linear conditions without max min and abs
        // Perormance reason
        const hl = high - low;
        const hc = high > prevClose ? high - prevClose : prevClose - high;
        const lc = low > prevClose ? low - prevClose : prevClose - low;
        if (hl >= hc && hl >= lc) {
            return hl;
        }
        if (hc >= hl && hc >= lc) {
            return hc;
        }
        return lc;
    }
    return;
}

class ATR {
    /**
     * Конструктор
     * @param period - период по умолчанию 14
     */
    constructor(period = 14, smoothing = 'WEMA') {
        switch (smoothing) {
            case 'SMA':
                this.avg = new SMA(period);
                break;
            case 'EMA':
                this.avg = new EMA(period);
                break;
            case 'SMMA':
                this.avg = new SMMA(period);
                break;
            case 'WEMA':
                this.avg = new WEMA(period);
                break;
            case 'LWMA':
                this.avg = new LWMA(period);
                break;
            case 'EWMA':
                this.avg = new EWMA(0.2);
                break;
            case 'RMA':
                this.avg = new RMA(period);
                break;
        }
        this.prevClose = 0;
    }
    nextValue(high, low, close) {
        const trueRange = getTrueRange(high, low, this.prevClose);
        this.prevClose = close;
        if (trueRange === undefined) {
            return;
        }
        return this.avg.nextValue(trueRange);
    }
    momentValue(high, low) {
        const trueRange = getTrueRange(high, low, this.prevClose);
        if (trueRange === undefined) {
            return;
        }
        return this.avg.momentValue(trueRange);
    }
}

/**
 * The Rate-of-Change (ROC) indicator, which is also referred to as simply Momentum,
 * is a pure momentum oscillator that measures the percent change in price from one period to the next.
 * The ROC calculation compares the current price with the price “n” periods ago.
 * The plot forms an oscillator that fluctuates above and below the zero line as the Rate-of-Change moves from positive to negative.
 * As a momentum oscillator, ROC signals include centerline crossovers, divergences and overbought-oversold readings.
 * Divergences fail to foreshadow reversals more often than not, so this article will forgo a detailed discussion on them.
 * Even though centerline crossovers are prone to whipsaw, especially short-term,
 * these crossovers can be used to identify the overall trend.
 * Identifying overbought or oversold extremes comes naturally to the Rate-of-Change oscillator.
 **/
class ROC {
    constructor(period = 5) {
        this.values = new CircularBuffer(period);
    }
    nextValue(value) {
        const outed = this.values.push(value);
        if (outed) {
            return ((value - outed) / outed) * 100;
        }
    }
    momentValue(value) {
        const outed = this.values.peek();
        if (outed) {
            return ((value - outed) / outed) * 100;
        }
    }
}

/**
 * Donchian channels were developed by Richard Donchian, a pioneer of mechanical trend following systems.
 * The two outer bands are plotted as the highest high and lowest low for a set period,
 * originally 20 days, with the optional middle band calculated as the average of the two.
 */
class DC {
    constructor(period = 20) {
        this.maxProvider = new MaxProvider(period);
        this.minProvider = new MinProvider(period);
    }
    nextValue(high, low) {
        const upper = this.maxProvider.nextValue(high);
        const lower = this.minProvider.nextValue(low);
        return { upper, middle: (upper + lower) / 2, lower };
    }
    momentValue(high, low) {
        const upper = this.maxProvider.momentValue(high);
        const lower = this.minProvider.momentValue(low);
        return { upper, middle: (upper + lower) / 2, lower };
    }
}

/**
 * Returns the percentile of a value. Returns the same values as the Excel PERCENTRANK and PERCENTRANK.INC functions.
 */
class PercentRank {
    constructor(period) {
        this.period = period;
        this.fill = 0;
        this.values = new CircularBuffer(period);
    }
    nextValue(value) {
        this.values.push(value);
        this.fill++;
        if (this.fill === this.period) {
            this.nextValue = (value) => {
                const result = this.calc(value);
                this.values.push(value);
                return result;
            };
            this.momentValue = this.calc;
            return this.calc(value);
        }
    }
    momentValue(value) {
        return;
    }
    calc(value) {
        let count = 0;
        this.values.toArray().forEach((item) => {
            if (item <= value)
                count++;
        });
        return (count / this.period) * 100;
    }
}

/**
 * Connors RSI (CRSI) uses the above formula to generate a value between 0 and 100.
 * This is primarily used to identify overbought and oversold levels.
 * Connor's original definition of these levels is that a value over 90
 * should be considered overbought and a value under 10 should be considered oversold.
 * On occasion, signals occur during slight corrections during a trend. For example,
 * when the market is in an uptrend, Connors RSI might generate short term sell signals.
 * When the market is in a downtrend, Connors RSI might generate short term buy signals.
 * Original core here: https://tradingview.com/script/vWAPUAl9-Stochastic-Connors-RSI/
 */
class cRSI {
    constructor(period = 3, updownRsiPeriod = 2, percentRankPeriod = 100) {
        this.period = period;
        this.rsi = new RSI(this.period);
        this.updownRsi = new RSI(updownRsiPeriod);
        this.roc = new ROC(1);
        this.percentRank = new PercentRank(percentRankPeriod);
        this.updownPeriod = 0;
        this.prevClose = 0;
    }
    nextValue(value) {
        const rsi = this.rsi.nextValue(value);
        const percentRank = this.percentRank.nextValue(this.roc.nextValue(value));
        this.updownPeriod = this.getUpdownPeriod(value);
        this.prevClose = value;
        this.updownValue = this.updownRsi.nextValue(this.updownPeriod);
        if (!this.updownValue) {
            return;
        }
        return (rsi + this.updownValue + percentRank) / 3;
    }
    momentValue(value) {
        const rsi = this.rsi.momentValue(value);
        const percentRank = this.percentRank.momentValue(this.roc.momentValue(value));
        const updownPeriod = this.getUpdownPeriod(value);
        const updownValue = this.updownRsi.momentValue(updownPeriod);
        if (updownValue === undefined) {
            return;
        }
        return (rsi + updownValue + percentRank) / 3;
    }
    getUpdownPeriod(value) {
        let updownPeriod = this.updownPeriod;
        if (value > this.prevClose) {
            // reset negative streak
            if (this.updownPeriod < 0) {
                updownPeriod = 0;
            }
            updownPeriod++;
        }
        else if (value < this.prevClose) {
            // reset positive streak
            if (this.updownPeriod > 0) {
                updownPeriod = 0;
            }
            updownPeriod--;
        }
        else {
            updownPeriod = 0;
        }
        return updownPeriod;
    }
}

class StandardDeviation {
    constructor(period) {
        this.period = period;
        this.values = new CircularBuffer(period);
    }
    nextValue(value, mean) {
        this.values.push(value);
        return Math.sqrt(this.values.toArray().reduce((acc, item) => acc + (item - mean) ** 2, 0) / this.period);
    }
    momentValue(value, mean) {
        const rm = this.values.push(value);
        const result = Math.sqrt(this.values.toArray().reduce((acc, item) => acc + (item - mean) ** 2, 0) / this.period);
        this.values.pushback(rm);
        return result;
    }
}

class BollingerBands {
    constructor(period = 20, stdDev = 2) {
        this.period = period;
        this.stdDev = stdDev;
        this.fill = 0;
        this.sma = new SMA(period);
        this.sd = new StandardDeviation(period);
    }
    nextValue(close) {
        const middle = this.sma.nextValue(close);
        const sd = this.sd.nextValue(close, middle);
        this.fill++;
        if (this.fill !== this.period) {
            return;
        }
        const lower = middle - this.stdDev * sd;
        const upper = middle + this.stdDev * sd;
        this.nextValue = (close) => {
            const middle = this.sma.nextValue(close);
            const sd = this.sd.nextValue(close, middle);
            const lower = middle - this.stdDev * sd;
            const upper = middle + this.stdDev * sd;
            return { lower, middle, upper };
        };
        return { lower, middle, upper };
    }
    momentValue(close) {
        const middle = this.sma.momentValue(close);
        const sd = this.sd.momentValue(close, middle);
        const lower = middle - this.stdDev * sd;
        const upper = middle + this.stdDev * sd;
        return { lower, middle, upper };
    }
}

/*
How work MACD?
https://www.investopedia.com/terms/m/macd.asp#:~:text=The%20MACD%20is%20calculated%20by,for%20buy%20and%20sell%20signals.
*/
class MACD {
    constructor(periodEmaFast = 12, periodEmaSlow = 26, periodSignal = 9) {
        this.periodEmaFast = periodEmaFast;
        this.periodEmaSlow = periodEmaSlow;
        this.periodSignal = periodSignal;
        this.emaFastIndicator = new EMA(periodEmaFast);
        this.emaSlowIndicator = new EMA(periodEmaSlow);
        this.emaSignalIndicator = new EMA(periodSignal);
    }
    nextValue(value) {
        const emaFast = this.emaFastIndicator.nextValue(value);
        const emaSlow = this.emaSlowIndicator.nextValue(value);
        const macd = emaFast - emaSlow;
        const signal = (macd && this.emaSignalIndicator.nextValue(macd)) || undefined;
        const histogram = macd - signal || undefined;
        if (isNaN(macd)) {
            return;
        }
        return {
            macd,
            emaFast,
            emaSlow,
            signal,
            histogram,
        };
    }
    momentValue(value) {
        const emaFast = this.emaFastIndicator.momentValue(value);
        const emaSlow = this.emaSlowIndicator.momentValue(value);
        const macd = emaFast - emaSlow;
        const signal = macd && this.emaSignalIndicator.momentValue(macd);
        const histogram = macd - signal;
        return {
            macd,
            emaFast,
            emaSlow,
            signal,
            histogram,
        };
    }
}

/**
 * Heikin-Ashi Candlesticks are an offshoot from Japanese candlesticks.
 * Heikin-Ashi Candlesticks use the open-close data from the prior period
 * and the open-high-low-close data from the current period to create a combo candlestick.
 * The resulting candlestick filters out some noise in an effort to better capture the trend.
 * In Japanese, Heikin means “average” and Ashi means “pace” (EUDict.com).
 * Taken together, Heikin-Ashi represents the average pace of prices.
 * Heikin-Ashi Candlesticks are not used like normal candlesticks.
 * Dozens of bullish or bearish reversal patterns consisting of 1-3 candlesticks are not to be found.
 * Instead, these candlesticks can be used to identify trending periods,
 * potential reversal points and classic technical analysis patterns.
 */
class HeikenAshi {
    constructor() {
        this.prevOpen = 0;
        this.prevClose = 0;
    }
    /**
     * Get next value for closed candle hlc
     * affect all next calculations
     */
    nextValue(o, h, l, c) {
        const data = this.calculate(o, h, l, c);
        this.prevClose = data.c;
        this.prevOpen = data.o;
        return data;
    }
    /**
     * Get next value for non closed (tick) candle hlc
     * does not affect any next calculations
     */
    momentValue(o, h, l, c) {
        return this.calculate(o, h, l, c);
    }
    /**
     * Heiken ashi formula
     */
    calculate(o, h, l, c) {
        c = (o + h + l + c) / 4;
        if (this.prevOpen) {
            o = (this.prevOpen + this.prevClose) / 2;
        }
        h = Math.max(h, o, c);
        l = Math.min(l, o, c);
        return { o, h, l, c };
    }
}

/**
 * Pivot points are major support and resistance levels where there likely to be a retracement
 * of price used by traders to objectively determine potential entry and exit levels of underlying assets.
 * Pivot point breaks can be an entry marker, confirmation of trend direction
 * also confirmation of trend reversal -exit marker.
 * These retracement calculation is based on the last day trading data as we follow
 * the market open, high, low, close on every day.
 * You can also calculate these pivot level on weekly basis.
 * For weekly pivot you need to weekly high, low, and close prices.
 */
class Pivot {
    constructor(mode = 'classic') {
        this.mode = mode;
        switch (this.mode) {
            case 'classic':
                this.calculator = this.classic;
                break;
            case 'camarilla':
                this.calculator = this.camarilla;
                break;
            case 'woodie':
                this.calculator = this.woodie;
                break;
            case 'fibonacci':
                this.calculator = this.fibonacci;
                break;
        }
    }
    nextValue(h, l, c) {
        return this.calculator(h, l, c);
    }
    // Classsic
    // Pivot Point (P) = (High + Low + Close)/3
    // Support 1 (S1) = (P x 2) - High
    // Support 2 (S2) = P  -  (High  -  Low)
    // Support 3 (S3) = Low – 2(High – PP)
    // Resistance 1 (R1) = (P x 2) - Low
    // Resistance 2 (R2) = P + (High  -  Low)
    // Resistance 3 (R3) = High + 2(PP – Low)
    classic(h, l, c) {
        const pp = (h + l + c) / 3;
        const s1 = pp * 2 - h;
        const s2 = pp - (h - l);
        const s3 = l - 2 * (h - pp);
        const r1 = pp * 2 - l;
        const r2 = pp + (h - l);
        const r3 = h + 2 * (pp - l);
        return { r3, r2, r1, pp, s1, s2, s3 };
    }
    // Woodie
    //R2 = PP + High – Low
    // R1 = (2 X PP) – Low
    // PP = (H + L + 2C) / 4
    // S1 = (2 X PP) – High
    // S2 = PP – High + Low
    woodie(h, l, c) {
        const pp = (h + l + 2 * c) / 4;
        const r2 = pp + h - l;
        const r1 = 2 * pp - l;
        const s1 = 2 * pp - h;
        const s2 = pp - h + l;
        return { r2, r1, pp, s1, s2 };
    }
    //Camarilla
    // pivot = (high + low + close ) / 3.0
    // range = high - low
    // h5 = (high/low) * close
    // h4 = close + (high - low) * 1.1 / 2.0
    // h3 = close + (high - low) * 1.1 / 4.0
    // h2 = close + (high - low) * 1.1 / 6.0
    // h1 = close + (high - low) * 1.1 / 12.0
    // l1 = close - (high - low) * 1.1 / 12.0
    // l2 = close - (high - low) * 1.1 / 6.0
    // l3 = close - (high - low) * 1.1 / 4.0
    // l4 = close - (high - low) * 1.1 / 2.0
    // h6 = h5 + 1.168 * (h5 - h4)
    // l5 = close - (h5 - close)
    // l6 = close - (h6 - close)
    camarilla(h, l, c) {
        const delta = (h - l) * 1.1;
        const pp = (h + l + c) / 3;
        const r5 = (h / l) * c;
        const r4 = c + delta / 2;
        const r6 = r5 + 1.168 * (r5 - r4);
        const r3 = c + delta / 4;
        const r2 = c + delta / 6;
        const r1 = c + delta / 12;
        const s1 = c - delta / 12;
        const s2 = c - delta / 6;
        const s3 = c - delta / 4;
        const s4 = c - delta / 2;
        const s5 = c - (r5 - c);
        const s6 = c - (r6 - c);
        return { r6, r5, r4, r3, r2, r1, pp, s1, s2, s3, s4, s5, s6 };
    }
    // Fibonacci Pivot Point
    // R3 = PP + ((High – Low) x 1.000)
    // R2 = PP + ((High – Low) x .618)
    // R1 = PP + ((High – Low) x .382)
    // PP = (H + L + C) / 3
    // S1 = PP – ((High – Low) x .382)
    // S2 = PP – ((High – Low) x .618)
    // S3 = PP – ((High – Low) x 1.000)
    fibonacci(h, l, c) {
        const delta = h - l;
        const pp = (h + l + c) / 3;
        const r3 = pp + delta;
        const r2 = pp + delta * 0.618;
        const r1 = pp + delta * 0.382;
        const s1 = pp - delta * 0.382;
        const s2 = pp - delta * 0.618;
        const s3 = pp - delta;
        return { r3, r2, r1, pp, s1, s2, s3 };
    }
}

/**
 In stock and securities market technical analysis, parabolic SAR (parabolic stop and reverse)
 is a method devised by J. Welles Wilder, Jr., to find potential reversals in the market price
 direction of traded goods such as securities or currency exchanges such as forex It is a
 trend-following (lagging) indicator and may be used to set a trailing stop loss or determine
 entry or exit points based on prices tending to stay within a parabolic curve during a strong trend.

 Similar to option theory's concept of time decay, the concept draws on the idea that "time is the enemy".
 Thus, unless a security can continue to generate more profits over time, it should be liquidated.
 The indicator generally works only in trending markets, and creates "whipsaws" during ranging or,
 sideways phases. Therefore, Wilder recommends first establishing the direction or change in direction
 of the trend through the use of parabolic SAR, and then using a different indicator such as the
 Average Directional Index to determine the strength of the trend.

 A parabola below the price is generally bullish, while a parabola above is generally bearish.
 A parabola below the price may be used as support, whereas a parabola above the price may represent resistance.
 * */
class PSAR {
    constructor(start = 0.02, acceleration = 0.02, max = 0.2) {
        this.start = start;
        this.acceleration = acceleration;
        this.max = max;
        this.result = 0;
        this.isBullTrend = true;
    }
    nextValue(high, low, close) {
        if (!this.result) {
            this.result = close;
            this.low1 = low;
            this.high1 = high;
            this.low2 = low;
            this.high2 = high;
            this.highest = high;
            this.lowest = low;
            this.accelerationFactor = this.start;
            return low;
        }
        if (this.isBullTrend) {
            this.psar = this.result + this.accelerationFactor * (this.highest - this.result);
        }
        else {
            this.psar = this.result + this.accelerationFactor * (this.lowest - this.result);
        }
        if (this.isBullTrend) {
            if (low < this.psar) {
                this.isBullTrend = false;
                this.psar = this.highest;
                this.lowest = low;
                this.accelerationFactor = this.start;
            }
            else {
                if (high > this.highest) {
                    this.highest = high;
                    const sumOfAcceleration = this.accelerationFactor + this.acceleration;
                    this.accelerationFactor = sumOfAcceleration > this.max ? this.max : sumOfAcceleration;
                }
                if (this.low1 < this.psar) {
                    this.psar = this.low1;
                }
                if (this.low2 < this.psar) {
                    this.psar = this.low2;
                }
            }
        }
        else {
            if (high > this.psar) {
                this.isBullTrend = true;
                this.psar = this.lowest;
                this.highest = high;
                this.accelerationFactor = this.start;
            }
            else {
                if (low < this.lowest) {
                    this.lowest = low;
                    const sumOfAcceleration = this.accelerationFactor + this.acceleration;
                    this.accelerationFactor = sumOfAcceleration > this.max ? this.max : sumOfAcceleration;
                }
                if (this.high1 > this.psar) {
                    this.psar = this.high1;
                }
                if (this.high2 > this.psar) {
                    this.psar = this.high2;
                }
            }
        }
        this.low2 = this.low1;
        this.low1 = low;
        this.high2 = this.high1;
        this.high1 = high;
        this.result = this.psar;
        return this.result;
    }
    momentValue(high, low) {
        if (!this.result) {
            return low;
        }
        let isBullTrend = this.isBullTrend;
        let result = this.result;
        let low1 = this.low1;
        let high1 = this.high1;
        let low2 = this.low2;
        let high2 = this.high2;
        let highest = this.highest;
        let lowest = this.lowest;
        let accelerationFactor = this.accelerationFactor;
        let psar;
        if (isBullTrend) {
            psar = result + accelerationFactor * (highest - result);
        }
        else {
            psar = result + accelerationFactor * (lowest - result);
        }
        if (isBullTrend) {
            if (low < psar) {
                psar = highest;
            }
            else {
                if (low1 < psar) {
                    psar = low1;
                }
                if (low2 < psar) {
                    psar = low2;
                }
            }
        }
        else {
            if (high > psar) {
                psar = lowest;
            }
            else {
                if (high1 > psar) {
                    psar = high1;
                }
                if (high2 > psar) {
                    psar = high2;
                }
            }
        }
        return psar;
    }
}

/**
 * The Welles Wilder's Smoothing Average (WWS) was developed by J. Welles Wilder, Jr. and is part of the Wilder's RSI indicator implementation.
 * This indicator smoothes price movements to help you identify and spot bullish and bearish trends.
 */
class WWS {
    constructor(period) {
        this.period = period;
        this.prevValue = 0;
        this.sumCount = 1;
    }
    /**
     * Get next value for closed candle hlc
     * affect all next calculations
     */
    nextValue(value) {
        if (this.sumCount < this.period) {
            this.prevValue += value;
            this.sumCount++;
            return;
        }
        if (this.sumCount === this.period) {
            this.prevValue += value;
            this.sumCount++;
            this.nextValue = (value) => (this.prevValue = this.prevValue - this.prevValue / this.period + value);
            return this.prevValue;
        }
    }
    /**
     * Get next value for non closed (tick) candle hlc
     * does not affect any next calculations
     */
    momentValue(value) {
        if (this.sumCount < this.period) {
            return;
        }
        return this.prevValue - this.prevValue / this.period + value;
    }
}

/**
 * ADX values help traders identify the strongest and most profitable trends to trade.
 * The values are also important for distinguishing between trending and non-trending conditions.
 * Many traders will use ADX readings above 25 to suggest that the trend is strong enough for trend-trading strategies.
 * Conversely, when ADX is below 25, many will avoid trend-trading strategies.
 * ADX Value	Trend Strength
 * 0-25	Absent or Weak Trend
 * 25-50	Strong Trend
 * 50-75	Very Strong Trend
 * 75-100	Extremely Strong Trend
 */
class ADX {
    constructor(period = 14) {
        this.period = period;
        this.wma1 = new WWS(period);
        this.wma2 = new WWS(period);
        this.wma3 = new WWS(period);
        this.wema = new WEMA(period);
    }
    nextValue(h, l, c) {
        if (!this.prevClose) {
            this.prevHigh = h;
            this.prevLow = l;
            this.prevClose = c;
            return;
        }
        let pDM = 0;
        let nDM = 0;
        const hDiff = h - this.prevHigh;
        const lDiff = this.prevLow - l;
        if (hDiff > lDiff && hDiff > 0) {
            pDM = hDiff;
        }
        if (lDiff > hDiff && lDiff > 0) {
            nDM = lDiff;
        }
        if (pDM > nDM || nDM < 0) {
            nDM = 0;
        }
        const atr = this.wma1.nextValue(getTrueRange(h, l, this.prevClose));
        const avgPDI = this.wma2.nextValue(pDM);
        const avgNDI = this.wma3.nextValue(nDM);
        this.prevHigh = h;
        this.prevLow = l;
        this.prevClose = c;
        if (avgPDI === undefined || avgNDI === undefined) {
            return;
        }
        const pDI = (avgPDI * 100) / atr;
        const nDI = (avgNDI * 100) / atr;
        const diAbs = pDI > nDI ? pDI - nDI : nDI - pDI;
        return { adx: this.wema.nextValue(100 * (diAbs / (pDI + nDI))), pdi: pDI, mdi: nDI };
    }
    momentValue(h, l, c) {
        if (!this.prevClose) {
            return;
        }
        let pDM = 0;
        let nDM = 0;
        const hDiff = h - this.prevHigh;
        const lDiff = this.prevLow - l;
        if (hDiff > lDiff && hDiff > 0) {
            pDM = hDiff;
        }
        if (lDiff > hDiff && lDiff > 0) {
            nDM = lDiff;
        }
        if (pDM > nDM || nDM < 0) {
            nDM = 0;
        }
        const atr = this.wma1.momentValue(getTrueRange(h, l, this.prevClose));
        const avgPDI = this.wma2.momentValue(pDM);
        const avgNDI = this.wma3.momentValue(nDM);
        if (avgPDI === undefined || avgNDI === undefined) {
            return;
        }
        const pDI = (avgPDI * 100) / atr;
        const nDI = (avgNDI * 100) / atr;
        const diAbs = pDI > nDI ? pDI - nDI : nDI - pDI;
        return { adx: this.wema.momentValue(100 * (diAbs / (pDI + nDI))), pdi: pDI, mdi: nDI };
    }
}

/**
 * SuperTrend indicator is one of the hybrid custom tools that show the current trend in the market.
 * The indicator name stands for Multi Time Frame SuperTrend.
 * The tool can show the direction of the trend on several timeframes at once.
 */
class SuperTrend {
    constructor(period = 10, multiplier = 3, smoothing = 'WEMA') {
        this.multiplier = multiplier;
        this.atr = new ATR(period, smoothing);
    }
    nextValue(h, l, c) {
        const atr = this.atr.nextValue(h, l, c);
        if (atr) {
            const src = (h + l) / 2;
            let upper = src + this.multiplier * atr;
            let lower = src - this.multiplier * atr;
            if (this.prevLower) {
                lower = lower > this.prevLower || this.prevClose < this.prevLower ? lower : this.prevLower;
                upper = upper < this.prevUpper || this.prevClose > this.prevUpper ? upper : this.prevUpper;
            }
            let superTrend = upper;
            if (this.prevSuper === this.prevUpper) {
                superTrend = c > upper ? lower : upper;
            }
            else {
                superTrend = c < lower ? upper : lower;
            }
            const direction = superTrend === upper ? 1 : -1;
            this.prevUpper = upper;
            this.prevLower = lower;
            this.prevSuper = superTrend;
            this.prevClose = c;
            return { upper, lower, superTrend, direction };
        }
    }
    momentValue(h, l, c) {
        const atr = this.atr.momentValue(h, l);
        const src = (h + l) / 2;
        let upper = src + this.multiplier * atr;
        let lower = src - this.multiplier * atr;
        if (this.prevLower) {
            lower = lower > this.prevLower || this.prevClose < this.prevLower ? lower : this.prevLower;
            upper = upper < this.prevSuper || this.prevClose > this.prevUpper ? upper : this.prevUpper;
        }
        let superTrend = upper;
        if (this.prevSuper === this.prevUpper) {
            superTrend = c > upper ? lower : upper;
        }
        else {
            superTrend = c < lower ? upper : lower;
        }
        const direction = superTrend === upper ? 1 : -1;
        return { upper, lower, superTrend, direction };
    }
}

const getPriceBySourceDefault = (candle) => {
    return (candle.o + candle.h + candle.l + candle.c) / 4;
};
/**
 * Is an indicator that gives a data representation of how much volume occurs
 * at each individual price over a certain period of time (session)
 */
class VolumeProfile {
    constructor(precision = 4, source = getPriceBySourceDefault) {
        this.sum = 0;
        this.sessionPricesLookup = new Set();
        this.sessionVolumes = {};
        this.prevCandle = null;
        this.source = source;
        this.precision = precision;
        this.valueToRoundWith = 10 ** this.precision;
    }
    /**
     * Get volume profile for current session
     */
    // Все еще не могу понять как считать важные уровни и группировать их
    getSession(candle, cleanOffset = 15) {
        const source = this.source(candle);
        let minDiff = Infinity;
        let middlePrice = source;
        this.sessionPricesLookup.forEach((price) => {
            const diff = this.diffPercent(price, source);
            if (diff > cleanOffset) {
                this.sessionPricesLookup.delete(price);
                delete this.sessionVolumes[price];
            }
            else if (diff < minDiff) {
                minDiff = diff;
                middlePrice = price;
            }
        });
        const prices = Array.from(this.sessionPricesLookup).sort();
        const middlePriceIndex = prices.indexOf(middlePrice);
        const session = new Map();
        if (middlePriceIndex === -1) {
            return session;
        }
        const segmentCount = 4;
        const segmentSize = Math.round(prices.length / segmentCount);
        let prevSegmentPrice = 0;
        for (let segment = 0; segment < segmentCount; segment++) {
            const start = segment * segmentSize;
            const end = start + segmentSize;
            let segmentVolume = 0;
            let segmentPrice = 0;
            for (let i = start; i < end; i++) {
                const currentPrice = prices[start];
                const currentVolume = this.sessionVolumes[currentPrice];
                if (segmentVolume < currentVolume) {
                    segmentVolume = currentVolume;
                    segmentPrice = currentPrice;
                }
            }
            if (this.diffPercent(prevSegmentPrice, segmentPrice) < 1) {
                segmentVolume = session.get(prevSegmentPrice) + segmentVolume;
                segmentPrice = this.roundPrice((segmentPrice + prevSegmentPrice) / 2);
                session.delete(prevSegmentPrice);
            }
            session.set(segmentPrice, segmentVolume);
            prevSegmentPrice = segmentPrice;
        }
        return session;
    }
    /**
     * Get session avg volume
     */
    getSessionAvg() {
        return this.sum / this.sessionPricesLookup.size;
    }
    /**
     * Get unformatted (raw) data for session
     */
    getRawSession() {
        return this.sessionVolumes;
    }
    /**
     * Add value to session
     */
    nextValue(candle) {
        const priceSource = this.roundPrice(this.source(candle));
        // Source volume calculated like diff between two candles or new candle volume
        // Next value might me used for each ticks or only once per candle
        const volume = this.prevCandle?.time === candle.time ? candle.v - this.prevCandle.v : candle.v;
        this.addToSession(priceSource, volume);
        this.sum += volume;
        this.lastPrice = priceSource;
        this.prevCandle = candle;
    }
    /**
     * Round price value
     */
    roundPrice(price) {
        return Math.round((price + Number.EPSILON) * this.valueToRoundWith) / this.valueToRoundWith;
    }
    /**
     * Add volume to current session
     */
    addToSession(price, volume) {
        const hasPrice = this.sessionPricesLookup.has(price);
        if (!hasPrice) {
            this.sessionPricesLookup.add(price);
            this.sessionVolumes[price] = volume;
        }
        else {
            this.sessionVolumes[price] += volume;
        }
    }
    /**
     * Percent change
     */
    diffPercent(a, b) {
        return a < b ? ((b - a) * 100) / a : ((a - b) * 100) / b;
    }
}

/**
 * Developed by Marc Chaikin, the Chaikin Oscillator measures the momentum of the Accumulation Distribution Line
 * using the MACD formula. (This makes it an indicator of an indicator.) The Chaikin Oscillator
 * is the difference between the 3-day and 10-day EMAs of the Accumulation Distribution Line.
 * Like other momentum indicators, this indicator is designed to anticipate directional changes
 * in the Accumulation Distribution Line by measuring the momentum behind the movements.
 * A momentum change is the first step to a trend change.
 * Anticipating trend changes in the Accumulation Distribution Line can help chartists anticipate
 * trend changes in the underlying security. The Chaikin Oscillator generates signals with
 * crosses above/below the zero line or with bullish/bearish divergences.
 */
class ChaikinOscillator {
    constructor(fastPeriod = 3, slowPeriod = 10) {
        this.accDistribution = 0;
        this.emaFast = new EMA(fastPeriod);
        this.emaSlow = new EMA(slowPeriod);
    }
    nextValue(h, l, c, v) {
        this.accDistribution += (c === h && c === l) || h === l ? 0 : ((2 * c - l - h) / (h - l)) * v;
        return this.emaFast.nextValue(this.accDistribution) - this.emaSlow.nextValue(this.accDistribution);
    }
    momentValue(h, l, c, v) {
        const accDistribution = this.accDistribution + ((c === h && c === l) || h === l ? 0 : ((2 * c - l - h) / (h - l)) * v);
        return this.emaFast.momentValue(accDistribution) - this.emaSlow.momentValue(accDistribution);
    }
}

/**
 * Adaptive Moving Average (AMA) is a powerful tool that can significantly improve your trading strategy.
 * In this ultimate guide, I’ll walk you through everything you need to know about AMA – from its
 * basics to implementing it in your own trading approach.
 * Get ready to take your trading game to the next level!
 */
class AMA {
    constructor(length, fastend = 4, slowend = 30) {
        this.sumNoise = 0;
        this.circular = new CircularBuffer(length);
        this.nfastend = 2 / (fastend + 1);
        this.nslowend = 2 / (slowend + 1);
        this.prevPrice = 0; // Можно инициализировать значением, например, первым полученным значением цены
        this.prevAMA = 0; // Аналогично
    }
    nextValue(price) {
        // Add the new value to the circular buffer and get the noise
        const prevPrice = this.prevPrice;
        const priceChange = Math.abs(price - prevPrice);
        const prevChange = this.circular.push(priceChange) ?? 0;
        this.sumNoise += priceChange - (this.circular.filled ? prevChange : 0);
        if (!this.circular.filled) {
            // Not enough data to calculate yet, return undefined
            this.prevAMA = price;
            this.prevPrice = price; // Update prevPrice
            return;
        }
        // Efficiency Ratio (ER)
        const signal = Math.abs(price - prevPrice);
        const noiseSum = this.sumNoise;
        const er = noiseSum !== 0 ? signal / noiseSum : 0;
        // Smoothing Constant (SC)
        const smooth = Math.pow(er * (this.nfastend - this.nslowend) + this.nslowend, 2);
        // AMA Calculation
        const currentAMA = this.prevAMA + smooth * (price - this.prevAMA);
        this.prevAMA = currentAMA;
        this.prevPrice = price; // Update prevPrice
        return currentAMA;
    }
    momentValue() {
        // Return the last calculated AMA value
        return this.prevAMA;
    }
}

export { AC, ADX, AMA, AO, ATR, BollingerBands, CCI, ChaikinOscillator, CircularBuffer, Correlation, DC, EMA, EWMA, Extremums, HeikenAshi, LWMA, Level, MACD, MFI, Move, PSAR, Pivot, RMA, ROC, RSI, SMA, SMMA, Sampler, StandardDeviation, Stochastic, StochasticRSI, SuperTrend, index as TrendLines, UniLevel, VolumeProfile, WEMA, WMA, WWS, Wave, cRSI };
