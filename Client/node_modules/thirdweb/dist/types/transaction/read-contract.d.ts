import { type Abi, type AbiFunction, type AbiParameter, type AbiParametersToPrimitiveTypes, type ExtractAbiFunctionNames } from "abitype";
import { type TransactionRequest } from "viem";
import type { ThirdwebContract } from "../contract/contract.js";
import type { PrepareTransactionOptions } from "./prepare-transaction.js";
import type { BaseTransactionOptions, ParamsOption, ParseMethod } from "./types.js";
import { type PreparedMethod } from "../utils/abi/prepare-method.js";
export type ReadContractResult<outputs extends readonly AbiParameter[]> = outputs extends {
    length: 0;
} ? never : outputs extends {
    length: 1;
} ? AbiParametersToPrimitiveTypes<outputs>[0] : AbiParametersToPrimitiveTypes<outputs>;
export type ReadContractOptions<TAbi extends Abi = [], TMethod extends AbiFunction | string | ((contract: ThirdwebContract<TAbi>) => Promise<AbiFunction>) = TAbi extends {
    length: 0;
} ? AbiFunction | string : ExtractAbiFunctionNames<TAbi>, TPreparedMethod extends PreparedMethod<ParseMethod<TAbi, TMethod>> = PreparedMethod<ParseMethod<TAbi, TMethod>>> = BaseTransactionOptions<Omit<TransactionRequest, "from" | "to" | "data" | "value" | "accessList" | "gas" | "gasPrice" | "maxFeePerGas" | "maxPriorityFeePerGas" | "nonce"> & {
    method: TMethod | TPreparedMethod;
    from?: string;
} & ParamsOption<TPreparedMethod[1]> & Omit<PrepareTransactionOptions, "to" | "data" | "chain" | "client">, TAbi>;
/**
 * ### Reads state from a deployed smart contract.
 *
 * Use this for raw read calls from a contract, but you can also use read [extensions](https://portal.thirdweb.com/typescript/v5/extensions/use) for predefined methods for common standards.
 *
 * @param options - The transaction options.
 * @returns A promise that resolves with the result of the read call.
 * @transaction
 * @example
 *
 * ### Raw contract call (recommended)
 *
 * You can read from any contract by using the solidity signature of the function you want to call.
 *
 * ```ts
 * import { getContract } from "thirdweb";
 * import { sepolia } from "thirdweb/chains";
 * import { useReadContract } from "thirdweb/react";
 *
 * const contract = getContract({
 *   client,
 *   address: "0x...",
 *   chain: sepolia,
 * });
 *
 * const { data, isLoading } = useReadContract({
 *   contract,
 *   method: "function tokenURI(uint256 tokenId) returns (string)",
 *   params: [1n],
 * });
 * ```
 *
 * Note that this is type safe, the params types will be enforced based on the signature.
 *
 * ### Raw contract call with `resolveMethod`
 *
 * If you don't have the solidity signature of the function you want to call, you can use the `resolveMethod` helper to resolve the method from any deployed contract.
 *
 * Note that this is not type safe, and will also have a 1 time overhead of resolving the contract ABI.
 *
 * ```ts
 * import { getContract, resolveMethod } from "thirdweb";
 * import { sepolia } from "thirdweb/chains";
 * import { useReadContract } from "thirdweb/react";
 *
 * const contract = getContract({
 *   client,
 *   address: "0x...",
 *   chain: sepolia,
 * });
 *
 * const { data, isLoading } = useReadContract({
 *   contract,
 *   method: resolveMethod("tokenURI"),
 *   params: [1n],
 * });
 * ```
 */
export declare function readContract<const TAbi extends Abi, const TMethod extends TAbi extends {
    length: 0;
} ? AbiFunction | `function ${string}` | ((contract: ThirdwebContract<TAbi>) => Promise<AbiFunction>) : ExtractAbiFunctionNames<TAbi>, const TPreparedMethod extends PreparedMethod<ParseMethod<TAbi, TMethod>> = PreparedMethod<ParseMethod<TAbi, TMethod>>>(options: ReadContractOptions<TAbi, TMethod, TPreparedMethod>): Promise<ReadContractResult<TPreparedMethod[2]>>;
//# sourceMappingURL=read-contract.d.ts.map