"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.estimateGas = estimateGas;
const ox__Hex = require("ox/Hex");
const viem_1 = require("viem");
const op_gas_fee_reducer_js_1 = require("../../gas/op-gas-fee-reducer.js");
const address_js_1 = require("../../utils/address.js");
const resolve_promised_value_js_1 = require("../../utils/promise/resolve-promised-value.js");
const extract_error_js_1 = require("../extract-error.js");
const cache = new WeakMap();
/**
 * Estimates the gas required to execute a transaction. The gas is returned as a `bigint` and in gwei units.
 * @param options - The options for estimating gas.
 * @returns A promise that resolves to the estimated gas as a bigint.
 * @transaction
 * @example
 * ```ts
 * import { estimateGas } from "thirdweb";
 * const gas = await estimateGas({
 *  transaction,
 *  from: "0x...",
 * });
 * ```
 */
async function estimateGas(options) {
    // from is:
    // 1. the user specified from address
    // 2. the passed in account address
    // 3. the passed in wallet's account address
    const fromAddress = typeof options.from === "string"
        ? (options.from ?? undefined)
        : (options.from?.address ?? options.account?.address);
    const txWithFrom = { ...options.transaction, from: fromAddress };
    if (cache.has(txWithFrom)) {
        // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set
        return cache.get(txWithFrom);
    }
    const { account } = options;
    const promise = (async () => {
        const predefinedGas = await (0, resolve_promised_value_js_1.resolvePromisedValue)(options.transaction.gas);
        // if we have a predefined gas value in the TX -> always use that
        if (predefinedGas !== undefined) {
            return predefinedGas;
        }
        // if the wallet itself overrides the estimateGas function, use that
        if (account?.estimateGas) {
            try {
                let gas = await account.estimateGas(options.transaction);
                if (options.transaction.chain.experimental?.increaseZeroByteCount) {
                    gas = (0, op_gas_fee_reducer_js_1.roundUpGas)(gas);
                }
                return gas;
            }
            catch (error) {
                throw await (0, extract_error_js_1.extractError)({
                    error,
                    contract: options.transaction.__contract,
                });
            }
        }
        // load up encode function if we need it
        const { encode } = await Promise.resolve().then(() => require("./encode.js"));
        const [encodedData, toAddress, value, authorizationList] = await Promise.all([
            encode(options.transaction),
            (0, resolve_promised_value_js_1.resolvePromisedValue)(options.transaction.to),
            (0, resolve_promised_value_js_1.resolvePromisedValue)(options.transaction.value),
            (0, resolve_promised_value_js_1.resolvePromisedValue)(options.transaction.authorizationList),
        ]);
        // load up the rpc client and the estimateGas function if we need it
        const [{ getRpcClient }, { eth_estimateGas }] = await Promise.all([
            Promise.resolve().then(() => require("../../rpc/rpc.js")),
            Promise.resolve().then(() => require("../../rpc/actions/eth_estimateGas.js")),
        ]);
        const rpcRequest = getRpcClient(options.transaction);
        try {
            let gas = await eth_estimateGas(rpcRequest, (0, viem_1.formatTransactionRequest)({
                to: toAddress ? (0, address_js_1.getAddress)(toAddress) : undefined,
                data: encodedData,
                from: fromAddress ? (0, address_js_1.getAddress)(fromAddress) : undefined,
                value,
                // TODO: Remove this casting when we migrate this file to Ox
                authorizationList: authorizationList?.map((auth) => ({
                    ...auth,
                    r: ox__Hex.fromNumber(auth.r),
                    s: ox__Hex.fromNumber(auth.s),
                    nonce: Number(auth.nonce),
                    contractAddress: (0, address_js_1.getAddress)(auth.address),
                })),
            }));
            if (options.transaction.chain.experimental?.increaseZeroByteCount) {
                gas = (0, op_gas_fee_reducer_js_1.roundUpGas)(gas);
            }
            return gas;
        }
        catch (error) {
            throw await (0, extract_error_js_1.extractError)({
                error,
                contract: options.transaction.__contract,
            });
        }
    })();
    cache.set(txWithFrom, promise);
    return promise;
}
//# sourceMappingURL=estimate-gas.js.map