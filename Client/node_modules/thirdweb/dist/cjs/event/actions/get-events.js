"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getContractEvents = getContractEvents;
const viem_1 = require("viem");
const resolve_abi_js_1 = require("../../contract/actions/resolve-abi.js");
const get_events_js_1 = require("../../insight/get-events.js");
const eth_blockNumber_js_1 = require("../../rpc/actions/eth_blockNumber.js");
const eth_getLogs_js_1 = require("../../rpc/actions/eth_getLogs.js");
const rpc_js_1 = require("../../rpc/rpc.js");
const address_js_1 = require("../../utils/address.js");
const hex_js_1 = require("../../utils/encoding/hex.js");
const prepare_event_js_1 = require("../prepare-event.js");
const utils_js_1 = require("../utils.js");
const parse_logs_js_1 = require("./parse-logs.js");
/**
 * Retrieves events from a contract based on the provided options.
 * @param options - The options for retrieving events.
 * @returns A promise that resolves to an array of parsed event logs.
 * Note: toBlock and fromBlock are both inclusive.
 * @example
 * ```ts
 * import { getContractEvents } from "thirdweb";
 * const events = await getContractEvents({
 *  contract: myContract,
 *  fromBlock: 123456n,
 *  toBlock: 123456n,
 *  events: [preparedEvent, preparedEvent2],
 * });
 * ```
 * @example
 * Optionally specify a blockRange as the number of blocks to retrieve. toBlock will default to the current block number.
 * ```ts
 * import { getContractEvents } from "thirdweb";
 * const events = await getContractEvents({
 *  contract: myContract,
 *  blockRange: 123456n,
 *  events: [preparedEvent, preparedEvent2],
 * });
 * ```
 * @example
 * Use fromBlock with blockRange for pagination.
 * ```ts
 * import { getContractEvents } from "thirdweb";
 * const events = await getContractEvents({
 *  contract: myContract,
 *  fromBlock: lastBlockFetched,
 *  blockRange: 123456n,
 *  events: [preparedEvent, preparedEvent2],
 * });
 * ```
 * @example
 * Retrieve events for a specific block hash.
 * ```ts
 * import { getContractEvents } from "thirdweb";
 * const events = await getContractEvents({
 *  contract: myContract,
 *  blockHash: "0x...",
 *  events: [preparedEvent, preparedEvent2],
 * });
 * ```
 * @contract
 */
async function getContractEvents(options) {
    const { contract, events, blockRange, useIndexer = true, ...restParams } = options;
    const rpcRequest = (0, rpc_js_1.getRpcClient)(contract);
    if (restParams.blockHash &&
        (blockRange || restParams.fromBlock || restParams.toBlock)) {
        throw new Error("Cannot specify blockHash and range simultaneously,");
    }
    const latestBlockNumber = await (0, eth_blockNumber_js_1.eth_blockNumber)(rpcRequest);
    // Compute toBlock and fromBlock if blockRange was passed
    if (blockRange) {
        const { fromBlock, toBlock } = restParams;
        // Make sure the inputs were properly defined
        if (fromBlock !== undefined &&
            toBlock !== undefined &&
            BigInt(toBlock) - BigInt(fromBlock) !== BigInt(blockRange)) {
            throw new Error("Incompatible blockRange with specified fromBlock and toBlock. Please only define fromBlock or toBlock when specifying blockRange.");
        }
        if (fromBlock !== undefined) {
            restParams.toBlock = BigInt(fromBlock) + BigInt(blockRange) - 1n; // Subtract one because toBlock is inclusive
        }
        else if (toBlock !== undefined) {
            restParams.fromBlock = BigInt(toBlock) - BigInt(blockRange) + 1n; // Add one because fromBlock is inclusive
        }
        else {
            // If no from or to block specified, use the latest block as the to block
            restParams.toBlock = latestBlockNumber;
            restParams.fromBlock = latestBlockNumber - BigInt(blockRange) + 1n; // Add one because fromBlock is inclusive
        }
    }
    let resolvedEvents = events ?? [];
    // if we have an abi on the contract, we can encode the topics with it
    if (!events?.length && !!contract) {
        if (useIndexer) {
            // fetch all events from the indexer, no need to get events from ABI
            const events = await (0, get_events_js_1.getContractEvents)({
                client: contract.client,
                chains: [contract.chain],
                contractAddress: contract.address,
                decodeLogs: true,
                queryOptions: {
                    limit: 500,
                    filter_block_hash: restParams.blockHash,
                    filter_block_number_gte: restParams.fromBlock,
                    filter_block_number_lte: restParams.toBlock,
                },
            }).catch(() => {
                // chain might not support indexer
                return null;
            });
            if (events) {
                return toLog(events);
            }
        }
        // if we have a contract *WITH* an abi we can use that
        if (contract.abi?.length) {
            // @ts-expect-error - we can't make typescript happy here, but we know this is an abi event
            resolvedEvents = contract.abi
                .filter(utils_js_1.isAbiEvent)
                .map((abiEvent) => (0, prepare_event_js_1.prepareEvent)({ signature: abiEvent }));
        }
        else {
            const runtimeAbi = await (0, resolve_abi_js_1.resolveContractAbi)(contract);
            // @ts-expect-error - we can't make typescript happy here, but we know this is an abi event
            resolvedEvents = runtimeAbi
                .filter(utils_js_1.isAbiEvent)
                .map((abiEvent) => (0, prepare_event_js_1.prepareEvent)({ signature: abiEvent }));
        }
    }
    const logsParams = events && events.length > 0
        ? // if we have events passed in then we use those
            events.map((e) => ({
                ...restParams,
                address: (0, address_js_1.getAddress)(contract.address),
                topics: e.topics,
            }))
        : // otherwise we want "all" events (aka not pass any topics at all)
            [{ ...restParams, address: (0, address_js_1.getAddress)(contract.address) }];
    let logs = [];
    // try fetching from insight if available
    if (useIndexer) {
        try {
            logs = await Promise.all(logsParams.map((p) => getLogsFromInsight({
                params: p,
                contract,
            })));
        }
        catch (e) {
            console.warn("Error fetching from insight, falling back to rpc", e);
            // fetch from rpc
            logs = await Promise.all(logsParams.map((ethLogParams) => (0, eth_getLogs_js_1.eth_getLogs)(rpcRequest, ethLogParams)));
        }
    }
    else {
        // fetch from rpc
        logs = await Promise.all(logsParams.map((ethLogParams) => (0, eth_getLogs_js_1.eth_getLogs)(rpcRequest, ethLogParams)));
    }
    const flattenLogs = logs
        .flat()
        .sort((a, b) => Number((a.blockNumber ?? 0n) - (b.blockNumber ?? 0n)));
    return (0, parse_logs_js_1.parseEventLogs)({
        logs: flattenLogs,
        events: resolvedEvents,
    });
}
async function getLogsFromInsight(options) {
    const { params, contract } = options;
    const fromBlock = typeof params.fromBlock === "bigint" ? Number(params.fromBlock) : undefined;
    const toBlock = typeof params.toBlock === "bigint" ? Number(params.toBlock) : undefined;
    const r = await (0, get_events_js_1.getContractEvents)({
        client: contract.client,
        chains: [contract.chain],
        contractAddress: contract.address,
        queryOptions: {
            limit: 500,
            filter_block_hash: params.blockHash,
            filter_block_number_gte: fromBlock,
            filter_block_number_lte: toBlock,
            filter_topic_0: params.topics?.[0],
            filter_topic_1: params.topics?.[1],
            filter_topic_2: params.topics?.[2],
            filter_topic_3: params.topics?.[3],
        },
    });
    return toLog(r);
}
function toLog(r) {
    const cleanedEventData = r.map((tx) => ({
        chainId: tx.chain_id,
        blockNumber: (0, hex_js_1.numberToHex)(Number(tx.block_number)),
        blockHash: tx.block_hash,
        blockTimestamp: tx.block_timestamp,
        transactionHash: tx.transaction_hash,
        transactionIndex: (0, hex_js_1.numberToHex)(tx.transaction_index),
        logIndex: (0, hex_js_1.numberToHex)(tx.log_index),
        address: tx.address,
        data: tx.data,
        topics: tx.topics,
        ...(tx.decoded
            ? {
                eventName: tx.decoded.name,
                args: {
                    ...tx.decoded.indexed_params,
                    ...tx.decoded.non_indexed_params,
                },
            }
            : {}),
    }));
    return cleanedEventData
        .map((e) => (0, viem_1.formatLog)(e))
        .sort((a, b) => Number((a.blockNumber ?? 0n) - (b.blockNumber ?? 0n)));
}
//# sourceMappingURL=get-events.js.map