"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.zkDeployProxy = zkDeployProxy;
const encode_js_1 = require("../../../transaction/actions/encode.js");
const constants_js_1 = require("../../../utils/any-evm/zksync/constants.js");
const is_contract_deployed_js_1 = require("../../../utils/bytecode/is-contract-deployed.js");
const resolve_promised_value_js_1 = require("../../../utils/promise/resolve-promised-value.js");
const random_js_1 = require("../../../utils/random.js");
const contract_js_1 = require("../../contract.js");
const zkDeployDeterministic_js_1 = require("./zkDeployDeterministic.js");
/**
 * @internal
 */
async function zkDeployProxy(options) {
    // TODO ensure implementation is deployed
    const implementationAddress = await (0, resolve_promised_value_js_1.resolvePromisedValue)(options.initializeTransaction.to);
    if (!implementationAddress) {
        throw new Error("initializeTransaction must have a 'to' field set");
    }
    const deployed = await (0, is_contract_deployed_js_1.isContractDeployed)((0, contract_js_1.getContract)({
        address: implementationAddress,
        chain: options.chain,
        client: options.client,
    }));
    if (!deployed) {
        throw new Error(`Implementation contract at ${implementationAddress} is not deployed`);
    }
    // deploy tw proxy of the implementation
    const proxyAddress = await (0, zkDeployDeterministic_js_1.zkDeployContractDeterministic)({
        client: options.client,
        chain: options.chain,
        account: options.account,
        abi: constants_js_1.twProxyAbi,
        bytecode: constants_js_1.twProxyBytecode,
        params: {
            _logic: implementationAddress,
            _data: await (0, encode_js_1.encode)(options.initializeTransaction),
        },
        salt: options.salt || (0, random_js_1.randomBytesHex)(32),
    });
    // return address of proxy
    return proxyAddress;
}
//# sourceMappingURL=zkDeployProxy.js.map