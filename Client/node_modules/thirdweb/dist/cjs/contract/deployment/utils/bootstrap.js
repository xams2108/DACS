"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOrDeployInfraForPublishedContract = getOrDeployInfraForPublishedContract;
exports.deployCloneFactory = deployCloneFactory;
exports.deployImplementation = deployImplementation;
exports.getOrDeployInfraContract = getOrDeployInfraContract;
exports.getOrDeployInfraContractFromMetadata = getOrDeployInfraContractFromMetadata;
const activateStylusContract_js_1 = require("../../../extensions/stylus/write/activateStylusContract.js");
const send_and_confirm_transaction_js_1 = require("../../../transaction/actions/send-and-confirm-transaction.js");
const send_transaction_js_1 = require("../../../transaction/actions/send-transaction.js");
const deploy_metadata_js_1 = require("../../../utils/any-evm/deploy-metadata.js");
const isZkSyncChain_js_1 = require("../../../utils/any-evm/zksync/isZkSyncChain.js");
const contract_js_1 = require("../../contract.js");
const publisher_js_1 = require("../publisher.js");
const implementations_js_1 = require("../zksync/implementations.js");
const zkDeployCreate2Factory_js_1 = require("../zksync/zkDeployCreate2Factory.js");
const zkDeployDeterministic_js_1 = require("../zksync/zkDeployDeterministic.js");
const clone_factory_js_1 = require("./clone-factory.js");
const create_2_factory_js_1 = require("./create-2-factory.js");
const infra_js_1 = require("./infra.js");
/**
 * Gets or deploys the infrastructure contracts needed for a published contract deployment
 * @param args - The arguments object
 * @param args.chain - The blockchain network configuration
 * @param args.client - The ThirdwebClient instance
 * @param args.account - The account performing the deployment
 * @param args.contractId - The ID of the contract to deploy
 * @param args.constructorParams - Optional constructor parameters for the implementation contract
 * @param args.publisher - Optional publisher address, defaults to thirdweb
 * @param args.version - Optional version of the contract to deploy
 * @returns An object containing:
 * - cloneFactoryContract: The factory contract used for creating clones
 * - implementationContract: The deployed implementation contract
 * @contract
 */
async function getOrDeployInfraForPublishedContract(args) {
    const { chain, client, account, contractId, constructorParams, publisher, version, } = args;
    if (await (0, isZkSyncChain_js_1.isZkSyncChain)(chain)) {
        const cloneFactoryContract = await (0, zkDeployCreate2Factory_js_1.zkDeployCreate2Factory)({
            chain,
            client,
            account,
        });
        const compilerMetadata = await (0, publisher_js_1.fetchPublishedContractMetadata)({
            client,
            contractId,
            publisher,
            version,
        });
        const zksyncImplementations = implementations_js_1.ZKSYNC_IMPLEMENTATIONS[chain.id];
        let implementationContract;
        if (zksyncImplementations) {
            implementationContract = zksyncImplementations[contractId];
        }
        if (!implementationContract) {
            implementationContract = await (0, zkDeployDeterministic_js_1.zkDeployContractDeterministic)({
                chain,
                client,
                account,
                abi: compilerMetadata.abi,
                bytecode: await (0, deploy_metadata_js_1.fetchBytecodeFromCompilerMetadata)({
                    compilerMetadata,
                    client,
                    chain,
                }),
                params: constructorParams,
            });
        }
        return {
            cloneFactoryContract: (0, contract_js_1.getContract)({
                address: cloneFactoryContract,
                chain,
                client,
            }),
            implementationContract: (0, contract_js_1.getContract)({
                address: implementationContract,
                chain,
                client,
            }),
        };
    }
    let [cloneFactoryContract, implementationContract] = await Promise.all([
        (0, clone_factory_js_1.getDeployedCloneFactoryContract)({
            chain,
            client,
        }),
        (0, infra_js_1.getDeployedInfraContract)({
            chain,
            client,
            contractId,
            constructorParams,
            publisher,
            version,
        }),
    ]);
    if (!implementationContract || !cloneFactoryContract) {
        // deploy the infra and implementation contracts if not found
        cloneFactoryContract = await deployCloneFactory({
            client,
            chain,
            account,
        });
        implementationContract = await deployImplementation({
            client,
            chain,
            account,
            contractId,
            constructorParams,
            publisher,
            version,
        });
    }
    return {
        cloneFactoryContract,
        implementationContract,
    };
}
/**
 * @internal
 * @returns the deployed clone factory contract
 */
async function deployCloneFactory(options) {
    // create2 factory
    const create2Factory = await (0, create_2_factory_js_1.getDeployedCreate2Factory)(options);
    if (!create2Factory) {
        await (0, create_2_factory_js_1.deployCreate2Factory)(options);
    }
    // Forwarder
    const forwarder = await getOrDeployInfraContract({
        ...options,
        contractId: "Forwarder",
    });
    // clone factory
    return getOrDeployInfraContract({
        ...options,
        contractId: "TWCloneFactory",
        constructorParams: { _trustedForwarder: forwarder.address },
    });
}
/**
 * @internal
 * @returns the deployed infra contract
 */
async function deployImplementation(options) {
    return getOrDeployInfraContract({
        ...options,
        contractId: options.contractId,
        constructorParams: options.constructorParams,
        publisher: options.publisher,
        version: options.version,
    });
}
/**
 * Convenience function to get or deploy an infra contract
 * @internal
 */
async function getOrDeployInfraContract(options) {
    if (options.contractId === "WETH9" && (await (0, isZkSyncChain_js_1.isZkSyncChain)(options.chain))) {
        const weth = implementations_js_1.ZKSYNC_WETH[options.chain.id];
        if (weth) {
            return (0, contract_js_1.getContract)({
                client: options.client,
                chain: options.chain,
                address: weth,
            });
        }
    }
    const contractMetadata = await (0, publisher_js_1.fetchPublishedContractMetadata)({
        client: options.client,
        contractId: options.contractId,
        publisher: options.publisher,
        version: options.version,
    });
    return getOrDeployInfraContractFromMetadata({
        account: options.account,
        chain: options.chain,
        client: options.client,
        constructorParams: options.constructorParams,
        contractMetadata,
    });
}
async function getOrDeployInfraContractFromMetadata(options) {
    const infraContract = await (0, infra_js_1.getDeployedInfraContractFromMetadata)(options);
    if (infraContract) {
        return infraContract;
    }
    const transaction = (0, infra_js_1.prepareInfraContractDeployTransactionFromMetadata)(options);
    await (0, send_and_confirm_transaction_js_1.sendAndConfirmTransaction)({
        transaction,
        account: options.account,
    });
    const deployedInfraContract = await (0, infra_js_1.getDeployedInfraContractFromMetadata)(options);
    if (!deployedInfraContract) {
        throw new Error(`Failed to deploy ${options.contractMetadata.name}`);
    }
    const isStylus = options.contractMetadata.metadata.language === "rust";
    if (isStylus) {
        try {
            const activationTransaction = await (0, activateStylusContract_js_1.activateStylusContract)({
                chain: options.chain,
                client: options.client,
                contractAddress: deployedInfraContract.address,
            });
            await (0, send_transaction_js_1.sendTransaction)({
                transaction: activationTransaction,
                account: options.account,
            });
        }
        catch {
            console.error("Error: Contract could not be activated.");
        }
    }
    return deployedInfraContract;
}
//# sourceMappingURL=bootstrap.js.map