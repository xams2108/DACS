"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBuyWithCryptoQuote = getBuyWithCryptoQuote;
const utils_js_1 = require("../../chains/utils.js");
const fetch_js_1 = require("../../utils/fetch.js");
const json_js_1 = require("../../utils/json.js");
const definitions_js_1 = require("../utils/definitions.js");
/**
 * Get a quote of type [`BuyWithCryptoQuote`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoQuote) to buy any given token with crypto.
 * This quote contains the information about the swap such as token amounts, processing fees, estimated time etc.
 *
 * Once you have the quote, you can use `prepareTransaction` and prepare the transaction for submission.
 * @param params - object of type [`GetBuyWithCryptoQuoteParams`](https://portal.thirdweb.com/references/typescript/v5/GetBuyWithCryptoQuoteParams)
 * @returns Object of type [`BuyWithCryptoQuote`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoQuote) which contains the information about the quote such as processing fees, estimated time, converted token amounts, etc.
 * @example
 *
 * ```ts
 * import { getBuyWithCryptoQuote } from "thirdweb/pay";
 *
 * const quote = await getBuyWithCryptoQuote({
 *  client,
 *  fromAddress: "0x...", // wallet address
 *  fromChainId: 137, // chain id of the source token
 *  fromTokenAddress: "0x...", // token address of the source token
 *  fromAmount: "10", // amount of source token to swap
 *  // optionally, you can use `toAmount` instead if you only want a certain amount of destination token
 *  toChainId: 10, // chain id of the destination token
 *  toTokenAddress: "0x...", // token address of the destination token
 *  toAddress: "0x...", // optional: send the tokens to a different address
 *  maxSlippageBPS: 50, // optional: max 0.5% slippage
 * });
 * ```
 * @buyCrypto
 */
async function getBuyWithCryptoQuote(params) {
    try {
        const clientFetch = (0, fetch_js_1.getClientFetch)(params.client);
        const response = await clientFetch((0, definitions_js_1.getPayBuyWithCryptoQuoteEndpoint)(), {
            method: "POST",
            headers: {
                Accept: "application/json",
                "Content-Type": "application/json",
            },
            body: (0, json_js_1.stringify)({
                fromAddress: params.fromAddress,
                toAddress: params.toAddress,
                fromChainId: params.fromChainId.toString(),
                fromTokenAddress: params.fromTokenAddress,
                toChainId: params.toChainId.toString(),
                toTokenAddress: params.toTokenAddress,
                fromAmount: params.fromAmount,
                toAmount: params.toAmount,
                maxSlippageBPS: params.maxSlippageBPS,
                intentId: params.intentId,
                purchaseData: params.purchaseData,
            }),
        });
        // Assuming the response directly matches the SwapResponse interface
        if (!response.ok) {
            const errorObj = await response.json();
            if (errorObj && "error" in errorObj) {
                throw errorObj;
            }
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = (await response.json())
            .result;
        // check if the fromAddress already has approval for the given amount
        const approvalData = data.approval;
        const swapRoute = {
            transactionRequest: {
                chain: (0, utils_js_1.getCachedChain)(data.transactionRequest.chainId),
                client: params.client,
                data: data.transactionRequest.data,
                to: data.transactionRequest.to,
                value: BigInt(data.transactionRequest.value),
                extraGas: 50000n, // extra gas buffer
            },
            approvalData,
            swapDetails: {
                fromAddress: data.fromAddress,
                toAddress: data.toAddress,
                fromToken: data.fromToken,
                toToken: data.toToken,
                fromAmount: data.fromAmount,
                fromAmountWei: data.fromAmountWei,
                toAmountMinWei: data.toAmountMinWei,
                toAmountMin: data.toAmountMin,
                toAmountWei: data.toAmountWei,
                toAmount: data.toAmount,
                estimated: data.estimated,
                maxSlippageBPS: data.maxSlippageBPS,
            },
            paymentTokens: data.paymentTokens,
            processingFees: data.processingFees,
            client: params.client,
        };
        return swapRoute;
    }
    catch (error) {
        console.error("Error getting buy with crypto quote", error);
        throw error;
    }
}
//# sourceMappingURL=getQuote.js.map