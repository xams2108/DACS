"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertFiatToCrypto = convertFiatToCrypto;
const addresses_js_1 = require("../../constants/addresses.js");
const get_bytecode_js_1 = require("../../contract/actions/get-bytecode.js");
const contract_js_1 = require("../../contract/contract.js");
const address_js_1 = require("../../utils/address.js");
const fetch_js_1 = require("../../utils/fetch.js");
const definitions_js_1 = require("../utils/definitions.js");
/**
 * Convert a fiat value to a token.
 * Currently only USD is supported.
 * @example
 * ### Basic usage
 * ```ts
 * import { convertFiatToCrypto } from "thirdweb/pay";
 *
 * // Convert 2 cents to ETH
 * const result = await convertFiatToCrypto({
 *   from: "USD",
 *   // the token address. For native token, use NATIVE_TOKEN_ADDRESS
 *   to: "0x...",
 *   // the chain (of the chain where the token belong to)
 *   chain: ethereum,
 *   // 2 cents
 *   fromAmount: 0.02,
 * });
 * ```
 * Result: `{ result: 0.0000057 }`
 * @buyCrypto
 */
async function convertFiatToCrypto(options) {
    const { client, from, to, chain, fromAmount } = options;
    if (Number(fromAmount) === 0) {
        return { result: 0 };
    }
    // Testnets just don't work with our current provider(s)
    if (chain.testnet === true) {
        throw new Error(`Cannot fetch price for a testnet (chainId: ${chain.id})`);
    }
    // Some provider that we are using will return `0` for unsupported token
    // so we should do some basic input validations before sending the request
    // Make sure it's a valid EVM address
    if (!(0, address_js_1.isAddress)(to)) {
        throw new Error("Invalid `to`. Expected a valid EVM contract address");
    }
    // Make sure it's either a valid contract or a native token
    if (to.toLowerCase() !== addresses_js_1.NATIVE_TOKEN_ADDRESS.toLowerCase()) {
        const bytecode = await (0, get_bytecode_js_1.getBytecode)((0, contract_js_1.getContract)({
            address: to,
            chain,
            client,
        })).catch(() => undefined);
        if (!bytecode || bytecode === "0x") {
            throw new Error(`Error: ${to} on chainId: ${chain.id} is not a valid contract address.`);
        }
    }
    const params = {
        from,
        to,
        chainId: String(chain.id),
        fromAmount: String(fromAmount),
    };
    const queryString = new URLSearchParams(params).toString();
    const url = `${(0, definitions_js_1.getPayConvertFiatToCryptoEndpoint)()}?${queryString}`;
    const response = await (0, fetch_js_1.getClientFetch)(client)(url);
    if (!response.ok) {
        throw new Error(`Failed to convert ${from} value to token (${to}) on chainId: ${chain.id}`);
    }
    const data = await response.json();
    return data;
}
//# sourceMappingURL=fiatToCrypto.js.map