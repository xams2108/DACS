"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OnRampScreen = OnRampScreen;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_query_1 = require("@tanstack/react-query");
const react_1 = require("react");
const pay_js_1 = require("../../../../../../../analytics/track/pay.js");
const utils_js_1 = require("../../../../../../../chains/utils.js");
const contract_js_1 = require("../../../../../../../contract/contract.js");
const allowance_js_1 = require("../../../../../../../extensions/erc20/__generated__/IERC20/read/allowance.js");
const approve_js_1 = require("../../../../../../../extensions/erc20/write/approve.js");
const getQuote_js_1 = require("../../../../../../../pay/buyWithCrypto/getQuote.js");
const getStatus_js_1 = require("../../../../../../../pay/buyWithFiat/getStatus.js");
const isSwapRequiredPostOnramp_js_1 = require("../../../../../../../pay/buyWithFiat/isSwapRequiredPostOnramp.js");
const send_batch_transaction_js_1 = require("../../../../../../../transaction/actions/send-batch-transaction.js");
const send_transaction_js_1 = require("../../../../../../../transaction/actions/send-transaction.js");
const wait_for_tx_receipt_js_1 = require("../../../../../../../transaction/actions/wait-for-tx-receipt.js");
const formatNumber_js_1 = require("../../../../../../../utils/formatNumber.js");
const is_ecosystem_wallet_js_1 = require("../../../../../../../wallets/ecosystem/is-ecosystem-wallet.js");
const index_js_1 = require("../../../../../../../wallets/in-app/core/wallet/index.js");
const is_smart_wallet_js_1 = require("../../../../../../../wallets/smart/is-smart-wallet.js");
const index_js_2 = require("../../../../../../core/design-system/index.js");
const useChainQuery_js_1 = require("../../../../../../core/hooks/others/useChainQuery.js");
const useBuyWithCryptoStatus_js_1 = require("../../../../../../core/hooks/pay/useBuyWithCryptoStatus.js");
const useBuyWithFiatStatus_js_1 = require("../../../../../../core/hooks/pay/useBuyWithFiatStatus.js");
const useConnectedWallets_js_1 = require("../../../../../../core/hooks/wallets/useConnectedWallets.js");
const invalidateWalletBalance_js_1 = require("../../../../../../core/providers/invalidateWalletBalance.js");
const Spacer_js_1 = require("../../../../components/Spacer.js");
const Spinner_js_1 = require("../../../../components/Spinner.js");
const SwitchNetwork_js_1 = require("../../../../components/SwitchNetwork.js");
const basic_js_1 = require("../../../../components/basic.js");
const buttons_js_1 = require("../../../../components/buttons.js");
const text_js_1 = require("../../../../components/text.js");
const TokenSymbol_js_1 = require("../../../../components/token/TokenSymbol.js");
const PayTokenIcon_js_1 = require("../PayTokenIcon.js");
const openOnRamppopup_js_1 = require("../openOnRamppopup.js");
const StepConnector_js_1 = require("../swap/StepConnector.js");
const WalletRow_js_1 = require("../swap/WalletRow.js");
const pendingSwapTx_js_1 = require("../swap/pendingSwapTx.js");
const FiatSteps_js_1 = require("./FiatSteps.js");
function OnRampScreen(props) {
    const connectedWallets = (0, useConnectedWallets_js_1.useConnectedWallets)();
    const isAutoMode = isInAppSigner({
        wallet: props.payer.wallet,
        connectedWallets,
    });
    const state = useOnRampScreenState({
        quote: props.quote,
        client: props.client,
        onSuccess: props.onSuccess,
        onDone: props.onDone,
        payer: props.payer,
        theme: props.theme,
        isAutoMode,
    });
    const firstStepChainId = state.steps[0]?.step.token.chainId;
    return ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { p: "lg", children: [(0, jsx_runtime_1.jsx)(basic_js_1.ModalHeader, { title: props.title, onBack: props.onBack }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "xl" }), (0, jsx_runtime_1.jsx)(basic_js_1.Container, { flex: "column", gap: "xs", center: "y", style: {
                    paddingLeft: index_js_2.spacing.md,
                }, children: (0, jsx_runtime_1.jsx)(WalletRow_js_1.WalletRow, { client: props.client, address: props.receiverAddress, iconSize: "md", textSize: "sm", label: "Recipient wallet" }) }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" }), (0, jsx_runtime_1.jsx)(basic_js_1.Container, { flex: "column", children: state.steps.map(({ step, status }, index) => ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", children: [(0, jsx_runtime_1.jsx)(FiatSteps_js_1.StepContainer, { state: status, index: index, style: {
                                flex: "1",
                            }, children: (0, jsx_runtime_1.jsx)(StepUI, { step: step, client: props.client, payer: props.payer, index: index }) }), index < state.steps.length - 1 && (0, jsx_runtime_1.jsx)(StepConnector_js_1.StepConnectorArrow, {})] }, step.action))) }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" }), (0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "xs", color: "secondaryText", center: true, style: { padding: `0 ${index_js_2.spacing.xl}` }, children: "Keep this window open until all transactions are complete." }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "lg" }), (0, jsx_runtime_1.jsx)(basic_js_1.Container, { flex: "column", gap: "md", children: !state.isDone &&
                    firstStepChainId &&
                    firstStepChainId !== props.payer.chain.id ? ((0, jsx_runtime_1.jsx)(SwitchNetwork_js_1.SwitchNetworkButton, { fullWidth: true, variant: "accent", switchChain: async () => {
                        await props.payer.wallet.switchChain((0, utils_js_1.getCachedChain)(firstStepChainId));
                    } })) : ((0, jsx_runtime_1.jsxs)(buttons_js_1.Button, { variant: "accent", gap: "sm", fullWidth: true, onClick: state.handleContinue, disabled: state.isLoading, children: [state.isLoading
                            ? "Processing"
                            : state.isDone
                                ? props.transactionMode
                                    ? "Continue Transaction"
                                    : "Done"
                                : state.isFailed
                                    ? "Retry"
                                    : "Continue", state.isLoading && (0, jsx_runtime_1.jsx)(Spinner_js_1.Spinner, { size: "sm", color: "primaryText" })] })) })] }));
}
function StepUI(props) {
    const { step, client } = props;
    const chain = (0, useChainQuery_js_1.useChainName)((0, utils_js_1.getCachedChain)(step.token.chainId));
    return ((0, jsx_runtime_1.jsx)(basic_js_1.Container, { flex: "column", gap: "xs", py: "3xs", children: (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", center: "y", gap: "sm", style: {
                display: "flex",
                justifyContent: "space-between",
                flexWrap: "nowrap",
            }, children: [(0, jsx_runtime_1.jsx)(PayTokenIcon_js_1.PayTokenIcon, { chain: (0, utils_js_1.getCachedChain)(step.token.chainId), client: client, size: "md", token: {
                        address: step.token.tokenAddress,
                    } }), (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", gap: "3xs", center: "y", style: { flex: "1" }, children: [(0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "sm", color: "primaryText", children: step.action.charAt(0).toUpperCase() + step.action.slice(1) }), (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", gap: "xs", center: "y", style: {
                                display: "flex",
                                justifyContent: "space-between",
                                flexWrap: "nowrap",
                            }, children: [(0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", gap: "xxs", center: "y", style: {
                                        flex: "1 1 60%",
                                        minWidth: 0,
                                        maxWidth: "60%",
                                        overflow: "hidden",
                                        flexWrap: "nowrap",
                                    }, children: [(0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "sm", color: "primaryText", children: (0, formatNumber_js_1.formatNumber)(Number(step.amount), 5) }), (0, jsx_runtime_1.jsx)(TokenSymbol_js_1.TokenSymbol, { token: {
                                                address: step.token.tokenAddress,
                                                name: step.token.name || "",
                                                symbol: step.token.symbol || "",
                                            }, chain: (0, utils_js_1.getCachedChain)(step.token.chainId), size: "sm", color: "secondaryText" })] }), (0, jsx_runtime_1.jsx)(basic_js_1.Container, { flex: "row", gap: "xs", center: "y", style: {
                                        flex: "1 1 40%",
                                        maxWidth: "40%",
                                        minWidth: 0,
                                        justifyContent: "flex-end",
                                        flexWrap: "nowrap",
                                    }, children: (0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "xs", style: {
                                            overflow: "hidden",
                                            textOverflow: "ellipsis",
                                            whiteSpace: "nowrap",
                                        }, children: chain.name }) })] })] })] }) }));
}
function useOnRampScreenState(props) {
    const onRampSteps = (0, isSwapRequiredPostOnramp_js_1.getOnRampSteps)(props.quote);
    const [currentStepIndex, setCurrentStepIndex] = (0, react_1.useState)(0);
    const [swapTxHash, setSwapTxHash] = (0, react_1.useState)();
    const [popupWindow, setPopupWindow] = (0, react_1.useState)(null);
    // Track onramp status
    const { uiStatus: fiatOnrampStatus } = useOnRampStatus({
        intentId: props.quote.intentId,
        client: props.client,
        onSuccess: (status) => {
            if (onRampSteps.length === 1) {
                // If only one step, this is the final success
                props.onSuccess(status);
            }
            else {
                // Move to next step (swap)
                setCurrentStepIndex((prev) => prev + 1);
            }
        },
        openedWindow: popupWindow,
    });
    // Get quote for current swap/bridge step if needed
    const previousStep = onRampSteps[currentStepIndex - 1];
    const currentStep = onRampSteps[currentStepIndex];
    // Handle swap execution
    const swapMutation = useSwapMutation({
        client: props.client,
        payer: props.payer,
        isFiatFlow: true,
    });
    // Track swap status
    const { uiStatus: swapStatus } = useSwapStatus({
        client: props.client,
        transactionHash: swapTxHash?.hash,
        chainId: swapTxHash?.chainId,
        onSuccess: () => {
            if (currentStepIndex === onRampSteps.length - 1) {
                // Last step completed - call final success
                (0, getStatus_js_1.getBuyWithFiatStatus)({
                    intentId: props.quote.intentId,
                    client: props.client,
                }).then(props.onSuccess);
            }
            else {
                // Reset swap state before moving to next step
                setSwapTxHash(undefined);
                swapMutation.reset();
                // Move to next step
                setCurrentStepIndex((prev) => prev + 1);
            }
        },
    });
    // Map steps to their current status
    const steps = onRampSteps.map((step, index) => {
        let status = "unknown";
        if (index === 0) {
            // First step (onramp) status
            status = fiatOnrampStatus;
        }
        else if (index < currentStepIndex) {
            // Previous steps are completed
            status = "completed";
        }
        else if (index === currentStepIndex) {
            // Current step - could be swap or bridge
            if (swapMutation.isPending) {
                status = "pending";
            }
            else if (swapMutation.error) {
                status = "failed";
            }
            else if (swapTxHash) {
                status = swapStatus;
            }
            else {
                status = "actionRequired";
            }
        }
        return {
            index,
            step,
            status,
        };
    });
    const isLoading = steps.some((step) => step.status === "pending");
    const isDone = steps.every((step) => step.status === "completed");
    const isFailed = steps.some((step) => step.status === "failed");
    // Update handleContinue to handle done state
    const handleContinue = (0, react_1.useCallback)(async () => {
        if (isDone) {
            props.onDone();
            return;
        }
        if (currentStepIndex === 0) {
            // First step - open onramp popup
            const popup = (0, openOnRamppopup_js_1.openOnrampPopup)(props.quote.onRampLink, props.theme);
            (0, pay_js_1.trackPayEvent)({
                event: "open_onramp_popup",
                client: props.client,
                walletAddress: props.payer.account.address,
                walletType: props.payer.wallet.id,
            });
            setPopupWindow(popup);
            (0, pendingSwapTx_js_1.addPendingTx)({
                type: "fiat",
                intentId: props.quote.intentId,
            });
        }
        else if (previousStep && currentStep && !swapTxHash) {
            // Execute swap/bridge
            try {
                const result = await swapMutation.mutateAsync({
                    fromToken: previousStep.token,
                    toToken: currentStep.token,
                    amount: currentStep.amount,
                });
                setSwapTxHash({
                    hash: result.transactionHash,
                    chainId: result.chainId,
                });
            }
            catch (e) {
                console.error("Failed to execute swap:", e);
            }
        }
        else if (isFailed) {
            // retry the quote step
            setSwapTxHash(undefined);
            swapMutation.reset();
        }
    }, [
        isDone,
        currentStepIndex,
        swapTxHash,
        props.quote,
        props.onDone,
        swapMutation,
        props.theme,
        isFailed,
        swapMutation.reset,
        props.client,
        props.payer.account.address,
        props.payer.wallet.id,
        currentStep,
        previousStep,
    ]);
    // Auto-progress effect
    (0, react_1.useEffect)(() => {
        if (!props.isAutoMode) {
            return;
        }
        // Auto-start next swap step when previous step completes
        if (!isLoading &&
            !isDone &&
            !isFailed &&
            currentStepIndex > 0 &&
            currentStepIndex < onRampSteps.length &&
            !swapTxHash) {
            handleContinue();
        }
    }, [
        props.isAutoMode,
        currentStepIndex,
        swapTxHash,
        onRampSteps.length,
        handleContinue,
        isDone,
        isFailed,
        isLoading,
    ]);
    return {
        steps,
        handleContinue,
        isLoading,
        isDone,
        isFailed,
    };
}
function useOnRampStatus(props) {
    const queryClient = (0, react_query_1.useQueryClient)();
    const statusQuery = (0, useBuyWithFiatStatus_js_1.useBuyWithFiatStatus)({
        intentId: props.intentId,
        client: props.client,
        queryOptions: {
            enabled: !!props.openedWindow,
        },
    });
    let uiStatus = "actionRequired";
    switch (statusQuery.data?.status) {
        case "ON_RAMP_TRANSFER_COMPLETED":
        case "CRYPTO_SWAP_COMPLETED":
        case "CRYPTO_SWAP_REQUIRED":
            uiStatus = "completed";
            break;
        case "CRYPTO_SWAP_FALLBACK":
            uiStatus = "partialSuccess";
            break;
        case "ON_RAMP_TRANSFER_FAILED":
        case "PAYMENT_FAILED":
            uiStatus = "failed";
            break;
        case "PENDING_PAYMENT":
        case "ON_RAMP_TRANSFER_IN_PROGRESS":
            uiStatus = "pending";
            break;
        default:
            uiStatus = "actionRequired";
            break;
    }
    const purchaseCbCalled = (0, react_1.useRef)(false);
    (0, react_1.useEffect)(() => {
        if (purchaseCbCalled.current || !props.onSuccess) {
            return;
        }
        if (statusQuery.data &&
            (uiStatus === "completed" || uiStatus === "partialSuccess")) {
            purchaseCbCalled.current = true;
            props.onSuccess(statusQuery.data);
        }
    }, [props.onSuccess, statusQuery.data, uiStatus]);
    // close the onramp popup if onramp is completed
    (0, react_1.useEffect)(() => {
        if (!props.openedWindow) {
            return;
        }
        if (uiStatus === "completed" || uiStatus === "partialSuccess") {
            try {
                if (props.openedWindow && !props.openedWindow.closed) {
                    props.openedWindow.close();
                }
            }
            catch (e) {
                console.warn("Failed to close payment window:", e);
            }
        }
    }, [props.openedWindow, uiStatus]);
    // invalidate wallet balance when onramp is completed
    const invalidatedBalance = (0, react_1.useRef)(false);
    (0, react_1.useEffect)(() => {
        if (!invalidatedBalance.current && uiStatus === "completed") {
            invalidatedBalance.current = true;
            (0, invalidateWalletBalance_js_1.invalidateWalletBalance)(queryClient);
        }
    }, [uiStatus, queryClient]);
    return { uiStatus };
}
function useSwapStatus(props) {
    const swapStatus = (0, useBuyWithCryptoStatus_js_1.useBuyWithCryptoStatus)(props.transactionHash && props.chainId
        ? {
            client: props.client,
            transactionHash: props.transactionHash,
            chainId: props.chainId,
        }
        : undefined);
    let uiStatus = "unknown";
    switch (swapStatus.data?.status) {
        case "COMPLETED":
            uiStatus = "completed";
            break;
        case "FAILED":
            uiStatus = "failed";
            break;
        case "PENDING":
        case "NOT_FOUND":
            uiStatus = "pending";
            break;
        case "NONE":
            uiStatus = "unknown";
            break;
        default:
            uiStatus = "unknown";
            break;
    }
    const purchaseCbCalled = (0, react_1.useRef)(false);
    (0, react_1.useEffect)(() => {
        if (purchaseCbCalled.current || !props.onSuccess) {
            return;
        }
        if (swapStatus.data?.status === "COMPLETED") {
            purchaseCbCalled.current = true;
            props.onSuccess(swapStatus.data);
        }
    }, [props.onSuccess, swapStatus]);
    const queryClient = (0, react_query_1.useQueryClient)();
    const balanceInvalidated = (0, react_1.useRef)(false);
    (0, react_1.useEffect)(() => {
        if (uiStatus === "completed" && !balanceInvalidated.current) {
            balanceInvalidated.current = true;
            (0, invalidateWalletBalance_js_1.invalidateWalletBalance)(queryClient);
        }
    }, [queryClient, uiStatus]);
    return { uiStatus };
}
function useSwapMutation(props) {
    const queryClient = (0, react_query_1.useQueryClient)();
    return (0, react_query_1.useMutation)({
        mutationFn: async (input) => {
            const { fromToken, toToken, amount } = input;
            const wallet = props.payer.wallet;
            // in case the wallet is not on the same chain as the fromToken, switch to it
            if (wallet.getChain()?.id !== fromToken.chainId) {
                await wallet.switchChain((0, utils_js_1.getCachedChain)(fromToken.chainId));
            }
            const account = wallet.getAccount();
            if (!account) {
                throw new Error("Payer wallet has no account");
            }
            // always get a fresh quote before executing
            const quote = await (0, getQuote_js_1.getBuyWithCryptoQuote)({
                fromChainId: fromToken.chainId,
                fromTokenAddress: fromToken.tokenAddress,
                toAmount: amount,
                toChainId: toToken.chainId,
                toTokenAddress: toToken.tokenAddress,
                fromAddress: account.address,
                toAddress: account.address,
                client: props.client,
            });
            const canBatch = account.sendBatchTransaction;
            const tokenContract = (0, contract_js_1.getContract)({
                client: props.client,
                address: quote.swapDetails.fromToken.tokenAddress,
                chain: (0, utils_js_1.getCachedChain)(quote.swapDetails.fromToken.chainId),
            });
            const approveTxRequired = quote.approvalData &&
                (await (0, allowance_js_1.allowance)({
                    contract: tokenContract,
                    owner: account.address,
                    spender: quote.approvalData.spenderAddress,
                })) < BigInt(quote.approvalData.amountWei);
            if (approveTxRequired && quote.approvalData && !canBatch) {
                (0, pay_js_1.trackPayEvent)({
                    event: "prompt_swap_approval",
                    client: props.client,
                    walletAddress: account.address,
                    walletType: props.payer.wallet.id,
                    fromToken: quote.swapDetails.fromToken.tokenAddress,
                    fromAmount: quote.swapDetails.fromAmountWei,
                    toToken: quote.swapDetails.toToken.tokenAddress,
                    toAmount: quote.swapDetails.toAmountWei,
                    chainId: quote.swapDetails.fromToken.chainId,
                    dstChainId: quote.swapDetails.toToken.chainId,
                });
                const transaction = (0, approve_js_1.approve)({
                    contract: tokenContract,
                    spender: quote.approvalData.spenderAddress,
                    amountWei: BigInt(quote.approvalData.amountWei),
                });
                const tx = await (0, send_transaction_js_1.sendTransaction)({
                    account,
                    transaction,
                });
                await (0, wait_for_tx_receipt_js_1.waitForReceipt)({ ...tx, maxBlocksWaitTime: 50 });
                (0, pay_js_1.trackPayEvent)({
                    event: "swap_approval_success",
                    client: props.client,
                    walletAddress: account.address,
                    walletType: props.payer.wallet.id,
                    fromToken: quote.swapDetails.fromToken.tokenAddress,
                    fromAmount: quote.swapDetails.fromAmountWei,
                    toToken: quote.swapDetails.toToken.tokenAddress,
                    toAmount: quote.swapDetails.toAmountWei,
                    chainId: quote.swapDetails.fromToken.chainId,
                    dstChainId: quote.swapDetails.toToken.chainId,
                });
            }
            (0, pay_js_1.trackPayEvent)({
                event: "prompt_swap_execution",
                client: props.client,
                walletAddress: account.address,
                walletType: props.payer.wallet.id,
                fromToken: quote.swapDetails.fromToken.tokenAddress,
                fromAmount: quote.swapDetails.fromAmountWei,
                toToken: quote.swapDetails.toToken.tokenAddress,
                toAmount: quote.swapDetails.toAmountWei,
                chainId: quote.swapDetails.fromToken.chainId,
                dstChainId: quote.swapDetails.toToken.chainId,
            });
            const tx = quote.transactionRequest;
            let _swapTx;
            // check if we can batch approval and swap
            if (canBatch && quote.approvalData && approveTxRequired) {
                const approveTx = (0, approve_js_1.approve)({
                    contract: tokenContract,
                    spender: quote.approvalData.spenderAddress,
                    amountWei: BigInt(quote.approvalData.amountWei),
                });
                _swapTx = await (0, send_batch_transaction_js_1.sendBatchTransaction)({
                    account,
                    transactions: [approveTx, tx],
                });
            }
            else {
                _swapTx = await (0, send_transaction_js_1.sendTransaction)({
                    account,
                    transaction: tx,
                });
            }
            await (0, wait_for_tx_receipt_js_1.waitForReceipt)({ ..._swapTx, maxBlocksWaitTime: 50 });
            (0, pay_js_1.trackPayEvent)({
                event: "swap_execution_success",
                client: props.client,
                walletAddress: account.address,
                walletType: props.payer.wallet.id,
                fromToken: quote.swapDetails.fromToken.tokenAddress,
                fromAmount: quote.swapDetails.fromAmountWei,
                toToken: quote.swapDetails.toToken.tokenAddress,
                toAmount: quote.swapDetails.toAmountWei,
                chainId: quote.swapDetails.fromToken.chainId,
                dstChainId: quote.swapDetails.toToken.chainId,
            });
            // do not add pending tx if the swap is part of fiat flow
            if (!props.isFiatFlow) {
                (0, pendingSwapTx_js_1.addPendingTx)({
                    type: "swap",
                    txHash: _swapTx.transactionHash,
                    chainId: _swapTx.chain.id,
                });
            }
            return {
                transactionHash: _swapTx.transactionHash,
                chainId: _swapTx.chain.id,
            };
        },
        onSuccess: () => {
            (0, invalidateWalletBalance_js_1.invalidateWalletBalance)(queryClient);
        },
    });
}
function isInAppSigner(options) {
    const isInAppOrEcosystem = (w) => (0, index_js_1.isInAppWallet)(w) || (0, is_ecosystem_wallet_js_1.isEcosystemWallet)(w);
    const isSmartWalletWithAdmin = (0, is_smart_wallet_js_1.isSmartWallet)(options.wallet) &&
        options.connectedWallets.some((w) => isInAppOrEcosystem(w) &&
            w.getAccount()?.address?.toLowerCase() ===
                options.wallet.getAdminAccount?.()?.address?.toLowerCase());
    return isInAppOrEcosystem(options.wallet) || isSmartWalletWithAdmin;
}
//# sourceMappingURL=OnRampScreen.js.map