"use strict";
"use client";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChainIcon = ChainIcon;
exports.fetchChainIcon = fetchChainIcon;
exports.getQueryKeys = getQueryKeys;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_query_1 = require("@tanstack/react-query");
const utils_js_1 = require("../../../../../chains/utils.js");
const function_id_js_1 = require("../../../../../utils/function-id.js");
const ipfs_js_1 = require("../../../../../utils/ipfs.js");
const provider_js_1 = require("./provider.js");
/**
 * This component tries to resolve the icon of a given chain, then return an image.
 * @returns an <img /> with the src of the chain icon
 *
 * @example
 * ### Basic usage
 * ```tsx
 * import { ChainProvider, ChainIcon } from "thirdweb/react";
 *
 * <ChainProvider chain={chain}>
 *   <ChainIcon />
 * </ChainProvider>
 * ```
 *
 * Result: An <img /> component with the src of the icon
 * ```html
 * <img src="chain-icon.png" />
 * ```
 *
 * ### Override the icon with the `iconResolver` prop
 * If you already have the icon url, you can skip the network requests and pass it directly to the ChainIcon
 * ```tsx
 * <ChainIcon iconResolver="/ethereum-icon.png" />
 * ```
 *
 * You can also pass in your own custom (async) function that retrieves the icon url
 * ```tsx
 * const getIcon = async () => {
 *   const icon = getIconFromCoinMarketCap(chainId, etc);
 *   return icon;
 * };
 *
 * <ChainIcon iconResolver={getIcon} />
 * ```
 *
 * ### Show a loading sign while the icon is being loaded
 * ```tsx
 * <ChainIcon loadingComponent={<Spinner />} />
 * ```
 *
 * ### Fallback to a dummy image if the chain icon fails to resolve
 * ```tsx
 * <ChainIcon fallbackComponent={<img src="blank-image.png" />} />
 * ```
 *
 * ### Usage with queryOptions
 * ChainIcon uses useQuery() from tanstack query internally.
 * It allows you to pass a custom queryOptions of your choice for more control of the internal fetching logic
 * ```tsx
 * <ChainIcon queryOptions={{ enabled: someLogic, retry: 3, }} />
 * ```
 *
 * @component
 * @chain
 * @beta
 */
function ChainIcon({ iconResolver, loadingComponent, fallbackComponent, queryOptions, client, ...restProps }) {
    const { chain } = (0, provider_js_1.useChainContext)();
    const iconQuery = (0, react_query_1.useQuery)({
        queryKey: getQueryKeys({ chainId: chain.id, iconResolver }),
        queryFn: async () => fetchChainIcon({ chain, client, iconResolver }),
        ...queryOptions,
    });
    if (iconQuery.isLoading) {
        return loadingComponent || null;
    }
    if (!iconQuery.data) {
        return fallbackComponent || null;
    }
    return (0, jsx_runtime_1.jsx)("img", { src: iconQuery.data, ...restProps, alt: restProps.alt });
}
/**
 * @internal Exported for tests only
 */
async function fetchChainIcon(props) {
    const { chain, client, iconResolver } = props;
    if (typeof iconResolver === "string") {
        return iconResolver;
    }
    if (typeof iconResolver === "function") {
        return iconResolver();
    }
    // Check if the chain object already has "icon"
    if (chain.icon?.url) {
        return (0, ipfs_js_1.resolveScheme)({ uri: chain.icon.url, client });
    }
    const possibleUrl = await (0, utils_js_1.getChainMetadata)(chain)
        .then((data) => data.icon?.url)
        .catch(() => undefined);
    if (!possibleUrl) {
        throw new Error("Failed to resolve icon for chain");
    }
    return (0, ipfs_js_1.resolveScheme)({ uri: possibleUrl, client });
}
/**
 * @internal
 */
function getQueryKeys(props) {
    const { chainId, iconResolver } = props;
    return [
        "_internal_chain_icon_",
        chainId,
        {
            resolver: typeof iconResolver === "string"
                ? iconResolver
                : typeof iconResolver === "function"
                    ? (0, function_id_js_1.getFunctionId)(iconResolver)
                    : undefined,
        },
    ];
}
//# sourceMappingURL=icon.js.map