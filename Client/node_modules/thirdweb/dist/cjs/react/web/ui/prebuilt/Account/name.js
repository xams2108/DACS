"use strict";
"use client";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountName = AccountName;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_query_1 = require("@tanstack/react-query");
const resolve_name_js_1 = require("../../../../../extensions/ens/resolve-name.js");
const profiles_js_1 = require("../../../../../social/profiles.js");
const provider_js_1 = require("../../../../core/account/provider.js");
/**
 * This component is used to display the name of the account.
 * A "name" in this context is the username, or account of the social profiles that the wallet may have.
 * In case a name is not found or failed to resolve, you can always fallback to displaying the wallet address instead by using the `fallbackComponent` prop.
 *
 * This component inherits all attribute of a native HTML <span> element, so you can style it just like how you would style a <span>.
 *
 * @param props
 * @returns A `<span>` containing the name of the account
 * ```html
 * <span>{name}</span>
 * ```
 *
 * @example
 * ### Basic usage
 * ```tsx
 * import { AccountProvider, AccountName } from "thirdweb/react";
 *
 * <AccountProvider address="0x1234...3f3f" client={client}>
 *   <AccountName />
 * </AccountProvider>
 * ```
 *
 * ### Show wallet address while social name is being loaded
 * ```tsx
 * <AccountName
 *   loadingComponent={<AccountAddress />}
 * />
 * ```
 *
 *
 * ### Fallback to showing wallet address if fail to resolve social name
 * ```tsx
 * <AccountName
 *   fallbackComponent={<AccountAddress />}
 * />
 * ```
 *
 * ### Transform the account name using `formatFn` prop
 * ```tsx
 * import { isAddress, shortenAddress } from "thirdweb/utils";
 * import { AccountProvider, AccountName } from "thirdweb/react";
 *
 * // Let's say we want the name to be capitalized without using CSS
 * const formatName = (name: string) => name.toUpperCase();
 *
 * return <AccountName formatFn={formatName} />
 * ```
 *
 *
 * ### Custom query options for useQuery
 * This component uses `@tanstack-query`'s useQuery internally.
 * You can use the `queryOptions` prop for more fine-grained control
 * ```tsx
 * <AccountName
 *   queryOptions={{
 *     enabled: isEnabled,
 *     retry: 3
 *   }}
 * />
 * ```
 *
 * @component
 * @wallet
 * @beta
 */
function AccountName({ resolverAddress, resolverChain, socialType, formatFn, queryOptions, loadingComponent, fallbackComponent, ...restProps }) {
    const { address, client } = (0, provider_js_1.useAccountContext)();
    const nameQuery = (0, react_query_1.useQuery)({
        queryKey: [
            "account-name",
            address,
            { socialType },
            { resolverAddress, resolverChain },
        ],
        queryFn: async () => {
            const [socialData, ensName] = await Promise.all([
                (0, profiles_js_1.getSocialProfiles)({ address, client }),
                (0, resolve_name_js_1.resolveName)({
                    client,
                    address,
                    resolverAddress,
                    resolverChain,
                }),
            ]);
            const name = socialData?.filter((p) => p.name && (socialType ? p.type === socialType : true))[0]?.name || ensName;
            if (!name) {
                throw new Error("Failed to resolve account name");
            }
            return formatFn ? formatFn(name) : name;
        },
        retry: false,
        ...queryOptions,
    });
    if (nameQuery.isLoading) {
        return loadingComponent || null;
    }
    if (!nameQuery.data) {
        return fallbackComponent || null;
    }
    return (0, jsx_runtime_1.jsx)("span", { ...restProps, children: nameQuery.data });
}
//# sourceMappingURL=name.js.map