"use strict";
"use client";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenSymbol = TokenSymbol;
exports.fetchTokenSymbol = fetchTokenSymbol;
exports.getQueryKeys = getQueryKeys;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_query_1 = require("@tanstack/react-query");
const utils_js_1 = require("../../../../../chains/utils.js");
const addresses_js_1 = require("../../../../../constants/addresses.js");
const contract_js_1 = require("../../../../../contract/contract.js");
const getContractMetadata_js_1 = require("../../../../../extensions/common/read/getContractMetadata.js");
const symbol_js_1 = require("../../../../../extensions/common/read/symbol.js");
const function_id_js_1 = require("../../../../../utils/function-id.js");
const provider_js_1 = require("./provider.js");
/**
 * This component fetches then shows the symbol of a token. For ERC20 tokens, it calls the `symbol` function in the ERC20 contract.
 * It inherits all the attributes of a HTML <span> component, hence you can style it just like how you would style a normal <span>
 *
 *
 * @example
 * ### Basic usage
 * ```tsx
 * import { TokenProvider, TokenSymbol } from "thirdweb/react";
 * import { ethereum } from "thirdweb/chains";
 *
 * <TokenProvider {...props}>
 *   <TokenSymbol  />
 * </TokenProvider>
 * ```
 * Result:
 * ```html
 * <span>ETH</span>
 * ```
 *
 * ### Custom symbol resolver
 * By default, TokenSymbol calls the `symbol` function of your contract,
 * however, if your token as an unconventional way to fetch the symbol, you can pass the custom logic to the `symbolResolver` prop.
 * It can either be a string or a function (async) that returns or resolves to a string.
 * ```tsx
 * async function getSymbol() {
 *   // your own fetching logic
 *   return "the symbol";
 * }
 *
 * <TokenSymbol symbolResolver={getSymbol} />
 * ```
 * Alternatively, you can pass in a string directly:
 * ```tsx
 * <TokenSymbol symbolResolver="USDC.e" />
 * ```
 *
 * ### Format the symbol (capitalize, truncate, etc.)
 * The TokenSymbol component accepts a `formatFn` which takes in a string and outputs a string
 * The function is used to modify the symbol of the token
 *
 * ```tsx
 * const concatStr = (str: string):string => str + "Token"
 *
 * <TokenSymbol formatFn={concatStr} />
 * ```
 *
 * Result:
 * ```html
 * <span>Ether Token</span>
 * ```
 *
 * ### Show a loading sign when the symbol is being fetched
 * ```tsx
 * import { TokenProvider, TokenSymbol } from "thirdweb/react";
 *
 * <TokenProvider address="0x...">
 *   <TokenSymbol loadingComponent={<Spinner />} />
 * </TokenProvider>
 * ```
 *
 * ### Fallback to something when the symbol fails to resolve
 * ```tsx
 * <TokenProvider address="0x...">
 *   <TokenSymbol fallbackComponent={"Failed to load"} />
 * </TokenProvider>
 * ```
 *
 * ### Custom query options for useQuery
 * This component uses `@tanstack-query`'s useQuery internally.
 * You can use the `queryOptions` prop for more fine-grained control
 * ```tsx
 * <TokenSymbol queryOptions={{
 *     enabled: isEnabled,
 *     retry: 4,
 *   }}
 * />
 * ```
 *
 * @component
 * @token
 * @beta
 */
function TokenSymbol({ symbolResolver, formatFn, loadingComponent, fallbackComponent, queryOptions, ...restProps }) {
    const { address, client, chain } = (0, provider_js_1.useTokenContext)();
    const symbolQuery = (0, react_query_1.useQuery)({
        queryKey: getQueryKeys({ chainId: chain.id, address, symbolResolver }),
        queryFn: async () => fetchTokenSymbol({ symbolResolver, address, chain, client }),
        ...queryOptions,
    });
    if (symbolQuery.isLoading) {
        return loadingComponent || null;
    }
    if (!symbolQuery.data) {
        return fallbackComponent || null;
    }
    if (formatFn && typeof formatFn === "function") {
        return (0, jsx_runtime_1.jsx)("span", { ...restProps, children: formatFn(symbolQuery.data) });
    }
    return (0, jsx_runtime_1.jsx)("span", { ...restProps, children: symbolQuery.data });
}
/**
 * @internal Exported for tests only
 */
async function fetchTokenSymbol(props) {
    const { symbolResolver, address, client, chain } = props;
    if (typeof symbolResolver === "string") {
        return symbolResolver;
    }
    if (typeof symbolResolver === "function") {
        return symbolResolver();
    }
    if (address.toLowerCase() === addresses_js_1.NATIVE_TOKEN_ADDRESS.toLowerCase()) {
        // Don't wanna use `getChainSymbol` because it has some side effect (it catches error and defaults to "ETH")
        return (0, utils_js_1.getChainMetadata)(chain).then((data) => data.nativeCurrency.symbol);
    }
    // Try to fetch the symbol from both the `symbol` function and the contract metadata
    // then prioritize its result
    const contract = (0, contract_js_1.getContract)({ address, client, chain });
    const [_symbol, contractMetadata] = await Promise.all([
        (0, symbol_js_1.symbol)({ contract }).catch(() => undefined),
        (0, getContractMetadata_js_1.getContractMetadata)({ contract }).catch(() => undefined),
    ]);
    if (typeof _symbol === "string") {
        return _symbol;
    }
    if (typeof contractMetadata?.symbol === "string") {
        return contractMetadata.symbol;
    }
    throw new Error("Failed to resolve symbol from both symbol() and contract metadata");
}
/**
 * @internal
 */
function getQueryKeys(props) {
    const { chainId, address, symbolResolver } = props;
    return [
        "_internal_token_symbol_",
        chainId,
        address,
        {
            resolver: typeof symbolResolver === "string"
                ? symbolResolver
                : typeof symbolResolver === "function"
                    ? (0, function_id_js_1.getFunctionId)(symbolResolver)
                    : undefined,
        },
    ];
}
//# sourceMappingURL=symbol.js.map