"use strict";
"use client";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NFTName = NFTName;
exports.getQueryKey = getQueryKey;
exports.fetchNftName = fetchNftName;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_query_1 = require("@tanstack/react-query");
const function_id_js_1 = require("../../../../../utils/function-id.js");
const provider_js_1 = require("./provider.js");
const utils_js_1 = require("./utils.js");
/**
 * This component fetches and displays an NFT's name. It takes in a `className` and `style` props
 * so you can style it just like how you would style a <span> element.
 * @returns A <span> element containing the name of the NFT
 *
 * @example
 * ### Basic usage
 * ```tsx
 * import { NFTProvider, NFTName } from "thirdweb/react";
 *
 * <NFTProvider>
 *   <NFTName />
 * </NFTProvider>
 * ```
 *
 * ### Show a loading sign while the name is being fetched
 * ```tsx
 * import { NFTProvider, NFTName } from "thirdweb/react";
 *
 * <NFTProvider>
 *   <NFTName loadingComponent={<YourLoadingSign />} />
 * </NFTProvider>
 * ```
 *
 * ### Show something in case the name failed to resolve
 * ```tsx
 * import { NFTProvider, NFTName } from "thirdweb/react";
 *
 * <NFTProvider>
 *   <NFTName fallbackComponent={<span>Failed to load name</span>} />
 * </NFTProvider>
 * ```
 *
 * ### Custom query options for useQuery (tanstack-query)
 * ```tsx
 * import { NFTProvider, NFTName } from "thirdweb/react";
 *
 * <NFTProvider>
 *   <NFTName queryOptions={{ retry: 3, enabled: false, }} />
 * </NFTProvider>
 * ```
 *
 * ### Override the name with the `nameResolver` prop
 * If you already have the name, you can skip the network requests and pass it directly to the NFTName
 * ```tsx
 * <NFTName nameResolver="Doodles #1" />
 * ```
 *
 * You can also pass in your own custom (async) function that retrieves the name
 * ```tsx
 * const getName = async () => {
 *   // ...
 *   return name;
 * };
 *
 * <NFTName nameResolver={getName} />
 * ```
 *
 * @nft
 * @component
 * @beta
 */
function NFTName({ loadingComponent, fallbackComponent, queryOptions, nameResolver, ...restProps }) {
    const { contract, tokenId } = (0, provider_js_1.useNFTContext)();
    const nameQuery = (0, react_query_1.useQuery)({
        queryKey: getQueryKey({
            contractAddress: contract.address,
            chainId: contract.chain.id,
            tokenId,
            nameResolver,
        }),
        queryFn: async () => fetchNftName({ nameResolver, contract, tokenId }),
        ...queryOptions,
    });
    if (nameQuery.isLoading) {
        return loadingComponent || null;
    }
    if (!nameQuery.data) {
        return fallbackComponent || null;
    }
    return (0, jsx_runtime_1.jsx)("span", { ...restProps, children: nameQuery.data });
}
/**
 * @internal
 */
function getQueryKey(props) {
    const { chainId, tokenId, nameResolver, contractAddress } = props;
    return [
        "_internal_nft_name_",
        chainId,
        contractAddress,
        tokenId.toString(),
        {
            resolver: typeof nameResolver === "string"
                ? nameResolver
                : typeof nameResolver === "function"
                    ? (0, function_id_js_1.getFunctionId)(nameResolver)
                    : undefined,
        },
    ];
}
/**
 * @internal Exported for tests
 */
async function fetchNftName(props) {
    const { nameResolver, contract, tokenId } = props;
    if (typeof nameResolver === "string") {
        return nameResolver;
    }
    if (typeof nameResolver === "function") {
        return nameResolver();
    }
    const nft = await (0, utils_js_1.getNFTInfo)({ contract, tokenId }).catch(() => undefined);
    if (!nft) {
        throw new Error("Failed to resolve NFT info");
    }
    if (typeof nft.metadata.name !== "string") {
        throw new Error("Failed to resolve NFT name");
    }
    return nft.metadata.name;
}
//# sourceMappingURL=name.js.map