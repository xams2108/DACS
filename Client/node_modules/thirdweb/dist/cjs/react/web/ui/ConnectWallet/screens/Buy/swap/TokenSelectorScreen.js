"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenSelectorScreen = TokenSelectorScreen;
const jsx_runtime_1 = require("react/jsx-runtime");
const styled_1 = require("@emotion/styled");
const react_icons_1 = require("@radix-ui/react-icons");
const react_query_1 = require("@tanstack/react-query");
const utils_js_1 = require("../../../../../../../chains/utils.js");
const addresses_js_1 = require("../../../../../../../constants/addresses.js");
const getWalletBalance_js_1 = require("../../../../../../../wallets/utils/getWalletBalance.js");
const CustomThemeProvider_js_1 = require("../../../../../../core/design-system/CustomThemeProvider.js");
const index_js_1 = require("../../../../../../core/design-system/index.js");
const useChainQuery_js_1 = require("../../../../../../core/hooks/others/useChainQuery.js");
const useActiveAccount_js_1 = require("../../../../../../core/hooks/wallets/useActiveAccount.js");
const useConnectedWallets_js_1 = require("../../../../../../core/hooks/wallets/useConnectedWallets.js");
const useDisconnect_js_1 = require("../../../../../../core/hooks/wallets/useDisconnect.js");
const LoadingScreen_js_1 = require("../../../../../wallets/shared/LoadingScreen.js");
const Spacer_js_1 = require("../../../../components/Spacer.js");
const TextDivider_js_1 = require("../../../../components/TextDivider.js");
const TokenIcon_js_1 = require("../../../../components/TokenIcon.js");
const basic_js_1 = require("../../../../components/basic.js");
const buttons_js_1 = require("../../../../components/buttons.js");
const text_js_1 = require("../../../../components/text.js");
const OutlineWalletIcon_js_1 = require("../../../icons/OutlineWalletIcon.js");
const formatTokenBalance_js_1 = require("../../formatTokenBalance.js");
const nativeToken_js_1 = require("../../nativeToken.js");
const FiatValue_js_1 = require("./FiatValue.js");
const WalletRow_js_1 = require("./WalletRow.js");
function TokenSelectorScreen(props) {
    const connectedWallets = (0, useConnectedWallets_js_1.useConnectedWallets)();
    const activeAccount = (0, useActiveAccount_js_1.useActiveAccount)();
    const chainInfo = (0, useChainQuery_js_1.useChainMetadata)(props.toChain);
    const theme = (0, CustomThemeProvider_js_1.useCustomTheme)();
    const walletsAndBalances = (0, react_query_1.useQuery)({
        queryKey: [
            "wallets-and-balances",
            props.sourceSupportedTokens,
            props.toChain.id,
            props.toToken,
            props.tokenAmount,
            props.mode,
            activeAccount?.address,
            connectedWallets.map((w) => w.getAccount()?.address),
        ],
        queryFn: async () => {
            // in parallel, get the balances of all the wallets on each of the sourceSupportedTokens
            const walletBalanceMap = new Map();
            const balancePromises = connectedWallets.flatMap((wallet) => {
                const account = wallet.getAccount();
                if (!account)
                    return [];
                const walletKey = {
                    id: wallet.id,
                    address: account.address,
                };
                walletBalanceMap.set(walletKey, []);
                // inject the destination token too since it can be used as well to pay/transfer
                const toToken = (0, nativeToken_js_1.isNativeToken)(props.toToken)
                    ? {
                        address: addresses_js_1.NATIVE_TOKEN_ADDRESS,
                        name: chainInfo.data?.nativeCurrency.name || "",
                        symbol: chainInfo.data?.nativeCurrency.symbol || "",
                        icon: chainInfo.data?.icon?.url,
                    }
                    : props.toToken;
                const tokens = {
                    ...props.sourceSupportedTokens,
                    [props.toChain.id]: [
                        toToken,
                        ...(props.sourceSupportedTokens?.[props.toChain.id] || []),
                    ],
                };
                return Object.entries(tokens).flatMap(([chainId, tokens]) => {
                    return tokens.map(async (token) => {
                        try {
                            const chain = (0, utils_js_1.getCachedChain)(Number(chainId));
                            const balance = await (0, getWalletBalance_js_1.getWalletBalance)({
                                address: account.address,
                                chain,
                                tokenAddress: (0, nativeToken_js_1.isNativeToken)(token) ? undefined : token.address,
                                client: props.client,
                            });
                            // show the token if:
                            // - its not the destination token and balance is greater than 0
                            // - its the destination token and balance is greater than the token amount AND we the account is not the default account in fund_wallet mode
                            const shouldInclude = token.address === toToken.address &&
                                chain.id === props.toChain.id
                                ? props.mode === "fund_wallet" &&
                                    account.address === activeAccount?.address
                                    ? false
                                    : Number(balance.displayValue) > Number(props.tokenAmount)
                                : balance.value > 0n;
                            if (shouldInclude) {
                                const existingBalances = walletBalanceMap.get(walletKey) || [];
                                existingBalances.push({ balance, chain, token });
                                existingBalances.sort((a, b) => {
                                    if (a.chain.id === props.toChain.id &&
                                        a.token.address === toToken.address)
                                        return -1;
                                    if (b.chain.id === props.toChain.id &&
                                        b.token.address === toToken.address)
                                        return 1;
                                    if (a.chain.id === props.toChain.id)
                                        return -1;
                                    if (b.chain.id === props.toChain.id)
                                        return 1;
                                    return a.chain.id > b.chain.id ? 1 : -1;
                                });
                            }
                        }
                        catch (error) {
                            console.error(`Failed to fetch balance for wallet ${wallet.id} on chain ${chainId} for token ${token.symbol}:`, error);
                        }
                    });
                });
            });
            await Promise.all(balancePromises);
            return walletBalanceMap;
        },
        enabled: !!props.sourceSupportedTokens && !!chainInfo.data,
    });
    if (walletsAndBalances.isLoading ||
        chainInfo.isLoading ||
        !chainInfo.data ||
        !props.sourceSupportedTokens) {
        return (0, jsx_runtime_1.jsx)(LoadingScreen_js_1.LoadingScreen, {});
    }
    const filteredWallets = Array.from(walletsAndBalances.data?.entries() || [])
        .filter(([w]) => !props.hiddenWallets?.includes(w.id))
        .filter(([, balances]) => {
        const hasEnoughBalance = balances.some((b) => b.balance.value > 0);
        return hasEnoughBalance;
    });
    return ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { animate: "fadein", style: {
            minHeight: "200px",
        }, children: [filteredWallets.length === 0 ? ((0, jsx_runtime_1.jsx)(basic_js_1.Container, { flex: "column", gap: "xs", py: "lg", children: (0, jsx_runtime_1.jsxs)(text_js_1.Text, { size: "xs", color: "secondaryText", center: true, children: ["No suitable payment token found", (0, jsx_runtime_1.jsx)("br", {}), "in connected wallets"] }) })) : ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", gap: "xs", children: [(0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "sm", children: "Select payment token" }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "xs" })] })), (0, jsx_runtime_1.jsx)(basic_js_1.Container, { scrollY: true, style: {
                    maxHeight: "350px",
                }, children: (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", gap: "sm", children: [filteredWallets.map(([w, balances]) => {
                            const address = w.address;
                            const wallet = connectedWallets.find((w) => w.getAccount()?.address === address);
                            if (!wallet)
                                return null;
                            return ((0, jsx_runtime_1.jsx)(WalletRowWithBalances, { wallet: wallet, balances: balances, client: props.client, address: address, onClick: props.onSelectToken }, w.id));
                        }), filteredWallets.length > 0 && (0, jsx_runtime_1.jsx)(TextDivider_js_1.TextDivider, { text: "OR" }), (0, jsx_runtime_1.jsx)(buttons_js_1.Button, { variant: "secondary", fullWidth: true, onClick: props.onConnect, bg: "tertiaryBg", style: {
                                border: `1px solid ${theme.colors.borderColor}`,
                                padding: index_js_1.spacing.sm,
                            }, children: (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", gap: "sm", center: "y", expand: true, color: "secondaryIconColor", children: [(0, jsx_runtime_1.jsx)(OutlineWalletIcon_js_1.OutlineWalletIcon, { size: index_js_1.iconSize.md }), (0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "sm", color: "primaryText", children: "Pay with another wallet" })] }) }), props.fiatSupported && ((0, jsx_runtime_1.jsx)(buttons_js_1.Button, { variant: "secondary", fullWidth: true, onClick: props.onPayWithFiat, bg: "tertiaryBg", style: {
                                border: `1px solid ${theme.colors.borderColor}`,
                                padding: index_js_1.spacing.sm,
                            }, children: (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", gap: "sm", center: "y", expand: true, color: "secondaryIconColor", children: [(0, jsx_runtime_1.jsx)(react_icons_1.CardStackIcon, { width: index_js_1.iconSize.md, height: index_js_1.iconSize.md }), (0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "sm", color: "primaryText", children: "Pay with a debit card" })] }) }))] }) })] }));
}
function WalletRowWithBalances(props) {
    const theme = (0, CustomThemeProvider_js_1.useCustomTheme)();
    const displayedBalances = props.balances;
    const activeAccount = (0, useActiveAccount_js_1.useActiveAccount)();
    const { disconnect } = (0, useDisconnect_js_1.useDisconnect)();
    const isActiveAccount = activeAccount?.address === props.address;
    return ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", style: {
            borderRadius: index_js_1.radius.lg,
            border: `1px solid ${theme.colors.borderColor}`,
        }, children: [(0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", gap: "sm", bg: "tertiaryBg", style: {
                    justifyContent: "space-between",
                    borderTopRightRadius: index_js_1.radius.lg,
                    borderTopLeftRadius: index_js_1.radius.lg,
                    padding: index_js_1.spacing.sm,
                    paddingRight: index_js_1.spacing.xs,
                    borderBottom: `1px solid ${theme.colors.borderColor}`,
                }, children: [(0, jsx_runtime_1.jsx)(WalletRow_js_1.WalletRow, { ...props }), !isActiveAccount && ((0, jsx_runtime_1.jsx)(buttons_js_1.Button, { variant: "ghost", onClick: () => disconnect(props.wallet), style: {
                            padding: index_js_1.spacing.xxs,
                            color: theme.colors.secondaryText,
                        }, children: (0, jsx_runtime_1.jsx)(react_icons_1.Cross2Icon, { width: index_js_1.iconSize.sm, height: index_js_1.iconSize.sm }) }))] }), (0, jsx_runtime_1.jsx)(basic_js_1.Container, { flex: "column", children: props.balances.length > 0 ? (displayedBalances.map((b, idx) => ((0, jsx_runtime_1.jsx)(TokenBalanceRow, { client: props.client, onClick: () => props.onClick(props.wallet, b.token, b.chain), tokenBalance: b, wallet: props.wallet, style: {
                        borderTopLeftRadius: 0,
                        borderTopRightRadius: 0,
                        borderBottomRightRadius: idx === displayedBalances.length - 1 ? index_js_1.radius.lg : 0,
                        borderBottomLeftRadius: idx === displayedBalances.length - 1 ? index_js_1.radius.lg : 0,
                        borderBottom: idx === displayedBalances.length - 1
                            ? "none"
                            : `1px solid ${theme.colors.borderColor}`,
                    } }, `${b.token.address}-${b.chain.id}`)))) : ((0, jsx_runtime_1.jsx)(basic_js_1.Container, { style: { padding: index_js_1.spacing.sm }, children: (0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "sm", color: "secondaryText", children: "Insufficient Funds" }) })) })] }));
}
function TokenBalanceRow(props) {
    const { tokenBalance, wallet, onClick, client, style } = props;
    const chainInfo = (0, useChainQuery_js_1.useChainName)(tokenBalance.chain);
    return ((0, jsx_runtime_1.jsxs)(StyledButton, { onClick: () => onClick(tokenBalance.token, wallet), variant: "secondary", style: {
            ...style,
            display: "flex",
            justifyContent: "space-between",
            minWidth: 0, // Needed for text truncation to work
        }, children: [(0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", center: "y", gap: "sm", style: {
                    flex: "1 1 50%",
                    minWidth: 0,
                    maxWidth: "50%",
                    overflow: "hidden",
                    flexWrap: "nowrap",
                }, children: [(0, jsx_runtime_1.jsx)(TokenIcon_js_1.TokenIcon, { token: tokenBalance.token, chain: tokenBalance.chain, size: "md", client: client }), (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", gap: "4xs", style: { minWidth: 0 }, children: [(0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "xs", color: "primaryText", style: {
                                    overflow: "hidden",
                                    textOverflow: "ellipsis",
                                    whiteSpace: "nowrap",
                                }, children: tokenBalance.token.symbol }), chainInfo && ((0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "xs", style: {
                                    overflow: "hidden",
                                    textOverflow: "ellipsis",
                                    whiteSpace: "nowrap",
                                }, children: chainInfo.name }))] })] }), (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", center: "y", gap: "4xs", color: "secondaryText", style: {
                    flex: "1 1 50%",
                    maxWidth: "50%",
                    minWidth: 0,
                    justifyContent: "flex-end",
                    flexWrap: "nowrap",
                }, children: [(0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", color: "secondaryText", gap: "4xs", style: {
                            alignItems: "flex-end",
                            minWidth: 0,
                            overflow: "hidden",
                        }, children: [(0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "xs", color: "primaryText", style: {
                                    overflow: "hidden",
                                    textOverflow: "ellipsis",
                                    whiteSpace: "nowrap",
                                }, children: (0, formatTokenBalance_js_1.formatTokenBalance)(tokenBalance.balance, true, 2) }), (0, jsx_runtime_1.jsx)(FiatValue_js_1.FiatValue, { tokenAmount: tokenBalance.balance.displayValue, token: tokenBalance.token, chain: tokenBalance.chain, client: client, size: "xs" })] }), (0, jsx_runtime_1.jsx)(react_icons_1.ChevronRightIcon, { width: index_js_1.iconSize.md, height: index_js_1.iconSize.md, style: { flexShrink: 0 } })] })] }));
}
const StyledButton = /* @__PURE__ */ (0, styled_1.default)(buttons_js_1.Button)((props) => {
    const theme = (0, CustomThemeProvider_js_1.useCustomTheme)();
    return {
        background: "transparent",
        justifyContent: "space-between",
        flexWrap: "nowrap",
        flexDirection: "row",
        padding: index_js_1.spacing.sm,
        paddingRight: index_js_1.spacing.xs,
        gap: index_js_1.spacing.sm,
        "&:hover": {
            background: theme.colors.secondaryButtonBg,
            transform: "scale(1.01)",
        },
        transition: "background 200ms ease, transform 150ms ease",
        ...props.style,
    };
});
//# sourceMappingURL=TokenSelectorScreen.js.map