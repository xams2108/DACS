"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleSmartWalletConnection = void 0;
exports.createConnectionManager = createConnectionManager;
exports.getStoredConnectedWalletIds = getStoredConnectedWalletIds;
exports.getStoredActiveWalletId = getStoredActiveWalletId;
exports.getLastConnectedChain = getLastConnectedChain;
const utils_js_1 = require("../../chains/utils.js");
const isSmartWallet_js_1 = require("../../react/core/utils/isSmartWallet.js");
const computedStore_js_1 = require("../../reactive/computedStore.js");
const effect_js_1 = require("../../reactive/effect.js");
const store_js_1 = require("../../reactive/store.js");
const json_js_1 = require("../../utils/json.js");
const walletStorage_js_1 = require("../../utils/storage/walletStorage.js");
const index_js_1 = require("../smart/index.js");
const smart_wallet_js_1 = require("../smart/smart-wallet.js");
const CONNECTED_WALLET_IDS = "thirdweb:connected-wallet-ids";
const LAST_ACTIVE_EOA_ID = "thirdweb:active-wallet-id";
const LAST_ACTIVE_CHAIN = "thirdweb:active-chain";
/**
 * Create a connection manager for Wallet connections
 * @param storage - An instance of type [`AsyncStorage`](https://portal.thirdweb.com/references/typescript/v5/AsyncStorage)
 * @example
 * ```ts
 * const manager = createConnectionManager();
 * ```
 * @returns A connection manager object
 * @walletUtils
 */
function createConnectionManager(storage) {
    // stores
    // active wallet/account
    const activeWalletStore = (0, store_js_1.createStore)(undefined);
    const activeAccountStore = (0, store_js_1.createStore)(undefined);
    const activeWalletChainStore = (0, store_js_1.createStore)(undefined);
    const activeWalletConnectionStatusStore = (0, store_js_1.createStore)("unknown");
    const definedChainsStore = (0, store_js_1.createStore)(new Map());
    // update global cachedChains when defined Chains store updates
    (0, effect_js_1.effect)(() => {
        (0, utils_js_1.cacheChains)([...definedChainsStore.getValue().values()]);
    }, [definedChainsStore]);
    // change the active chain object to use the defined chain object
    (0, effect_js_1.effect)(() => {
        const chainVal = activeWalletChainStore.getValue();
        if (!chainVal) {
            return;
        }
        const definedChain = definedChainsStore.getValue().get(chainVal.id);
        if (!definedChain || definedChain === chainVal) {
            return;
        }
        // update active chain store
        activeWalletChainStore.setValue(definedChain);
    }, [definedChainsStore, activeWalletChainStore]);
    // other connected accounts
    const walletIdToConnectedWalletMap = (0, store_js_1.createStore)(new Map());
    const isAutoConnecting = (0, store_js_1.createStore)(false);
    const connectedWallets = (0, computedStore_js_1.computedStore)(() => {
        return Array.from(walletIdToConnectedWalletMap.getValue().values());
    }, [walletIdToConnectedWalletMap]);
    // actions
    const addConnectedWallet = (wallet) => {
        const oldValue = walletIdToConnectedWalletMap.getValue();
        if (oldValue.has(wallet.id)) {
            return;
        }
        const newValue = new Map(oldValue);
        newValue.set(wallet.id, wallet);
        walletIdToConnectedWalletMap.setValue(newValue);
    };
    const removeConnectedWallet = (wallet) => {
        const oldValue = walletIdToConnectedWalletMap.getValue();
        const newValue = new Map(oldValue);
        newValue.delete(wallet.id);
        walletIdToConnectedWalletMap.setValue(newValue);
    };
    const onWalletDisconnect = (wallet) => {
        (0, walletStorage_js_1.deleteConnectParamsFromStorage)(storage, wallet.id);
        removeConnectedWallet(wallet);
        // if disconnecting the active wallet
        if (activeWalletStore.getValue() === wallet) {
            storage.removeItem(LAST_ACTIVE_EOA_ID);
            activeAccountStore.setValue(undefined);
            activeWalletChainStore.setValue(undefined);
            activeWalletStore.setValue(undefined);
            activeWalletConnectionStatusStore.setValue("disconnected");
        }
    };
    const disconnectWallet = (wallet) => {
        onWalletDisconnect(wallet);
        wallet.disconnect();
    };
    // handle the connection logic, but don't set the wallet as active
    const handleConnection = async (wallet, options) => {
        const account = wallet.getAccount();
        if (!account) {
            throw new Error("Cannot set a wallet without an account as active");
        }
        const activeWallet = await (async () => {
            if (options?.accountAbstraction && !(0, isSmartWallet_js_1.hasSmartAccount)(wallet)) {
                return await (0, exports.handleSmartWalletConnection)(wallet, options.client, options.accountAbstraction, onWalletDisconnect);
            }
            else {
                return wallet;
            }
        })();
        await storage.setItem(LAST_ACTIVE_EOA_ID, wallet.id);
        // add personal wallet to connected wallets list even if it's not the active one
        addConnectedWallet(wallet);
        if (options?.setWalletAsActive !== false) {
            handleSetActiveWallet(activeWallet);
        }
        wallet.subscribe("accountChanged", async () => {
            // We reimplement connect here to prevent memory leaks
            const newWallet = await handleConnection(wallet, options);
            options?.onConnect?.(newWallet);
        });
        return activeWallet;
    };
    const connect = async (wallet, options) => {
        // connectedWallet can be either wallet or smartWallet
        const connectedWallet = await handleConnection(wallet, options);
        options?.onConnect?.(connectedWallet);
        return connectedWallet;
    };
    const handleSetActiveWallet = (activeWallet) => {
        const account = activeWallet.getAccount();
        if (!account) {
            throw new Error("Cannot set a wallet without an account as active");
        }
        // also add it to connected wallets if it's not already there
        addConnectedWallet(activeWallet);
        // update active states
        activeWalletStore.setValue(activeWallet);
        activeAccountStore.setValue(account);
        activeWalletChainStore.setValue(activeWallet.getChain());
        activeWalletConnectionStatusStore.setValue("connected");
        // setup listeners
        const onAccountsChanged = (newAccount) => {
            activeAccountStore.setValue(newAccount);
        };
        const unsubAccounts = activeWallet.subscribe("accountChanged", onAccountsChanged);
        const unsubChainChanged = activeWallet.subscribe("chainChanged", (chain) => activeWalletChainStore.setValue(chain));
        const unsubDisconnect = activeWallet.subscribe("disconnect", () => {
            handleDisconnect();
        });
        const handleDisconnect = () => {
            onWalletDisconnect(activeWallet);
            unsubAccounts();
            unsubChainChanged();
            unsubDisconnect();
        };
    };
    const setActiveWallet = async (activeWallet) => {
        handleSetActiveWallet(activeWallet);
        // do not set smart wallet as last active EOA
        if (activeWallet.id !== "smart") {
            await storage.setItem(LAST_ACTIVE_EOA_ID, activeWallet.id);
        }
    };
    // side effects
    (0, effect_js_1.effect)(() => {
        const _chain = activeWalletChainStore.getValue();
        if (_chain) {
            storage.setItem(LAST_ACTIVE_CHAIN, (0, json_js_1.stringify)(_chain));
        }
        else {
            storage.removeItem(LAST_ACTIVE_CHAIN);
        }
    }, [activeWalletChainStore], false);
    // save last connected wallet ids to storage
    (0, effect_js_1.effect)(async () => {
        const prevAccounts = (await getStoredConnectedWalletIds(storage)) || [];
        const accounts = connectedWallets.getValue();
        const ids = accounts.map((acc) => acc?.id).filter((c) => !!c);
        storage.setItem(CONNECTED_WALLET_IDS, (0, json_js_1.stringify)(Array.from(new Set([...prevAccounts, ...ids]))));
    }, [connectedWallets], false);
    const switchActiveWalletChain = async (chain) => {
        const wallet = activeWalletStore.getValue();
        if (!wallet) {
            throw new Error("No active wallet found");
        }
        if (!wallet.switchChain) {
            throw new Error("Wallet does not support switching chains");
        }
        if ((0, index_js_1.isSmartWallet)(wallet)) {
            // also switch personal wallet
            const personalWalletId = await getStoredActiveWalletId(storage);
            if (personalWalletId) {
                const personalWallet = connectedWallets
                    .getValue()
                    .find((w) => w.id === personalWalletId);
                if (personalWallet) {
                    await personalWallet.switchChain(chain);
                    await wallet.switchChain(chain);
                    // reset the active wallet as switch chain recreates a new smart account
                    handleSetActiveWallet(wallet);
                    return;
                }
            }
            // If we couldn't find the personal wallet, just switch the smart wallet
            await wallet.switchChain(chain);
            handleSetActiveWallet(wallet);
        }
        else {
            await wallet.switchChain(chain);
        }
        // for wallets that dont implement events, just set it manually
        activeWalletChainStore.setValue(wallet.getChain());
    };
    function defineChains(chains) {
        const currentMapVal = definedChainsStore.getValue();
        // if all chains to be defined are already defined, no need to update the definedChains map
        const allChainsSame = chains.every((c) => {
            const definedChain = currentMapVal.get(c.id);
            // basically a deep equal check
            return (0, json_js_1.stringify)(definedChain) === (0, json_js_1.stringify)(c);
        });
        if (allChainsSame) {
            return;
        }
        const newMapVal = new Map(currentMapVal);
        for (const c of chains) {
            newMapVal.set(c.id, c);
        }
        definedChainsStore.setValue(newMapVal);
    }
    return {
        activeWalletStore,
        activeAccountStore,
        connectedWallets,
        addConnectedWallet,
        disconnectWallet,
        setActiveWallet,
        connect,
        handleConnection,
        activeWalletChainStore,
        switchActiveWalletChain,
        activeWalletConnectionStatusStore,
        isAutoConnecting,
        removeConnectedWallet,
        defineChains,
    };
}
/**
 *
 * @internal
 */
async function getStoredConnectedWalletIds(storage) {
    try {
        const value = await storage.getItem(CONNECTED_WALLET_IDS);
        if (value) {
            return JSON.parse(value);
        }
        return [];
    }
    catch {
        return [];
    }
}
/**
 * @internal
 */
async function getStoredActiveWalletId(storage) {
    try {
        const value = await storage.getItem(LAST_ACTIVE_EOA_ID);
        if (value) {
            return value;
        }
    }
    catch { }
    return null;
}
/**
 * @internal
 */
async function getLastConnectedChain(storage) {
    try {
        const value = await storage.getItem(LAST_ACTIVE_CHAIN);
        if (value) {
            return JSON.parse(value);
        }
    }
    catch { }
    return null;
}
/**
 * @internal
 */
const handleSmartWalletConnection = async (eoaWallet, client, options, onWalletDisconnect) => {
    const signer = eoaWallet.getAccount();
    if (!signer) {
        throw new Error("Cannot set a wallet without an account as active");
    }
    const wallet = (0, smart_wallet_js_1.smartWallet)(options);
    await wallet.connect({
        personalAccount: signer,
        client: client,
        chain: options.chain,
    });
    // Disconnect the active wallet when the EOA disconnects if it the active wallet is a smart wallet
    const disconnectUnsub = eoaWallet.subscribe("disconnect", () => {
        handleDisconnect();
    });
    const handleDisconnect = () => {
        disconnectUnsub();
        onWalletDisconnect(wallet);
    };
    return wallet;
};
exports.handleSmartWalletConnection = handleSmartWalletConnection;
//# sourceMappingURL=index.js.map