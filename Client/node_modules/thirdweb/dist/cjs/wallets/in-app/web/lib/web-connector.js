"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InAppWebConnector = void 0;
const domains_js_1 = require("../../../../utils/domains.js");
const webStorage_js_1 = require("../../../../utils/storage/webStorage.js");
const get_enclave_user_status_js_1 = require("../../core/actions/get-enclave-user-status.js");
const authEndpoint_js_1 = require("../../core/authentication/authEndpoint.js");
const backend_js_1 = require("../../core/authentication/backend.js");
const client_scoped_storage_js_1 = require("../../core/authentication/client-scoped-storage.js");
const guest_js_1 = require("../../core/authentication/guest.js");
const jwt_js_1 = require("../../core/authentication/jwt.js");
const linkAccount_js_1 = require("../../core/authentication/linkAccount.js");
const passkeys_js_1 = require("../../core/authentication/passkeys.js");
const siwe_js_1 = require("../../core/authentication/siwe.js");
const enclave_wallet_js_1 = require("../../core/wallet/enclave-wallet.js");
const InAppWalletIframeCommunicator_js_1 = require("../utils/iFrameCommunication/InAppWalletIframeCommunicator.js");
const iframe_auth_js_1 = require("./auth/iframe-auth.js");
const oauth_js_1 = require("./auth/oauth.js");
const otp_js_1 = require("./auth/otp.js");
const iframe_wallet_js_1 = require("./iframe-wallet.js");
/**
 * @internal
 */
class InAppWebConnector {
    isClientIdLegacyPaper(clientId) {
        if (clientId.indexOf("-") > 0 && clientId.length === 36) {
            return true;
        }
        return false;
    }
    /**
     * @example
     * `const thirdwebInAppWallet = new InAppWalletSdk({ clientId: "", chain: "Goerli" });`
     * @internal
     */
    constructor({ client, onAuthSuccess, ecosystem, passkeyDomain, storage, }) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "ecosystem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "querier", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "storage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "wallet", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Used to manage the Auth state of the user.
         */
        Object.defineProperty(this, "auth", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "passkeyDomain", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (this.isClientIdLegacyPaper(client.clientId)) {
            throw new Error("You are using a legacy clientId. Please use the clientId found on the thirdweb dashboard settings page");
        }
        const baseUrl = (0, domains_js_1.getThirdwebBaseUrl)("inAppWallet");
        this.client = client;
        this.ecosystem = ecosystem;
        this.passkeyDomain = passkeyDomain;
        this.storage = new client_scoped_storage_js_1.ClientScopedStorage({
            storage: storage ?? webStorage_js_1.webLocalStorage,
            clientId: client.clientId,
            ecosystem: ecosystem,
        });
        this.querier = new InAppWalletIframeCommunicator_js_1.InAppWalletIframeCommunicator({
            clientId: client.clientId,
            ecosystem,
            baseUrl,
        });
        this.auth = new iframe_auth_js_1.Auth({
            client,
            querier: this.querier,
            baseUrl,
            localStorage: this.storage,
            ecosystem,
            onAuthSuccess: async (authResult) => {
                onAuthSuccess?.(authResult);
                if (authResult.storedToken.authDetails.walletType === "sharded") {
                    // If this is an existing sharded ecosystem wallet, we'll need to migrate
                    const result = await this.querier.call({
                        procedureName: "migrateFromShardToEnclave",
                        params: {
                            storedToken: authResult.storedToken,
                        },
                    });
                    if (!result) {
                        console.warn("Failed to migrate from sharded to enclave wallet, continuing with sharded wallet");
                    }
                }
                this.wallet = await this.initializeWallet(authResult.storedToken.cookieString);
                if (!this.wallet) {
                    throw new Error("Failed to initialize wallet");
                }
                const deviceShareStored = "deviceShareStored" in authResult.walletDetails
                    ? authResult.walletDetails.deviceShareStored
                    : undefined;
                await this.wallet.postWalletSetUp({
                    storedToken: authResult.storedToken,
                    deviceShareStored,
                });
                if (this.wallet instanceof iframe_wallet_js_1.IFrameWallet) {
                    await this.querier.call({
                        procedureName: "initIframe",
                        params: {
                            partnerId: ecosystem?.partnerId,
                            ecosystemId: ecosystem?.id,
                            clientId: this.client.clientId,
                            // For enclave wallets we won't have a device share
                            deviceShareStored: "deviceShareStored" in authResult.walletDetails
                                ? authResult.walletDetails.deviceShareStored
                                : null,
                            walletUserId: authResult.storedToken.authDetails.userWalletId,
                            authCookie: authResult.storedToken.cookieString,
                        },
                    });
                }
                return {
                    user: {
                        status: "Logged In, Wallet Initialized",
                        authDetails: authResult.storedToken.authDetails,
                        account: await this.wallet.getAccount(),
                        walletAddress: authResult.walletDetails.walletAddress,
                    },
                };
            },
        });
    }
    async initializeWallet(authToken) {
        const storedAuthToken = await this.storage.getAuthCookie();
        if (!authToken && storedAuthToken === null) {
            throw new Error("No auth token provided and no stored auth token found to initialize the wallet");
        }
        const user = await (0, get_enclave_user_status_js_1.getUserStatus)({
            authToken: authToken || storedAuthToken,
            client: this.client,
            ecosystem: this.ecosystem,
        });
        if (!user) {
            throw new Error("Cannot initialize wallet, no user logged in");
        }
        if (user.wallets.length === 0) {
            throw new Error("Cannot initialize wallet, this user does not have a wallet generated yet");
        }
        if (user.wallets[0]?.type === "enclave") {
            return new enclave_wallet_js_1.EnclaveWallet({
                client: this.client,
                ecosystem: this.ecosystem,
                address: user.wallets[0].address,
                storage: this.storage,
            });
        }
        return new iframe_wallet_js_1.IFrameWallet({
            client: this.client,
            ecosystem: this.ecosystem,
            querier: this.querier,
            localStorage: this.storage,
        });
    }
    /**
     * Gets the user if they're logged in
     * @example
     * ```js
     *  const user = await thirdwebInAppWallet.getUser();
     *  switch (user.status) {
     *     case UserWalletStatus.LOGGED_OUT: {
     *       // User is logged out, call one of the auth methods on thirdwebInAppWallet.auth to authenticate the user
     *       break;
     *     }
     *     case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED: {
     *       // user is logged in and wallet is all set up.
     *       // You have access to:
     *       user.status;
     *       user.authDetails;
     *       user.walletAddress;
     *       user.wallet;
     *       break;
     *     }
     * }
     * ```
     * @returns GetUser - an object to containing various information on the user statuses
     */
    async getUser() {
        // If we don't have a wallet yet we'll create one
        if (!this.wallet) {
            const localAuthToken = await this.storage.getAuthCookie();
            if (!localAuthToken) {
                return { status: "Logged Out" };
            }
            this.wallet = await this.initializeWallet(localAuthToken);
        }
        if (!this.wallet) {
            throw new Error("Wallet not initialized");
        }
        return await this.wallet.getUserWalletStatus();
    }
    getAccount() {
        if (!this.wallet) {
            throw new Error("Wallet not initialized");
        }
        return this.wallet.getAccount();
    }
    async preAuthenticate(args) {
        return (0, otp_js_1.sendOtp)({
            ...args,
            client: this.client,
            ecosystem: this.ecosystem,
        });
    }
    async authenticateWithRedirect(strategy, mode, redirectUrl) {
        return (0, oauth_js_1.loginWithOauthRedirect)({
            authOption: strategy,
            client: this.client,
            ecosystem: this.ecosystem,
            redirectUrl,
            mode,
        });
    }
    async loginWithAuthToken(authResult, recoveryCode) {
        return this.auth.loginWithAuthToken(authResult, recoveryCode);
    }
    /**
     * Authenticates the user and returns the auth token, but does not instantiate their wallet
     */
    async authenticate(args) {
        const strategy = args.strategy;
        switch (strategy) {
            case "email":
                return (0, otp_js_1.verifyOtp)({
                    ...args,
                    client: this.client,
                    ecosystem: this.ecosystem,
                });
            case "phone":
                return (0, otp_js_1.verifyOtp)({
                    ...args,
                    client: this.client,
                    ecosystem: this.ecosystem,
                });
            case "auth_endpoint": {
                return (0, authEndpoint_js_1.authEndpoint)({
                    payload: args.payload,
                    client: this.client,
                    ecosystem: this.ecosystem,
                });
            }
            case "jwt":
                return (0, jwt_js_1.customJwt)({
                    jwt: args.jwt,
                    client: this.client,
                    ecosystem: this.ecosystem,
                });
            case "passkey": {
                return this.passkeyAuth(args);
            }
            case "iframe_email_verification": {
                return this.auth.authenticateWithIframe({
                    email: args.email,
                });
            }
            case "iframe": {
                return this.auth.authenticateWithModal();
            }
            case "apple":
            case "facebook":
            case "google":
            case "telegram":
            case "github":
            case "twitch":
            case "farcaster":
            case "line":
            case "x":
            case "steam":
            case "coinbase":
            case "discord": {
                return (0, oauth_js_1.loginWithOauth)({
                    authOption: strategy,
                    client: this.client,
                    ecosystem: this.ecosystem,
                    closeOpenedWindow: args.closeOpenedWindow,
                    openedWindow: args.openedWindow,
                });
            }
            case "guest": {
                return (0, guest_js_1.guestAuthenticate)({
                    client: this.client,
                    ecosystem: this.ecosystem,
                    storage: webStorage_js_1.webLocalStorage,
                });
            }
            case "backend": {
                return (0, backend_js_1.backendAuthenticate)({
                    client: this.client,
                    walletSecret: args.walletSecret,
                    ecosystem: this.ecosystem,
                });
            }
            case "wallet": {
                return (0, siwe_js_1.siweAuthenticate)({
                    ecosystem: this.ecosystem,
                    client: this.client,
                    wallet: args.wallet,
                    chain: args.chain,
                });
            }
        }
    }
    /**
     * Authenticates the user then instantiates their wallet using the resulting auth token
     */
    async connect(args) {
        const strategy = args.strategy;
        switch (strategy) {
            case "auth_endpoint":
            case "jwt": {
                const authToken = await this.authenticate(args);
                return await this.loginWithAuthToken(authToken, args.encryptionKey);
            }
            case "iframe_email_verification": {
                return this.auth.loginWithIframe({
                    email: args.email,
                });
            }
            case "iframe": {
                return this.auth.loginWithModal();
            }
            case "passkey": {
                const authToken = await this.passkeyAuth(args);
                return this.loginWithAuthToken(authToken);
            }
            case "backend":
            case "phone":
            case "email":
            case "wallet":
            case "apple":
            case "facebook":
            case "google":
            case "farcaster":
            case "telegram":
            case "github":
            case "line":
            case "x":
            case "guest":
            case "coinbase":
            case "twitch":
            case "steam":
            case "discord": {
                const authToken = await this.authenticate(args);
                return await this.auth.loginWithAuthToken(authToken);
            }
            default:
                assertUnreachable(strategy);
        }
    }
    async logout() {
        return await this.auth.logout();
    }
    async passkeyAuth(args) {
        const { PasskeyWebClient } = await Promise.resolve().then(() => require("./auth/passkeys.js"));
        const { passkeyName, storeLastUsedPasskey = true } = args;
        const passkeyClient = new PasskeyWebClient();
        const storage = this.storage;
        if (args.type === "sign-up") {
            return (0, passkeys_js_1.registerPasskey)({
                client: this.client,
                ecosystem: this.ecosystem,
                username: passkeyName,
                passkeyClient,
                storage: storeLastUsedPasskey ? storage : undefined,
                rp: {
                    id: this.passkeyDomain ?? window.location.hostname,
                    name: this.passkeyDomain ?? window.document.title,
                },
            });
        }
        return (0, passkeys_js_1.loginWithPasskey)({
            client: this.client,
            ecosystem: this.ecosystem,
            passkeyClient,
            storage: storeLastUsedPasskey ? storage : undefined,
            rp: {
                id: this.passkeyDomain ?? window.location.hostname,
                name: this.passkeyDomain ?? window.document.title,
            },
        });
    }
    async linkProfile(args) {
        const { storedToken } = await this.authenticate(args);
        return await (0, linkAccount_js_1.linkAccount)({
            client: args.client,
            tokenToLink: storedToken.cookieString,
            storage: this.storage,
            ecosystem: args.ecosystem || this.ecosystem,
        });
    }
    async unlinkProfile(profile) {
        return await (0, linkAccount_js_1.unlinkAccount)({
            client: this.client,
            storage: this.storage,
            ecosystem: this.ecosystem,
            profileToUnlink: profile,
        });
    }
    async getProfiles() {
        return (0, linkAccount_js_1.getLinkedProfilesInternal)({
            client: this.client,
            ecosystem: this.ecosystem,
            storage: this.storage,
        });
    }
}
exports.InAppWebConnector = InAppWebConnector;
function assertUnreachable(x, message) {
    throw new Error(message ?? `Invalid param: ${x}`);
}
//# sourceMappingURL=web-connector.js.map