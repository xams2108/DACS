"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.smartAccountSignMessage = smartAccountSignMessage;
exports.smartAccountSignTypedData = smartAccountSignTypedData;
exports.confirmContractDeployment = confirmContractDeployment;
exports.deploySmartAccount = deploySmartAccount;
const serialize_erc6492_signature_js_1 = require("../../../auth/serialize-erc6492-signature.js");
const verify_hash_js_1 = require("../../../auth/verify-hash.js");
const contract_js_1 = require("../../../contract/contract.js");
const encode_js_1 = require("../../../transaction/actions/encode.js");
const read_contract_js_1 = require("../../../transaction/read-contract.js");
const encodeAbiParameters_js_1 = require("../../../utils/abi/encodeAbiParameters.js");
const is_contract_deployed_js_1 = require("../../../utils/bytecode/is-contract-deployed.js");
const hashMessage_js_1 = require("../../../utils/hashing/hashMessage.js");
const hashTypedData_js_1 = require("../../../utils/hashing/hashTypedData.js");
const calls_js_1 = require("./calls.js");
/**
 * If the account is already deployed, generate an ERC-1271 signature.
 * If the account is not deployed, generate an ERC-6492 signature unless otherwise specified.
 *
 * @internal
 */
async function smartAccountSignMessage({ accountContract, factoryContract, options, message, }) {
    const originalMsgHash = (0, hashMessage_js_1.hashMessage)(message);
    const is712Factory = await checkFor712Factory({
        factoryContract,
        accountContract,
        originalMsgHash,
    });
    let sig;
    if (is712Factory) {
        const wrappedMessageHash = (0, encodeAbiParameters_js_1.encodeAbiParameters)([{ type: "bytes32" }], [originalMsgHash]);
        sig = await options.personalAccount.signTypedData({
            domain: {
                name: "Account",
                version: "1",
                chainId: options.chain.id,
                verifyingContract: accountContract.address,
            },
            primaryType: "AccountMessage",
            types: { AccountMessage: [{ name: "message", type: "bytes" }] },
            message: { message: wrappedMessageHash },
        });
    }
    else {
        sig = await options.personalAccount.signMessage({ message });
    }
    const isDeployed = await (0, is_contract_deployed_js_1.isContractDeployed)(accountContract);
    if (isDeployed) {
        const isValid = await (0, verify_hash_js_1.verifyEip1271Signature)({
            hash: originalMsgHash,
            signature: sig,
            contract: accountContract,
        });
        if (isValid) {
            return sig;
        }
        throw new Error("Failed to verify signature");
    }
    else {
        const deployTx = (0, calls_js_1.prepareCreateAccount)({
            factoryContract,
            adminAddress: options.personalAccount.address,
            accountSalt: options.overrides?.accountSalt,
            createAccountOverride: options.overrides?.createAccount,
        });
        if (!deployTx) {
            throw new Error("Create account override not provided");
        }
        const initCode = await (0, encode_js_1.encode)(deployTx);
        const erc6492Sig = (0, serialize_erc6492_signature_js_1.serializeErc6492Signature)({
            address: factoryContract.address,
            data: initCode,
            signature: sig,
        });
        // check if the signature is valid
        const isValid = await (0, verify_hash_js_1.verifyHash)({
            hash: originalMsgHash,
            signature: erc6492Sig,
            address: accountContract.address,
            chain: accountContract.chain,
            client: accountContract.client,
        });
        if (isValid) {
            return erc6492Sig;
        }
        throw new Error("Unable to verify ERC-6492 signature after signing.");
    }
}
async function smartAccountSignTypedData({ accountContract, factoryContract, options, typedData, }) {
    const isSelfVerifyingContract = typedData.domain?.verifyingContract?.toLowerCase() ===
        accountContract.address?.toLowerCase();
    if (isSelfVerifyingContract) {
        // if the contract is self-verifying, we can just sign the message with the EOA (ie. adding a session key)
        return options.personalAccount.signTypedData(typedData);
    }
    const originalMsgHash = (0, hashTypedData_js_1.hashTypedData)(typedData);
    // check if the account contract supports EIP721 domain separator based signing
    const is712Factory = await checkFor712Factory({
        factoryContract,
        accountContract,
        originalMsgHash,
    });
    let sig;
    if (is712Factory) {
        const wrappedMessageHash = (0, encodeAbiParameters_js_1.encodeAbiParameters)([{ type: "bytes32" }], [originalMsgHash]);
        sig = await options.personalAccount.signTypedData({
            domain: {
                name: "Account",
                version: "1",
                chainId: options.chain.id,
                verifyingContract: accountContract.address,
            },
            primaryType: "AccountMessage",
            types: { AccountMessage: [{ name: "message", type: "bytes" }] },
            message: { message: wrappedMessageHash },
        });
    }
    else {
        sig = await options.personalAccount.signTypedData(typedData);
    }
    const isDeployed = await (0, is_contract_deployed_js_1.isContractDeployed)(accountContract);
    if (isDeployed) {
        const isValid = await (0, verify_hash_js_1.verifyEip1271Signature)({
            hash: originalMsgHash,
            signature: sig,
            contract: accountContract,
        });
        if (isValid) {
            return sig;
        }
        throw new Error("Failed to verify signature");
    }
    else {
        const deployTx = (0, calls_js_1.prepareCreateAccount)({
            factoryContract,
            adminAddress: options.personalAccount.address,
            accountSalt: options.overrides?.accountSalt,
            createAccountOverride: options.overrides?.createAccount,
        });
        if (!deployTx) {
            throw new Error("Create account override not provided");
        }
        const initCode = await (0, encode_js_1.encode)(deployTx);
        const erc6492Sig = (0, serialize_erc6492_signature_js_1.serializeErc6492Signature)({
            address: factoryContract.address,
            data: initCode,
            signature: sig,
        });
        // check if the signature is valid
        const isValid = await (0, verify_hash_js_1.verifyHash)({
            hash: originalMsgHash,
            signature: erc6492Sig,
            address: accountContract.address,
            chain: accountContract.chain,
            client: accountContract.client,
        });
        if (isValid) {
            return erc6492Sig;
        }
        throw new Error("Unable to verify signature on smart account, please make sure the admin wallet has permissions and the signature is valid.");
    }
}
async function confirmContractDeployment(args) {
    const { accountContract } = args;
    const startTime = Date.now();
    const timeout = 60000; // wait 1 minute max
    const { isContractDeployed } = await Promise.resolve().then(() => require("../../../utils/bytecode/is-contract-deployed.js"));
    let isDeployed = await isContractDeployed(accountContract);
    while (!isDeployed) {
        if (Date.now() - startTime > timeout) {
            throw new Error("Timeout: Smart account deployment not confirmed after 1 minute");
        }
        await new Promise((resolve) => setTimeout(resolve, 500));
        isDeployed = await isContractDeployed(accountContract);
    }
}
async function checkFor712Factory({ factoryContract, accountContract, originalMsgHash, }) {
    try {
        const implementationAccount = await (0, read_contract_js_1.readContract)({
            contract: factoryContract,
            method: "function accountImplementation() public view returns (address)",
        });
        // check if the account contract supports EIP721 domain separator or modular based signing
        const is712Factory = await (0, read_contract_js_1.readContract)({
            contract: (0, contract_js_1.getContract)({
                address: implementationAccount,
                chain: accountContract.chain,
                client: accountContract.client,
            }),
            method: "function getMessageHash(bytes32 _hash) public view returns (bytes32)",
            params: [originalMsgHash],
        })
            .then((res) => res !== "0x")
            .catch(() => false);
        return is712Factory;
    }
    catch {
        return false;
    }
}
/**
 * Deployes a smart account via a dummy transaction. If the account is already deployed, this will do nothing.
 *
 * @param args - Arguments for the deployment.
 * @param args.smartAccount - The smart account to deploy.
 * @param args.chain - The chain to deploy on.
 * @param args.client - The client to use for the deployment.
 * @param args.accountContract - The account contract to deploy.
 *
 * @example
 * ```ts
 * import { deploySmartAccount } from "thirdweb";
 *
 * const account = await deploySmartAccount({
 *   smartAccount,
 *   chain,
 *   client,
 *   accountContract,
 * });
 * ```
 *
 * @wallet
 */
async function deploySmartAccount(args) {
    const { chain, client, smartAccount, accountContract } = args;
    const isDeployed = await (0, is_contract_deployed_js_1.isContractDeployed)(accountContract);
    if (isDeployed) {
        return;
    }
    const [{ sendTransaction }, { prepareTransaction }] = await Promise.all([
        Promise.resolve().then(() => require("../../../transaction/actions/send-transaction.js")),
        Promise.resolve().then(() => require("../../../transaction/prepare-transaction.js")),
    ]);
    const dummyTx = prepareTransaction({
        client: client,
        chain: chain,
        to: accountContract.address,
        value: 0n,
        gas: 50000n, // force gas to avoid simulation error
    });
    const deployResult = await sendTransaction({
        transaction: dummyTx,
        account: smartAccount,
    });
    await confirmContractDeployment({
        accountContract,
    });
    return deployResult;
}
//# sourceMappingURL=signing.js.map