"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.clearAccountDeploying = void 0;
exports.waitForUserOpReceipt = waitForUserOpReceipt;
exports.createUnsignedUserOp = createUnsignedUserOp;
exports.signUserOp = signUserOp;
exports.getUserOpHash = getUserOpHash;
exports.createAndSignUserOp = createAndSignUserOp;
exports.prepareUserOp = prepareUserOp;
const Solidity_1 = require("ox/Solidity");
const viem_1 = require("viem");
const contract_js_1 = require("../../../contract/contract.js");
const getNonce_js_1 = require("../../../extensions/erc4337/__generated__/IEntryPoint/read/getNonce.js");
const getUserOpHash_js_1 = require("../../../extensions/erc4337/__generated__/IEntryPoint/read/getUserOpHash.js");
const getUserOpHash_js_2 = require("../../../extensions/erc4337/__generated__/IEntryPoint_v07/read/getUserOpHash.js");
const fee_data_js_1 = require("../../../gas/fee-data.js");
const encode_js_1 = require("../../../transaction/actions/encode.js");
const to_serializable_transaction_js_1 = require("../../../transaction/actions/to-serializable-transaction.js");
const encodeAbiParameters_js_1 = require("../../../utils/abi/encodeAbiParameters.js");
const is_contract_deployed_js_1 = require("../../../utils/bytecode/is-contract-deployed.js");
const hex_js_1 = require("../../../utils/encoding/hex.js");
const to_bytes_js_1 = require("../../../utils/encoding/to-bytes.js");
const fetch_js_1 = require("../../../utils/fetch.js");
const keccak256_js_1 = require("../../../utils/hashing/keccak256.js");
const json_js_1 = require("../../../utils/json.js");
const resolve_promised_value_js_1 = require("../../../utils/promise/resolve-promised-value.js");
const index_js_1 = require("../index.js");
const bundler_js_1 = require("./bundler.js");
const calls_js_1 = require("./calls.js");
const constants_js_1 = require("./constants.js");
const packUserOp_js_1 = require("./packUserOp.js");
const paymaster_js_1 = require("./paymaster.js");
const utils_js_1 = require("./utils.js");
const isDeployingSet = new Set();
const getKey = (accountContract) => {
    return `${accountContract.chain.id}:${accountContract.address}`;
};
const markAccountDeploying = (accountContract) => {
    isDeployingSet.add(getKey(accountContract));
};
const clearAccountDeploying = (accountContract) => {
    isDeployingSet.delete(getKey(accountContract));
};
exports.clearAccountDeploying = clearAccountDeploying;
const isAccountDeploying = (accountContract) => {
    return isDeployingSet.has(getKey(accountContract));
};
/**
 * Wait for the user operation to be mined.
 * @param args - The options and user operation hash
 * @returns - The transaction receipt
 *
 * @example
 * ```ts
 * import { waitForUserOpReceipt } from "thirdweb/wallets/smart";
 *
 * const receipt = await waitForUserOpReceipt({
 *  chain,
 *  client,
 *  userOpHash,
 * });
 * ```
 * @walletUtils
 */
async function waitForUserOpReceipt(args) {
    const timeout = args.timeoutMs || 120000; // 2mins
    const interval = args.intervalMs || 1000; // 1s
    const endtime = Date.now() + timeout;
    while (Date.now() < endtime) {
        const userOpReceipt = await (0, bundler_js_1.getUserOpReceipt)(args);
        if (userOpReceipt) {
            return userOpReceipt;
        }
        await new Promise((resolve) => setTimeout(resolve, interval));
    }
    throw new Error(`Timeout waiting for userOp to be mined on chain ${args.chain.id} with UserOp hash: ${args.userOpHash}`);
}
/**
 * Creates an unsigned user operation from a prepared transaction.
 * @param args - The prepared transaction and options
 * @returns - The unsigned user operation
 * @example
 * ```ts
 * import { createUnsignedUserOp } from "thirdweb/wallets/smart";
 *
 * const transaction = prepareContractCall(...);
 *
 * const userOp = await createUnsignedUserOp({
 *  transaction,
 *  factoryContract,
 *  accountContract,
 *  adminAddress,
 *  sponsorGas,
 *  overrides,
 * });
 * ```
 * @walletUtils
 */
async function createUnsignedUserOp(args) {
    const { transaction: executeTx, accountContract, factoryContract, adminAddress, overrides, sponsorGas, waitForDeployment = true, isDeployedOverride, } = args;
    const chain = executeTx.chain;
    const client = executeTx.client;
    const bundlerOptions = {
        client,
        chain,
        bundlerUrl: overrides?.bundlerUrl,
        entrypointAddress: overrides?.entrypointAddress,
    };
    const entrypointVersion = (0, constants_js_1.getEntryPointVersion)(args.overrides?.entrypointAddress || constants_js_1.ENTRYPOINT_ADDRESS_v0_6);
    const [isDeployed, callData, callGasLimit, gasFees, nonce] = await Promise.all([
        typeof isDeployedOverride === "boolean"
            ? isDeployedOverride
            : (0, is_contract_deployed_js_1.isContractDeployed)(accountContract).then((isDeployed) => isDeployed || isAccountDeploying(accountContract)),
        (0, encode_js_1.encode)(executeTx),
        (0, resolve_promised_value_js_1.resolvePromisedValue)(executeTx.gas),
        getGasFees({
            executeTx,
            bundlerOptions,
            chain,
            client,
        }),
        getAccountNonce({
            accountContract,
            chain,
            client,
            entrypointAddress: overrides?.entrypointAddress,
            getNonceOverride: overrides?.getAccountNonce,
        }),
    ]);
    const { maxFeePerGas, maxPriorityFeePerGas } = gasFees;
    if (entrypointVersion === "v0.7") {
        return populateUserOp_v0_7({
            bundlerOptions,
            factoryContract,
            accountContract,
            adminAddress,
            sponsorGas,
            overrides,
            isDeployed,
            nonce,
            callData,
            callGasLimit,
            maxFeePerGas,
            maxPriorityFeePerGas,
            waitForDeployment,
        });
    }
    // default to v0.6
    return populateUserOp_v0_6({
        bundlerOptions,
        factoryContract,
        accountContract,
        adminAddress,
        sponsorGas,
        overrides,
        isDeployed,
        nonce,
        callData,
        callGasLimit,
        maxFeePerGas,
        maxPriorityFeePerGas,
        waitForDeployment,
    });
}
async function getGasFees(args) {
    const { executeTx, bundlerOptions, chain, client } = args;
    let { maxFeePerGas, maxPriorityFeePerGas } = executeTx;
    const bundlerUrl = bundlerOptions?.bundlerUrl ?? (0, constants_js_1.getDefaultBundlerUrl)(chain);
    if ((0, fetch_js_1.isThirdwebUrl)(bundlerUrl)) {
        // get gas prices from bundler
        const bundlerGasPrice = await (0, bundler_js_1.getUserOpGasFees)({
            options: bundlerOptions,
        });
        maxFeePerGas = bundlerGasPrice.maxFeePerGas;
        maxPriorityFeePerGas = bundlerGasPrice.maxPriorityFeePerGas;
    }
    else {
        // Check for explicity values
        const [resolvedMaxFeePerGas, resolvedMaxPriorityFeePerGas] = await Promise.all([
            (0, resolve_promised_value_js_1.resolvePromisedValue)(maxFeePerGas),
            (0, resolve_promised_value_js_1.resolvePromisedValue)(maxPriorityFeePerGas),
        ]);
        if (resolvedMaxFeePerGas && resolvedMaxPriorityFeePerGas) {
            // Save a network call if the values are provided
            maxFeePerGas = resolvedMaxFeePerGas;
            maxPriorityFeePerGas = resolvedMaxPriorityFeePerGas;
        }
        else {
            // Fallback to RPC gas prices if no explicit values provided
            const feeData = await (0, fee_data_js_1.getDefaultGasOverrides)(client, chain);
            // Still check for explicit values in case one is provided and not the other
            maxPriorityFeePerGas =
                resolvedMaxPriorityFeePerGas ?? feeData.maxPriorityFeePerGas ?? 0n;
            maxFeePerGas = resolvedMaxFeePerGas ?? feeData.maxFeePerGas ?? 0n;
        }
    }
    return { maxFeePerGas, maxPriorityFeePerGas };
}
async function populateUserOp_v0_7(args) {
    const { bundlerOptions, isDeployed, factoryContract, accountContract, adminAddress, sponsorGas, overrides, nonce, callData, callGasLimit, maxFeePerGas, maxPriorityFeePerGas, waitForDeployment, } = args;
    const { chain, client } = bundlerOptions;
    let factory;
    let factoryData;
    if (isDeployed) {
        factoryData = "0x";
        if (waitForDeployment) {
            // lock until account is deployed if needed to avoid 'sender already created' errors when sending multiple transactions in parallel
            await waitForAccountDeployed(accountContract);
        }
    }
    else {
        factory = factoryContract.address;
        factoryData = await (0, encode_js_1.encode)((0, calls_js_1.prepareCreateAccount)({
            factoryContract: factoryContract,
            adminAddress,
            accountSalt: overrides?.accountSalt,
            createAccountOverride: overrides?.createAccount,
        }));
        if (waitForDeployment) {
            markAccountDeploying(accountContract);
        }
    }
    const partialOp = {
        sender: accountContract.address,
        nonce,
        callData,
        maxFeePerGas,
        maxPriorityFeePerGas,
        callGasLimit: callGasLimit ?? 0n,
        verificationGasLimit: 0n,
        preVerificationGas: 0n,
        factory,
        factoryData,
        paymaster: undefined,
        paymasterData: "0x",
        paymasterVerificationGasLimit: 0n,
        paymasterPostOpGasLimit: 0n,
        signature: constants_js_1.DUMMY_SIGNATURE,
    };
    if (sponsorGas) {
        const paymasterResult = (await (0, paymaster_js_1.getPaymasterAndData)({
            userOp: partialOp,
            chain,
            client,
            entrypointAddress: overrides?.entrypointAddress,
            paymasterOverride: overrides?.paymaster,
        }));
        if (paymasterResult.paymaster && paymasterResult.paymasterData) {
            partialOp.paymaster = paymasterResult.paymaster;
            partialOp.paymasterData = paymasterResult.paymasterData;
        }
        // paymaster can have the gas limits in the response
        if (paymasterResult.callGasLimit &&
            paymasterResult.verificationGasLimit &&
            paymasterResult.preVerificationGas &&
            paymasterResult.paymasterPostOpGasLimit &&
            paymasterResult.paymasterVerificationGasLimit) {
            partialOp.callGasLimit = paymasterResult.callGasLimit;
            partialOp.verificationGasLimit = paymasterResult.verificationGasLimit;
            partialOp.preVerificationGas = paymasterResult.preVerificationGas;
            partialOp.paymasterPostOpGasLimit =
                paymasterResult.paymasterPostOpGasLimit;
            partialOp.paymasterVerificationGasLimit =
                paymasterResult.paymasterVerificationGasLimit;
        }
        else {
            // otherwise fallback to bundler for gas limits
            const stateOverrides = overrides?.tokenPaymaster
                ? {
                    [overrides.tokenPaymaster.tokenAddress]: {
                        stateDiff: {
                            [(0, keccak256_js_1.keccak256)((0, encodeAbiParameters_js_1.encodeAbiParameters)([{ type: "address" }, { type: "uint256" }], [
                                accountContract.address,
                                overrides.tokenPaymaster.balanceStorageSlot,
                            ]))]: (0, hex_js_1.toHex)(Solidity_1.maxUint96, { size: 32 }),
                        },
                    },
                }
                : undefined;
            const estimates = await (0, bundler_js_1.estimateUserOpGas)({
                userOp: partialOp,
                options: bundlerOptions,
            }, stateOverrides);
            partialOp.callGasLimit = estimates.callGasLimit;
            partialOp.verificationGasLimit = estimates.verificationGasLimit;
            partialOp.preVerificationGas = estimates.preVerificationGas;
            partialOp.paymasterPostOpGasLimit = overrides?.tokenPaymaster
                ? 500000n // TODO: estimate this better, needed if there's an extra swap needed in the paymaster
                : estimates.paymasterPostOpGasLimit || 0n;
            partialOp.paymasterVerificationGasLimit =
                estimates.paymasterVerificationGasLimit || 0n;
            // need paymaster to re-sign after estimates
            const paymasterResult2 = (await (0, paymaster_js_1.getPaymasterAndData)({
                userOp: partialOp,
                chain,
                client,
                entrypointAddress: overrides?.entrypointAddress,
                paymasterOverride: overrides?.paymaster,
            }));
            if (paymasterResult2.paymaster && paymasterResult2.paymasterData) {
                partialOp.paymaster = paymasterResult2.paymaster;
                partialOp.paymasterData = paymasterResult2.paymasterData;
            }
        }
    }
    else {
        // not gasless, so we just need to estimate gas limits
        const estimates = await (0, bundler_js_1.estimateUserOpGas)({
            userOp: partialOp,
            options: bundlerOptions,
        });
        partialOp.callGasLimit = estimates.callGasLimit;
        partialOp.verificationGasLimit = estimates.verificationGasLimit;
        partialOp.preVerificationGas = estimates.preVerificationGas;
        partialOp.paymasterPostOpGasLimit = estimates.paymasterPostOpGasLimit || 0n;
        partialOp.paymasterVerificationGasLimit =
            estimates.paymasterVerificationGasLimit || 0n;
    }
    return {
        ...partialOp,
        signature: "0x",
    };
}
async function populateUserOp_v0_6(args) {
    const { bundlerOptions, isDeployed, factoryContract, accountContract, adminAddress, sponsorGas, overrides, nonce, callData, callGasLimit, maxFeePerGas, maxPriorityFeePerGas, waitForDeployment, } = args;
    const { chain, client } = bundlerOptions;
    let initCode;
    if (isDeployed) {
        initCode = "0x";
        if (waitForDeployment) {
            // lock until account is deployed if needed to avoid 'sender already created' errors when sending multiple transactions in parallel
            await waitForAccountDeployed(accountContract);
        }
    }
    else {
        initCode = await getAccountInitCode({
            factoryContract: factoryContract,
            adminAddress,
            accountSalt: overrides?.accountSalt,
            createAccountOverride: overrides?.createAccount,
        });
        if (waitForDeployment) {
            markAccountDeploying(accountContract);
        }
    }
    const partialOp = {
        sender: accountContract.address,
        nonce,
        initCode,
        callData,
        maxFeePerGas,
        maxPriorityFeePerGas,
        callGasLimit: callGasLimit ?? 0n,
        verificationGasLimit: 0n,
        preVerificationGas: 0n,
        paymasterAndData: "0x",
        signature: constants_js_1.DUMMY_SIGNATURE,
    };
    if (sponsorGas) {
        const paymasterResult = await (0, paymaster_js_1.getPaymasterAndData)({
            userOp: partialOp,
            chain,
            client,
            entrypointAddress: overrides?.entrypointAddress,
            paymasterOverride: overrides?.paymaster,
        });
        const paymasterAndData = "paymasterAndData" in paymasterResult
            ? paymasterResult.paymasterAndData
            : "0x";
        if (paymasterAndData && paymasterAndData !== "0x") {
            partialOp.paymasterAndData = paymasterAndData;
        }
        // paymaster can have the gas limits in the response
        if (paymasterResult.callGasLimit &&
            paymasterResult.verificationGasLimit &&
            paymasterResult.preVerificationGas) {
            partialOp.callGasLimit = paymasterResult.callGasLimit;
            partialOp.verificationGasLimit = paymasterResult.verificationGasLimit;
            partialOp.preVerificationGas = paymasterResult.preVerificationGas;
        }
        else {
            // otherwise fallback to bundler for gas limits
            const estimates = await (0, bundler_js_1.estimateUserOpGas)({
                userOp: partialOp,
                options: bundlerOptions,
            });
            partialOp.callGasLimit = estimates.callGasLimit;
            partialOp.verificationGasLimit = estimates.verificationGasLimit;
            partialOp.preVerificationGas = estimates.preVerificationGas;
            // need paymaster to re-sign after estimates
            if (paymasterAndData && paymasterAndData !== "0x") {
                const paymasterResult2 = await (0, paymaster_js_1.getPaymasterAndData)({
                    userOp: partialOp,
                    chain,
                    client,
                    entrypointAddress: overrides?.entrypointAddress,
                    paymasterOverride: overrides?.paymaster,
                });
                const paymasterAndData2 = "paymasterAndData" in paymasterResult2
                    ? paymasterResult2.paymasterAndData
                    : "0x";
                if (paymasterAndData2 && paymasterAndData2 !== "0x") {
                    partialOp.paymasterAndData = paymasterAndData2;
                }
            }
        }
    }
    else {
        // not gasless, so we just need to estimate gas limits
        const estimates = await (0, bundler_js_1.estimateUserOpGas)({
            userOp: partialOp,
            options: bundlerOptions,
        });
        partialOp.callGasLimit = estimates.callGasLimit;
        partialOp.verificationGasLimit = estimates.verificationGasLimit;
        partialOp.preVerificationGas = estimates.preVerificationGas;
    }
    return {
        ...partialOp,
        signature: "0x",
    };
}
/**
 * Sign a user operation.
 * @param userOp - The UserOperation to sign (with signature field ignored)
 * @returns - The user operation with the signature field populated
 * @example
 * ```ts
 * import { signUserOp } from "thirdweb/wallets/smart";
 *
 * const userOp = await createUnsignedUserOp(...);
 *
 * const signedUserOp = await signUserOp({
 *  client,
 *  userOp,
 *  chain,
 *  adminAccount,
 * });
 * ```
 * @walletUtils
 */
async function signUserOp(args) {
    const { userOp, chain, entrypointAddress, adminAccount } = args;
    const userOpHash = await getUserOpHash({
        client: args.client,
        userOp,
        chain,
        entrypointAddress,
    });
    if (adminAccount.signMessage) {
        const signature = await adminAccount.signMessage({
            message: {
                raw: (0, to_bytes_js_1.hexToBytes)(userOpHash),
            },
            originalMessage: (0, json_js_1.stringify)(userOp),
            chainId: chain.id,
        });
        return {
            ...userOp,
            signature,
        };
    }
    throw new Error("signMessage not implemented in signingAccount");
}
/**
 * Get the hash of a user operation.
 * @param args - The options for getting the user operation hash
 * @returns - The user operation hash
 * @example
 * ```ts
 * import { getUserOpHash } from "thirdweb/wallets/smart";
 *
 * const userOp = await createUnsignedUserOp(...);
 * const userOpHash = await getUserOpHash({
 *  client,
 *  userOp,
 *  chain,
 * });
 * ```
 * @walletUtils
 */
async function getUserOpHash(args) {
    const { userOp, chain, entrypointAddress } = args;
    const entrypointVersion = (0, constants_js_1.getEntryPointVersion)(entrypointAddress || constants_js_1.ENTRYPOINT_ADDRESS_v0_6);
    let userOpHash;
    if (entrypointVersion === "v0.7") {
        const packedUserOp = (0, packUserOp_js_1.getPackedUserOperation)(userOp);
        userOpHash = await (0, getUserOpHash_js_2.getUserOpHash)({
            contract: (0, contract_js_1.getContract)({
                address: entrypointAddress || constants_js_1.ENTRYPOINT_ADDRESS_v0_7,
                chain,
                client: args.client,
            }),
            userOp: packedUserOp,
        });
    }
    else {
        userOpHash = await (0, getUserOpHash_js_1.getUserOpHash)({
            contract: (0, contract_js_1.getContract)({
                address: entrypointAddress || constants_js_1.ENTRYPOINT_ADDRESS_v0_6,
                chain,
                client: args.client,
            }),
            userOp: userOp,
        });
    }
    return userOpHash;
}
async function getAccountInitCode(options) {
    const { factoryContract, adminAddress, accountSalt, createAccountOverride } = options;
    const deployTx = (0, calls_js_1.prepareCreateAccount)({
        factoryContract,
        adminAddress,
        accountSalt,
        createAccountOverride,
    });
    return (0, viem_1.concat)([factoryContract.address, await (0, encode_js_1.encode)(deployTx)]);
}
async function getAccountNonce(options) {
    const { accountContract, chain, client, entrypointAddress, getNonceOverride, } = options;
    if (getNonceOverride) {
        return getNonceOverride(accountContract);
    }
    return await (0, getNonce_js_1.getNonce)({
        contract: (0, contract_js_1.getContract)({
            address: entrypointAddress || constants_js_1.ENTRYPOINT_ADDRESS_v0_6,
            chain,
            client,
        }),
        key: (0, utils_js_1.generateRandomUint192)(),
        sender: accountContract.address,
    });
}
/**
 * Create and sign a user operation.
 * @param options - The options for creating and signing the user operation
 * @returns - The signed user operation
 * @example
 * ```ts
 * import { createAndSignUserOp } from "thirdweb/wallets/smart";
 *
 * const userOp = await createAndSignUserOp({
 *  client,
 *  adminAccount,
 *  smartWalletOptions,
 *  transactions,
 * });
 * ```
 * @walletUtils
 */
async function createAndSignUserOp(options) {
    // if factory is passed, but no entrypoint, try to resolve entrypoint from factory
    if (options.smartWalletOptions.factoryAddress &&
        !options.smartWalletOptions.overrides?.entrypointAddress) {
        const entrypointAddress = await (0, index_js_1.getEntrypointFromFactory)(options.smartWalletOptions.factoryAddress, options.client, options.smartWalletOptions.chain);
        if (entrypointAddress) {
            options.smartWalletOptions.overrides = {
                ...options.smartWalletOptions.overrides,
                entrypointAddress,
            };
        }
    }
    const unsignedUserOp = await prepareUserOp({
        transactions: options.transactions,
        adminAccount: options.adminAccount,
        client: options.client,
        smartWalletOptions: options.smartWalletOptions,
        waitForDeployment: options.waitForDeployment,
        isDeployedOverride: options.isDeployedOverride,
    });
    const signedUserOp = await signUserOp({
        client: options.client,
        chain: options.smartWalletOptions.chain,
        adminAccount: options.adminAccount,
        entrypointAddress: options.smartWalletOptions.overrides?.entrypointAddress,
        userOp: unsignedUserOp,
    });
    return signedUserOp;
}
async function prepareUserOp(options) {
    const config = options.smartWalletOptions;
    const factoryContract = (0, contract_js_1.getContract)({
        address: config.factoryAddress ||
            (0, constants_js_1.getDefaultAccountFactory)(config.overrides?.entrypointAddress),
        chain: config.chain,
        client: options.client,
    });
    const accountAddress = await (0, calls_js_1.predictAddress)({
        factoryContract,
        adminAddress: options.adminAccount.address,
        predictAddressOverride: config.overrides?.predictAddress,
        accountSalt: config.overrides?.accountSalt,
        accountAddress: config.overrides?.accountAddress,
    });
    const accountContract = (0, contract_js_1.getContract)({
        address: accountAddress,
        chain: config.chain,
        client: options.client,
    });
    let executeTx;
    if (options.transactions.length === 1) {
        const tx = options.transactions[0];
        // for single tx, simulate fully
        const serializedTx = await (0, to_serializable_transaction_js_1.toSerializableTransaction)({
            transaction: tx,
            from: accountAddress,
        });
        executeTx = (0, calls_js_1.prepareExecute)({
            accountContract,
            transaction: serializedTx,
            executeOverride: config.overrides?.execute,
        });
    }
    else {
        // for multiple txs, we can't simulate, just encode
        const serializedTxs = await Promise.all(options.transactions.map(async (tx) => {
            const [data, to, value] = await Promise.all([
                (0, encode_js_1.encode)(tx),
                (0, resolve_promised_value_js_1.resolvePromisedValue)(tx.to),
                (0, resolve_promised_value_js_1.resolvePromisedValue)(tx.value),
            ]);
            return {
                data,
                to,
                value,
                chainId: tx.chain.id,
            };
        }));
        executeTx = (0, calls_js_1.prepareBatchExecute)({
            accountContract,
            transactions: serializedTxs,
            executeBatchOverride: config.overrides?.executeBatch,
        });
    }
    return createUnsignedUserOp({
        transaction: executeTx,
        factoryContract,
        accountContract,
        adminAddress: options.adminAccount.address,
        sponsorGas: "sponsorGas" in config ? config.sponsorGas : config.gasless,
        overrides: config.overrides,
        waitForDeployment: options.waitForDeployment,
        isDeployedOverride: options.isDeployedOverride,
    });
}
async function waitForAccountDeployed(accountContract) {
    const startTime = Date.now();
    while (isAccountDeploying(accountContract)) {
        if (Date.now() - startTime > 60000) {
            (0, exports.clearAccountDeploying)(accountContract); // clear the flag so it doesnt stay stuck in this state
            throw new Error("Account deployment is taking too long (over 1 minute). Please try again.");
        }
        await new Promise((resolve) => setTimeout(resolve, 500));
    }
}
//# sourceMappingURL=userop.js.map