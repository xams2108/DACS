"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bundleUserOp = bundleUserOp;
exports.estimateUserOpGas = estimateUserOpGas;
exports.estimateUserOpGasCost = estimateUserOpGasCost;
exports.getUserOpGasFees = getUserOpGasFees;
exports.getUserOpReceipt = getUserOpReceipt;
exports.getUserOpReceiptRaw = getUserOpReceiptRaw;
exports.getZkPaymasterData = getZkPaymasterData;
exports.broadcastZkTransaction = broadcastZkTransaction;
const viem_1 = require("viem");
const contract_js_1 = require("../../../contract/contract.js");
const parse_logs_js_1 = require("../../../event/actions/parse-logs.js");
const UserOperationRevertReason_js_1 = require("../../../extensions/erc4337/__generated__/IEntryPoint/events/UserOperationRevertReason.js");
const PostOpRevertReason_js_1 = require("../../../extensions/erc4337/__generated__/IEntryPoint_v07/events/PostOpRevertReason.js");
const is_contract_deployed_js_1 = require("../../../utils/bytecode/is-contract-deployed.js");
const hex_js_1 = require("../../../utils/encoding/hex.js");
const fetch_js_1 = require("../../../utils/fetch.js");
const json_js_1 = require("../../../utils/json.js");
const units_js_1 = require("../../../utils/units.js");
const index_js_1 = require("../index.js");
const types_js_1 = require("../types.js");
const calls_js_1 = require("./calls.js");
const constants_js_1 = require("./constants.js");
const userop_js_1 = require("./userop.js");
const utils_js_1 = require("./utils.js");
/**
 * Bundle a user operation.
 * @param args - The options for bundling a user operation.
 * @returns The bundle hash of the user operation.
 * @example
 * ```ts
 * import { bundleUserOp } from "thirdweb/wallets/smart";
 *
 * const userOpHash = await bundleUserOp({
 *  userOp,
 *  options,
 * });
 * ```
 * @walletUtils
 */
async function bundleUserOp(args) {
    return sendBundlerRequest({
        ...args,
        operation: "eth_sendUserOperation",
        params: [
            (0, utils_js_1.hexlifyUserOp)(args.userOp),
            args.options.entrypointAddress ?? constants_js_1.ENTRYPOINT_ADDRESS_v0_6,
        ],
    });
}
/**
 * Estimate the gas cost of a user operation.
 * @param args - The options for estimating the gas cost of a user operation.
 * @returns The estimated gas cost of the user operation.
 * @example
 * ```ts
 * import { estimateUserOpGas } from "thirdweb/wallets/smart";
 *
 * const gasCost = await estimateUserOpGas({
 *  userOp,
 *  options,
 * });
 * ```
 * @walletUtils
 */
async function estimateUserOpGas(args, stateOverrides) {
    const res = await sendBundlerRequest({
        ...args,
        operation: "eth_estimateUserOperationGas",
        params: [
            (0, utils_js_1.hexlifyUserOp)(args.userOp),
            args.options.entrypointAddress ?? constants_js_1.ENTRYPOINT_ADDRESS_v0_6,
            stateOverrides ?? {},
        ],
    });
    // add gas buffer for managed account factory delegate calls
    return {
        preVerificationGas: (0, hex_js_1.hexToBigInt)(res.preVerificationGas),
        verificationGas: res.verificationGas !== undefined
            ? (0, hex_js_1.hexToBigInt)(res.verificationGas)
            : undefined,
        verificationGasLimit: (0, hex_js_1.hexToBigInt)(res.verificationGasLimit),
        callGasLimit: (0, hex_js_1.hexToBigInt)(res.callGasLimit) + constants_js_1.MANAGED_ACCOUNT_GAS_BUFFER,
        paymasterVerificationGasLimit: res.paymasterVerificationGasLimit !== undefined
            ? (0, hex_js_1.hexToBigInt)(res.paymasterVerificationGasLimit)
            : undefined,
        paymasterPostOpGasLimit: res.paymasterPostOpGasLimit !== undefined
            ? (0, hex_js_1.hexToBigInt)(res.paymasterPostOpGasLimit)
            : undefined,
    };
}
/**
 * Estimate the gas cost of a user operation.
 * @param args - The options for estimating the gas cost of a user operation.
 * @returns The estimated gas cost of the user operation.
 * @example
 * ```ts
 * import { estimateUserOpGasCost } from "thirdweb/wallets/smart";
 *
 * const gasCost = await estimateUserOpGasCost({
 *  transactions,
 *  adminAccount,
 *  client,
 *  smartWalletOptions,
 * });
 * ```
 * @walletUtils
 */
async function estimateUserOpGasCost(args) {
    // if factory is passed, but no entrypoint, try to resolve entrypoint from factory
    if (args.smartWalletOptions.factoryAddress &&
        !args.smartWalletOptions.overrides?.entrypointAddress) {
        const entrypointAddress = await (0, index_js_1.getEntrypointFromFactory)(args.smartWalletOptions.factoryAddress, args.client, args.smartWalletOptions.chain);
        if (entrypointAddress) {
            args.smartWalletOptions.overrides = {
                ...args.smartWalletOptions.overrides,
                entrypointAddress,
            };
        }
    }
    const userOp = await (0, userop_js_1.prepareUserOp)({
        transactions: args.transactions,
        adminAccount: args.adminAccount,
        client: args.client,
        smartWalletOptions: args.smartWalletOptions,
        isDeployedOverride: await (0, is_contract_deployed_js_1.isContractDeployed)((0, contract_js_1.getContract)({
            address: await (0, calls_js_1.predictSmartAccountAddress)({
                adminAddress: args.adminAccount.address,
                factoryAddress: args.smartWalletOptions.factoryAddress,
                chain: args.smartWalletOptions.chain,
                client: args.client,
            }),
            chain: args.smartWalletOptions.chain,
            client: args.client,
        })),
        waitForDeployment: false,
    });
    let gasLimit = 0n;
    if ("paymasterVerificationGasLimit" in userOp) {
        // v0.7
        gasLimit =
            BigInt(userOp.paymasterVerificationGasLimit ?? 0) +
                BigInt(userOp.paymasterPostOpGasLimit ?? 0) +
                BigInt(userOp.verificationGasLimit ?? 0) +
                BigInt(userOp.preVerificationGas ?? 0) +
                BigInt(userOp.callGasLimit ?? 0);
    }
    else {
        // v0.6
        gasLimit =
            BigInt(userOp.verificationGasLimit ?? 0) +
                BigInt(userOp.preVerificationGas ?? 0) +
                BigInt(userOp.callGasLimit ?? 0);
    }
    const gasCost = gasLimit * (userOp.maxFeePerGas ?? 0n);
    return {
        ether: (0, units_js_1.toEther)(gasCost),
        wei: gasCost,
    };
}
/**
 * Get the gas fees of a user operation.
 * @param args - The options for getting the gas price of a user operation.
 * @returns The gas price of the user operation.
 * @example
 * ```ts
 * import { getUserOpGasPrice } from "thirdweb/wallets/smart";
 *
 * const fees = await getUserOpGasPrice({
 *  options,
 * });
 * ```
 * @walletUtils
 */
async function getUserOpGasFees(args) {
    const res = await sendBundlerRequest({
        ...args,
        operation: "thirdweb_getUserOperationGasPrice",
        params: [],
    });
    return {
        maxPriorityFeePerGas: (0, hex_js_1.hexToBigInt)(res.maxPriorityFeePerGas),
        maxFeePerGas: (0, hex_js_1.hexToBigInt)(res.maxFeePerGas),
    };
}
/**
 * Get the receipt of a user operation.
 * @param args - The options for getting the receipt of a user operation.
 * @returns The receipt of the user operation.
 * @example
 * ```ts
 * import { getUserOpReceipt } from "thirdweb/wallets/smart";
 *
 * const receipt = await getUserOpReceipt({
 *  client,
 *  chain,
 *  userOpHash,
 * });
 * ```
 * @walletUtils
 */
async function getUserOpReceipt(args) {
    const res = await getUserOpReceiptRaw(args);
    if (!res) {
        return undefined;
    }
    if (res.success === false) {
        // parse revert reason
        const logs = (0, parse_logs_js_1.parseEventLogs)({
            events: [(0, UserOperationRevertReason_js_1.userOperationRevertReasonEvent)(), (0, PostOpRevertReason_js_1.postOpRevertReasonEvent)()],
            logs: res.logs,
        });
        const revertReason = logs[0]?.args?.revertReason;
        if (!revertReason) {
            throw new Error(`UserOp failed at txHash: ${res.receipt.transactionHash}`);
        }
        const revertMsg = (0, viem_1.decodeErrorResult)({
            data: revertReason,
        });
        throw new Error(`UserOp failed with reason: '${revertMsg.args.join(",")}' at txHash: ${res.receipt.transactionHash}`);
    }
    return res.receipt;
}
/**
 * Get the receipt of a user operation.
 * @param args - The options for getting the receipt of a user operation.
 * @returns The raw receipt of the user operation.
 * @example
 * ```ts
 * import { getUserOpReceiptRaw } from "thirdweb/wallets/smart";
 *
 * const receipt = await getUserOpReceiptRaw({
 *  client,
 *  chain,
 *  userOpHash,
 * });
 * ```
 * @walletUtils
 */
async function getUserOpReceiptRaw(args) {
    const res = await sendBundlerRequest({
        options: args,
        operation: "eth_getUserOperationReceipt",
        params: [args.userOpHash],
    });
    if (!res) {
        return undefined;
    }
    return (0, types_js_1.formatUserOperationReceipt)(res);
}
/**
 * @internal
 */
async function getZkPaymasterData(args) {
    const res = await sendBundlerRequest({
        options: args.options,
        operation: "zk_paymasterData",
        params: [args.transaction],
    });
    return {
        paymaster: res.paymaster,
        paymasterInput: res.paymasterInput,
    };
}
async function broadcastZkTransaction(args) {
    const res = await sendBundlerRequest({
        options: args.options,
        operation: "zk_broadcastTransaction",
        params: [
            {
                ...args.transaction,
                signedTransaction: args.signedTransaction,
            },
        ],
    });
    return {
        transactionHash: res.transactionHash,
    };
}
async function sendBundlerRequest(args) {
    const { options, operation, params } = args;
    const bundlerUrl = options.bundlerUrl ?? (0, constants_js_1.getDefaultBundlerUrl)(options.chain);
    const fetchWithHeaders = (0, fetch_js_1.getClientFetch)(options.client);
    const response = await fetchWithHeaders(bundlerUrl, {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
        },
        body: (0, json_js_1.stringify)({
            jsonrpc: "2.0",
            id: 1,
            method: operation,
            params,
        }),
    });
    const res = await response.json();
    if (!response.ok || res.error) {
        let error = res.error || response.statusText;
        if (typeof error === "object") {
            error = (0, json_js_1.stringify)(error);
        }
        const code = res.code || "UNKNOWN";
        throw new Error(`${operation} error: ${error}
Status: ${response.status}
Code: ${code}`);
    }
    return res.result;
}
//# sourceMappingURL=bundler.js.map