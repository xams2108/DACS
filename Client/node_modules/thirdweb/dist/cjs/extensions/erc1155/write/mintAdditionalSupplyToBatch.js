"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mintAdditionalSupplyToBatch = mintAdditionalSupplyToBatch;
exports.optimizeMintBatchContent = optimizeMintBatchContent;
const multicall_js_1 = require("../../../extensions/common/__generated__/IMulticall/write/multicall.js");
const uri_js_1 = require("../__generated__/IERC1155/read/uri.js");
const mintTo_js_1 = require("../__generated__/IMintableERC1155/write/mintTo.js");
/**
 * This extension batches multiple `mintAdditionalSupplyToBatch` extensions into one single multicall.
 * Keep in mind that there is a limit of how many NFTs you can mint per transaction.
 * This limit varies depends on the network that you are transacting on.
 *
 * You are recommended to experiment with the number to figure out the best number for your chain of choice.
 * @extension ERC1155
 * @example
 * ```ts
 * import { mintAdditionalSupplyToBatch } from "thirdweb/extensions/erc1155";
 *
 * const transaction = mintAdditionalSupplyToBatch({
 *   contract,
 *   nfts: [
 *     { tokenId: 0n, supply: 99n, to: account.address },
 *     { tokenId: 1n, supply: 98n, to: account.address },
 *     { tokenId: 2n, supply: 97n, to: account.address },
 *   ],
 * });
 * ```
 */
function mintAdditionalSupplyToBatch(options) {
    return (0, multicall_js_1.multicall)({
        contract: options.contract,
        asyncParams: async () => {
            const nfts = optimizeMintBatchContent(options.nfts);
            const data = await Promise.all(nfts.map(async (nft) => {
                const tokenUri = await (0, uri_js_1.uri)({
                    contract: options.contract,
                    tokenId: nft.tokenId,
                });
                return (0, mintTo_js_1.encodeMintTo)({
                    to: nft.to,
                    tokenId: nft.tokenId,
                    amount: nft.supply,
                    uri: tokenUri,
                });
            }));
            return { data };
        },
        overrides: options.overrides,
    });
}
/**
 * Optimization
 *
 * We can batch the records that share the same "to" & "tokenId" into 1 transaction
 *
 * For example, this struct:
 * [
 *   { tokenId: 0n, supply: 99n, to: account.address },
 *   { tokenId: 1n, supply: 49n, to: account.address },
 *   { tokenId: 1n, supply: 51n, to: account.address },
 * ]
 *
 * ...can be packed into:
 * [
 *   { tokenId: 0n, supply: 99n, to: account.address },
 *   { tokenId: 1n, supply: 100n, to: account.address },
 * ]
 * @internal
 */
function optimizeMintBatchContent(nfts) {
    const results = [];
    for (const item of nfts) {
        const matchingIndex = results.findIndex((o) => o.tokenId === item.tokenId &&
            o.to.toLowerCase() === item.to.toLowerCase());
        if (matchingIndex !== -1) {
            results[matchingIndex] = {
                to: item.to,
                tokenId: item.tokenId,
                supply: item.supply + (results[matchingIndex]?.supply || 0n),
            };
        }
        else {
            results.push(item);
        }
    }
    return results;
}
//# sourceMappingURL=mintAdditionalSupplyToBatch.js.map