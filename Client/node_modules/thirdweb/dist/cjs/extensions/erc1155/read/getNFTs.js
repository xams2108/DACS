"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNFTs = getNFTs;
exports.isGetNFTsSupported = isGetNFTsSupported;
const Solidity_1 = require("ox/Solidity");
const get_nfts_js_1 = require("../../../insight/get-nfts.js");
const bigint_js_1 = require("../../../utils/bigint.js");
const nextTokenIdToMint_js_1 = require("../__generated__/IERC1155Enumerable/read/nextTokenIdToMint.js");
const getNFT_js_1 = require("./getNFT.js");
const DEFAULT_QUERY_ALL_COUNT = 100n;
/**
 * Retrieves an array of NFTs ("ERC1155") based on the provided options.
 * @param options - The options for retrieving the NFTs.
 * @returns A promise that resolves to an array of NFTs.
 * @extension ERC1155
 * @example
 * ```ts
 * import { getNFTs } from "thirdweb/extensions/erc1155";
 * const nfts = await getNFTs({
 *  contract,
 *  start: 0,
 *  count: 10,
 * });
 * ```
 */
async function getNFTs(options) {
    const { useIndexer = true } = options;
    if (useIndexer) {
        try {
            return await getNFTsFromInsight(options);
        }
        catch {
            return await getNFTsFromRPC(options);
        }
    }
    return await getNFTsFromRPC(options);
}
async function getNFTsFromInsight(options) {
    const { contract, start, count = Number(DEFAULT_QUERY_ALL_COUNT) } = options;
    const [result, supply] = await Promise.all([
        (0, get_nfts_js_1.getContractNFTs)({
            client: contract.client,
            chains: [contract.chain],
            contractAddress: contract.address,
            queryOptions: {
                limit: count,
                page: start ? Math.floor(start / count) : undefined,
            },
        }),
        (0, nextTokenIdToMint_js_1.nextTokenIdToMint)(options).catch(() => Solidity_1.maxUint256),
    ]);
    const currentOffset = start ?? 0;
    const expectedResultLength = Math.min(count, Math.max(0, Number(supply) - currentOffset));
    if (result.length < expectedResultLength) {
        // fresh contracts might be delayed in indexing, so we fallback to RPC
        return getNFTsFromRPC(options);
    }
    return result;
}
async function getNFTsFromRPC(options) {
    const start = BigInt(options.start || 0);
    const count = BigInt(options.count || DEFAULT_QUERY_ALL_COUNT);
    // try to get the totalCount (non-standard) - if this fails then just use maxUint256
    const totalCount = await (0, nextTokenIdToMint_js_1.nextTokenIdToMint)(options).catch(() => Solidity_1.maxUint256);
    // get the maxId to query up to (either the totalCount or the start + count, whichever is smaller)
    const maxId = (0, bigint_js_1.min)(totalCount, start + count);
    const promises = [];
    for (let i = start; i < maxId; i++) {
        promises.push((0, getNFT_js_1.getNFT)({
            ...options,
            tokenId: i,
            useIndexer: false,
        }));
    }
    return await Promise.all(promises);
}
/**
 * Checks if the `getNFTs` method is supported by the given contract.
 * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using "whatsabi" or if you have the ABI of the contract available you can use it to generate the selectors.
 * @returns A boolean indicating if the `getNFTs` method is supported.
 * @extension ERC1155
 * @example
 * ```ts
 * import { isGetNFTsSupported } from "thirdweb/extensions/erc721";
 *
 * const supported = isGetNFTsSupported(["0x..."]);
 * ```
 */
function isGetNFTsSupported(availableSelectors) {
    return ((0, getNFT_js_1.isGetNFTSupported)(availableSelectors) &&
        (0, nextTokenIdToMint_js_1.isNextTokenIdToMintSupported)(availableSelectors));
}
//# sourceMappingURL=getNFTs.js.map