"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOwnedNFTs = getOwnedNFTs;
const get_nfts_js_1 = require("../../../insight/get-nfts.js");
const getNFT_js_1 = require("./getNFT.js");
const getOwnedTokenIds_js_1 = require("./getOwnedTokenIds.js");
/**
 * Retrieves the owned ERC1155 NFTs for a given wallet address.
 * @param options - The transaction options and parameters.
 * @returns A promise that resolves to an array of ERC1155 NFTs owned by the wallet address, along with the quantity owned.
 * @extension ERC1155
 * @example
 * ```ts
 * import { getOwnedNFTs } from "thirdweb/extensions/erc1155";
 * const nfts = await getOwnedNFTs({
 *  contract,
 *  start: 0,
 *  count: 10,
 *  address: "0x123...",
 * });
 * ```
 */
async function getOwnedNFTs(options) {
    const { useIndexer = true } = options;
    if (useIndexer) {
        try {
            return await getOwnedNFTsFromInsight(options);
        }
        catch {
            return await getOwnedNFTsFromRPC(options);
        }
    }
    return await getOwnedNFTsFromRPC(options);
}
async function getOwnedNFTsFromInsight(options) {
    const limit = 50;
    const nfts = [];
    let page = 0;
    let hasMore = true;
    // TODO (insight): add support for contract address filters
    while (hasMore) {
        const pageResults = await (0, get_nfts_js_1.getOwnedNFTs)({
            client: options.contract.client,
            chains: [options.contract.chain],
            ownerAddress: options.address,
            queryOptions: {
                limit,
                page,
            },
        });
        nfts.push(...pageResults);
        // If we got fewer results than the limit, we've reached the end
        if (pageResults.length < limit) {
            hasMore = false;
        }
        else {
            page++;
        }
    }
    const results = nfts;
    return results
        .filter((n) => n.tokenAddress.toLowerCase() === options.contract.address.toLowerCase())
        .map((result) => ({
        ...result,
        owner: options.address,
    }));
}
async function getOwnedNFTsFromRPC(options) {
    const ownedBalances = await (0, getOwnedTokenIds_js_1.getOwnedTokenIds)(options);
    const nfts = await Promise.all(ownedBalances.map((ob) => (0, getNFT_js_1.getNFT)({ ...options, tokenId: ob.tokenId, useIndexer: false })));
    return nfts.map((nft, index) => ({
        ...nft,
        owner: options.address,
        quantityOwned: ownedBalances[index]?.balance || 0n,
    }));
}
//# sourceMappingURL=getOwnedNFTs.js.map