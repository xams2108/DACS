"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isGetNFTSupported = void 0;
exports.getNFT = getNFT;
const fetchTokenMetadata_js_1 = require("../../../utils/nft/fetchTokenMetadata.js");
const parseNft_js_1 = require("../../../utils/nft/parseNft.js");
const tokenURI_js_1 = require("../__generated__/IERC721A/read/tokenURI.js");
const tokenByIndex_js_1 = require("../__generated__/IERC721Enumerable/read/tokenByIndex.js");
var tokenURI_js_2 = require("../__generated__/IERC721A/read/tokenURI.js");
Object.defineProperty(exports, "isGetNFTSupported", { enumerable: true, get: function () { return tokenURI_js_2.isTokenURISupported; } });
const index_js_1 = require("../../../insight/index.js");
/**
 * Retrieves information about a specific ERC721 non-fungible token (NFT).
 * @param options - The options for retrieving the NFT.
 * @returns A promise that resolves to the NFT object.
 * @extension ERC721
 * @example
 * ```ts
 * import { getNFT } from "thirdweb/extensions/erc721";
 * const nft = await getNFT({
 *  contract,
 *  tokenId: 1n,
 * });
 * ```
 *
 * * @example
 * ```ts
 * import { getNFT } from "thirdweb/extensions/erc721";
 *
 *
 * const nft = await getNFT({
 *  contract,
 *  tokenId: 1n,
 *  tokenByIndex: true // use this flag if the contract supports `tokenByIndex` and the above tokenId should be treated as an index.
 * });
 * ```
 */
async function getNFT(options) {
    const { useIndexer = true } = options;
    if (useIndexer) {
        try {
            return await getNFTFromInsight(options);
        }
        catch {
            return await getNFTFromRPC(options);
        }
    }
    return await getNFTFromRPC(options);
}
async function getNFTFromInsight(options) {
    const nft = await (0, index_js_1.getNFT)({
        client: options.contract.client,
        chain: options.contract.chain,
        contractAddress: options.contract.address,
        tokenId: options.tokenId,
        includeOwners: options.includeOwner,
    });
    if (!nft) {
        // fresh contracts might be delayed in indexing, so we fallback to RPC
        return getNFTFromRPC(options);
    }
    return nft;
}
async function getNFTFromRPC(options) {
    let tokenId = options.tokenId;
    if (options.tokenByIndex) {
        try {
            tokenId = await (0, tokenByIndex_js_1.tokenByIndex)({
                contract: options.contract,
                index: options.tokenId,
            });
        }
        catch { }
    }
    const [uri, owner] = await Promise.all([
        (0, tokenURI_js_1.tokenURI)({ contract: options.contract, tokenId }).catch(() => null),
        options.includeOwner
            ? Promise.resolve().then(() => require("../__generated__/IERC721A/read/ownerOf.js")).then((m) => m.ownerOf({ contract: options.contract, tokenId }))
                .catch(() => null)
            : null,
    ]);
    if (!uri?.trim()) {
        return (0, parseNft_js_1.parseNFT)({
            id: tokenId,
            type: "ERC721",
            uri: "",
        }, {
            tokenId,
            tokenUri: "",
            type: "ERC721",
            owner,
            tokenAddress: options.contract.address,
            chainId: options.contract.chain.id,
        });
    }
    return (0, parseNft_js_1.parseNFT)(await (0, fetchTokenMetadata_js_1.fetchTokenMetadata)({
        client: options.contract.client,
        tokenId,
        tokenUri: uri,
    }).catch(() => ({
        id: tokenId,
        type: "ERC721",
        uri,
    })), {
        tokenId: tokenId,
        tokenUri: uri,
        type: "ERC721",
        owner,
        tokenAddress: options.contract.address,
        chainId: options.contract.chain.id,
    });
}
//# sourceMappingURL=getNFT.js.map