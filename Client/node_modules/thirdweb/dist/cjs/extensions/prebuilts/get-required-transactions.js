"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRequiredTransactions = getRequiredTransactions;
exports.getAllDefaultConstructorParamsForImplementation = getAllDefaultConstructorParamsForImplementation;
exports.generateExtensionFunctionsFromAbi = generateExtensionFunctionsFromAbi;
const viem_1 = require("viem");
const resolve_abi_js_1 = require("../../contract/actions/resolve-abi.js");
const create_2_factory_js_1 = require("../../contract/deployment/utils/create-2-factory.js");
const infra_js_1 = require("../../contract/deployment/utils/infra.js");
const infra_js_2 = require("../../contract/deployment/utils/infra.js");
const implementations_js_1 = require("../../contract/deployment/zksync/implementations.js");
const compute_published_contract_address_js_1 = require("../../utils/any-evm/compute-published-contract-address.js");
const isZkSyncChain_js_1 = require("../../utils/any-evm/zksync/isZkSyncChain.js");
/**
 * @internal
 */
async function getRequiredTransactions(options) {
    const { chain, client, deployMetadata, implementationConstructorParams, modules = [], } = options;
    const isZkSync = await (0, isZkSyncChain_js_1.isZkSyncChain)(chain);
    if (deployMetadata?.deployType === "autoFactory") {
        const results = await Promise.all([
            isZkSync
                ? null
                : (0, create_2_factory_js_1.getDeployedCreate2Factory)({
                    chain,
                    client,
                }).then((c) => c
                    ? null
                    : { type: "infra", contractId: "Create2Factory" }),
            isZkSync
                ? null
                : (0, infra_js_1.getDeployedInfraContract)({
                    chain,
                    client,
                    contractId: "Forwarder",
                }).then((c) => c ? null : { type: "infra", contractId: "Forwarder" }),
            isZkSync
                ? null
                : (0, infra_js_1.getDeployedInfraContract)({
                    chain,
                    client,
                    contractId: "TWCloneFactory",
                    constructorParams: {
                        _trustedForwarder: await (0, compute_published_contract_address_js_1.computePublishedContractAddress)({
                            chain,
                            client,
                            contractId: "Forwarder",
                        }),
                    },
                }).then((c) => c
                    ? null
                    : { type: "infra", contractId: "TWCloneFactory" }),
            // TODO (deploy): add WETH contract check for implementations that need it (check implementation constructor params)
            getTransactionsForImplementation({
                chain,
                client,
                deployMetadata,
                implementationConstructorParams,
            }),
            ...modules.map((m) => (0, infra_js_2.getDeployedInfraContractFromMetadata)({
                chain,
                client,
                contractMetadata: m.deployMetadata,
            }).then((c) => c
                ? null
                : {
                    type: "module",
                    contractId: m.deployMetadata.name,
                })),
        ]);
        results.push({ type: "proxy", contractId: deployMetadata.name });
        return results.flat().filter((r) => r !== null);
    }
    return [{ type: "implementation", contractId: deployMetadata.name }];
}
async function getTransactionsForImplementation(options) {
    const { chain, client, deployMetadata, implementationConstructorParams } = options;
    if (deployMetadata.name === "MarketplaceV3") {
        return getTransactionsForMaketplaceV3(options);
    }
    if (deployMetadata.routerType === "dynamic") {
        return getTransactionsForDynamicContract(options);
    }
    const constructorParams = implementationConstructorParams ??
        (await getAllDefaultConstructorParamsForImplementation({
            chain,
            client,
            contractId: deployMetadata.name,
        }));
    const result = await (0, infra_js_1.getDeployedInfraContract)({
        chain,
        client,
        contractId: deployMetadata.name,
        constructorParams,
        publisher: deployMetadata.publisher,
        version: deployMetadata.version,
    }).then((c) => c
        ? null
        : {
            type: "implementation",
            contractId: deployMetadata.name,
        });
    return result ? [result] : [];
}
async function getTransactionsForMaketplaceV3(options) {
    const { chain, client } = options;
    const WETHAdress = await (0, compute_published_contract_address_js_1.computePublishedContractAddress)({
        chain,
        client,
        contractId: "WETH9",
    });
    const extensions = await Promise.all([
        (0, infra_js_1.getDeployedInfraContract)({
            chain,
            client,
            contractId: "WETH9",
        }).then((c) => c ? null : { type: "infra", contractId: "WETH9" }),
        (0, infra_js_1.getDeployedInfraContract)({
            chain,
            client,
            contractId: "DirectListingsLogic",
            constructorParams: { _nativeTokenWrapper: WETHAdress },
        }).then((c) => c
            ? null
            : { type: "extension", contractId: "DirectListingsLogic" }),
        (0, infra_js_1.getDeployedInfraContract)({
            chain,
            client,
            contractId: "EnglishAuctionsLogic",
            constructorParams: { _nativeTokenWrapper: WETHAdress },
        }).then((c) => c
            ? null
            : { type: "extension", contractId: "EnglishAuctionsLogic" }),
        (0, infra_js_1.getDeployedInfraContract)({
            chain,
            client,
            contractId: "OffersLogic",
        }).then((c) => c ? null : { type: "extension", contractId: "OffersLogic" }),
    ]);
    // hacky assumption: if we need to deploy any of the extensions, we also need to deploy the implementation
    const transactions = extensions.filter((e) => e !== null);
    if (transactions.length) {
        transactions.push({ type: "implementation", contractId: "MarketplaceV3" });
    }
    return transactions;
}
async function getTransactionsForDynamicContract(options) {
    const { chain, client } = options;
    const WETHAdress = await (0, compute_published_contract_address_js_1.computePublishedContractAddress)({
        chain,
        client,
        contractId: "WETH9",
    });
    const wethTx = await (0, infra_js_1.getDeployedInfraContract)({
        chain,
        client,
        contractId: "WETH9",
    }).then((c) => c ? null : { type: "infra", contractId: "WETH9" });
    const extensions = options.deployMetadata
        .defaultExtensions
        ? await Promise.all(options.deployMetadata.defaultExtensions.map((e) => {
            return (0, infra_js_1.getDeployedInfraContract)({
                chain,
                client,
                contractId: e.extensionName,
                publisher: e.publisherAddress,
                version: e.extensionVersion || "latest",
                constructorParams: { _nativeTokenWrapper: WETHAdress },
            }).then((c) => c
                ? null
                : { type: "extension", contractId: e.extensionName });
        }))
        : [];
    // hacky assumption: if we need to deploy any of the extensions, we also need to deploy the implementation
    const transactions = [...extensions, wethTx].filter((e) => e !== null);
    if (transactions.length) {
        transactions.push({
            type: "implementation",
            contractId: options.deployMetadata.name,
        });
    }
    return transactions;
}
/**
 * Gets the default constructor parameters required for contract implementation deployment
 * @param args - The arguments object
 * @param args.chain - The blockchain network configuration
 * @param args.client - The ThirdwebClient instance
 * @returns An object containing default constructor parameters:
 * - On zkSync chains: returns an empty object since no parameters are needed
 * - On other chains: returns `trustedForwarder` and `nativeTokenWrapper` addresses
 *
 * @internal
 */
async function getAllDefaultConstructorParamsForImplementation(args) {
    const { chain, client } = args;
    const isZkSync = await (0, isZkSyncChain_js_1.isZkSyncChain)(chain);
    if (isZkSync) {
        const weth = implementations_js_1.ZKSYNC_WETH[chain.id];
        return {
            nativeTokenWrapper: weth,
        };
    }
    const forwarderContractId = args.contractId === "Pack" ? "ForwarderEOAOnly" : "Forwarder";
    const [forwarder, weth] = await Promise.all([
        (0, compute_published_contract_address_js_1.computePublishedContractAddress)({
            chain,
            client,
            contractId: forwarderContractId,
        }),
        (0, compute_published_contract_address_js_1.computePublishedContractAddress)({
            chain,
            client,
            contractId: "WETH9",
        }),
    ]);
    const defaultExtensionInput = args.defaultExtensions
        ? await generateExtensionInput({
            defaultExtensions: args.defaultExtensions,
            chain,
            client,
            forwarder,
            nativeTokenWrapper: weth,
        })
        : [];
    return {
        trustedForwarder: forwarder,
        nativeTokenWrapper: weth,
        extensions: defaultExtensionInput,
    };
}
async function generateExtensionInput(args) {
    const { defaultExtensions, chain, client, forwarder, nativeTokenWrapper } = args;
    const deployedExtensions = await Promise.all(defaultExtensions.map((e) => (0, infra_js_1.getDeployedInfraContract)({
        chain,
        client,
        contractId: e.extensionName,
        publisher: e.publisherAddress,
        version: e.extensionVersion || "latest",
        constructorParams: { forwarder, nativeTokenWrapper },
    }).then((c) => ({
        name: e.extensionName,
        metadataURI: "",
        implementation: c,
    }))));
    const extensionInput = await Promise.all(deployedExtensions.map(async (e) => {
        if (!e.implementation) {
            throw new Error("Extension not deployed");
        }
        return (0, resolve_abi_js_1.resolveContractAbi)(e.implementation)
            .then(generateExtensionFunctionsFromAbi)
            .then((c) => ({
            metadata: {
                ...e,
                implementation: e.implementation?.address,
            },
            functions: c,
        }));
    }));
    return extensionInput;
}
function generateExtensionFunctionsFromAbi(abi) {
    const functions = abi.filter((item) => item.type === "function" && !item.name.startsWith("_"));
    return functions.map((fn) => ({
        functionSelector: (0, viem_1.toFunctionSelector)(fn),
        functionSignature: (0, viem_1.toFunctionSignature)(fn),
    }));
}
//# sourceMappingURL=get-required-transactions.js.map