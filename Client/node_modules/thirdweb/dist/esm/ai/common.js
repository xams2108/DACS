import { getCachedChain } from "../chains/utils.js";
import { prepareTransaction, } from "../transaction/prepare-transaction.js";
import { toBigInt } from "../utils/bigint.js";
import { getClientFetch } from "../utils/fetch.js";
const NEBULA_API_URL = "https://nebula-api.thirdweb.com";
export async function nebulaFetch(mode, input) {
    const fetch = getClientFetch(input.client);
    const response = await fetch(`${NEBULA_API_URL}/${mode}`, {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
        },
        body: JSON.stringify({
            ...("messages" in input
                ? {
                    messages: input.messages,
                }
                : {
                    message: input.message,
                }),
            session_id: input.sessionId,
            ...(input.account
                ? {
                    execute_config: {
                        mode: "client",
                        signer_wallet_address: input.account.address,
                    },
                }
                : {}),
            ...(input.contextFilter
                ? {
                    context_filter: {
                        chain_ids: input.contextFilter.chains?.map((c) => c.id.toString()) || [],
                        wallet_addresses: input.contextFilter.walletAddresses ||
                            (input.account ? [input.account.address] : []),
                        contract_addresses: input.contextFilter.contractAddresses || [],
                    },
                }
                : {}),
        }),
    });
    if (!response.ok) {
        const error = await response.text();
        throw new Error(`Nebula API error: ${error}`);
    }
    const data = (await response.json());
    // parse transactions if present
    let transactions = [];
    if (data.actions) {
        transactions = data.actions
            .map((action) => {
            // only parse sign_transaction actions
            if (action.type === "sign_transaction") {
                const tx = JSON.parse(action.data);
                return prepareTransaction({
                    chain: getCachedChain(tx.chainId),
                    client: input.client,
                    to: tx.to,
                    value: tx.value ? toBigInt(tx.value) : undefined,
                    data: tx.data,
                });
            }
            return undefined;
        })
            .filter((tx) => tx !== undefined);
    }
    return {
        message: data.message,
        sessionId: data.session_id,
        transactions,
    };
}
//# sourceMappingURL=common.js.map