import { toHex } from "../../utils/encoding/hex.js";
import { stringify } from "../../utils/json.js";
/**
 * Creates an account that uses your engine backend wallet for sending transactions and signing messages.
 *
 * @param options - The options for the engine account.
 * @returns An account that uses your engine backend wallet.
 *
 * @beta
 * @wallet
 *
 * @example
 * ```ts
 * import { engineAccount } from "thirdweb/wallets/engine";
 *
 * const engineAcc = engineAccount({
 *   engineUrl: "https://engine.thirdweb.com",
 *   authToken: "your-auth-token",
 *   walletAddress: "0x...",
 * });
 *
 * // then use the account as you would any other account
 * const transaction = claimTo({
 *   contract,
 *   to: "0x...",
 *   quantity: 1n,
 * });
 * const result = await sendTransaction({ transaction, account: engineAcc });
 * console.log("Transaction sent:", result.transactionHash);
 * ```
 */
export function engineAccount(options) {
    const { engineUrl, authToken, walletAddress, chain, overrides } = options;
    // these are shared across all methods
    const headers = {
        "x-backend-wallet-address": walletAddress,
        Authorization: `Bearer ${authToken}`,
        "Content-Type": "application/json",
    };
    if (overrides?.accountAddress) {
        headers["x-account-address"] = overrides.accountAddress;
    }
    if (overrides?.accountFactoryAddress) {
        headers["x-account-factory-address"] = overrides.accountFactoryAddress;
    }
    if (overrides?.accountSalt) {
        headers["x-account-salt"] = overrides.accountSalt;
    }
    return {
        address: walletAddress,
        sendTransaction: async (transaction) => {
            const ENGINE_URL = new URL(engineUrl);
            ENGINE_URL.pathname = `/backend-wallet/${transaction.chainId}/send-transaction`;
            const engineData = {
                // add to address if we have it (is optional to pass to engine)
                toAddress: transaction.to || undefined,
                // engine wants a hex string here so we serialize it
                data: transaction.data || "0x",
                // value is always required
                value: toHex(transaction.value ?? 0n),
            };
            // TODO: gas overrides etc?
            const engineRes = await fetch(ENGINE_URL, {
                method: "POST",
                headers,
                body: stringify(engineData),
            });
            if (!engineRes.ok) {
                const body = await engineRes.text();
                throw new Error(`Engine request failed with status ${engineRes.status} - ${body}`);
            }
            const engineJson = (await engineRes.json());
            // wait for the queueId to be processed
            ENGINE_URL.pathname = `/transaction/status/${engineJson.result.queueId}`;
            const startTime = Date.now();
            const TIMEOUT_IN_MS = 5 * 60 * 1000; // 5 minutes in milliseconds
            while (Date.now() - startTime < TIMEOUT_IN_MS) {
                const queueRes = await fetch(ENGINE_URL, {
                    method: "GET",
                    headers,
                });
                if (!queueRes.ok) {
                    const body = await queueRes.text();
                    throw new Error(`Engine request failed with status ${queueRes.status} - ${body}`);
                }
                const queueJSON = (await queueRes.json());
                if (queueJSON.result.status === "errored" &&
                    queueJSON.result.errorMessage) {
                    throw new Error(queueJSON.result.errorMessage);
                }
                if (queueJSON.result.transactionHash) {
                    return {
                        transactionHash: queueJSON.result.transactionHash,
                    };
                }
                // wait 1s before checking again
                await new Promise((resolve) => setTimeout(resolve, 1000));
            }
            throw new Error("Transaction timed out after 5 minutes");
        },
        signMessage: async ({ message }) => {
            let engineMessage;
            let isBytes = false;
            if (typeof message === "string") {
                engineMessage = message;
            }
            else {
                engineMessage = toHex(message.raw);
                isBytes = true;
            }
            const ENGINE_URL = new URL(engineUrl);
            ENGINE_URL.pathname = "/backend-wallet/sign-message";
            const engineRes = await fetch(ENGINE_URL, {
                method: "POST",
                headers,
                body: stringify({
                    message: engineMessage,
                    isBytes,
                    chainId: chain?.id,
                }),
            });
            if (!engineRes.ok) {
                const body = await engineRes.text();
                throw new Error(`Engine request failed with status ${engineRes.status} - ${body}`);
            }
            const engineJson = (await engineRes.json());
            return engineJson.result;
        },
        signTypedData: async (_typedData) => {
            const ENGINE_URL = new URL(engineUrl);
            ENGINE_URL.pathname = "/backend-wallet/sign-typed-data";
            const engineRes = await fetch(ENGINE_URL, {
                method: "POST",
                headers,
                body: stringify({
                    domain: _typedData.domain,
                    types: _typedData.types,
                    value: _typedData.message,
                    primaryType: _typedData.primaryType,
                    chainId: chain?.id,
                }),
            });
            if (!engineRes.ok) {
                const body = await engineRes.text();
                throw new Error(`Engine request failed with status ${engineRes.status} - ${body}`);
            }
            const engineJson = (await engineRes.json());
            return engineJson.result;
        },
    };
}
//# sourceMappingURL=index.js.map