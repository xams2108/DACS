"use client";
import { jsx as _jsx } from "react/jsx-runtime";
import { useQuery } from "@tanstack/react-query";
import { getChainMetadata } from "../../../../../chains/utils.js";
import { NATIVE_TOKEN_ADDRESS } from "../../../../../constants/addresses.js";
import { getContract } from "../../../../../contract/contract.js";
import { getContractMetadata } from "../../../../../extensions/common/read/getContractMetadata.js";
import { name } from "../../../../../extensions/common/read/name.js";
import { getFunctionId } from "../../../../../utils/function-id.js";
import { useTokenContext } from "./provider.js";
/**
 * This component fetches then shows the name of a token. For ERC20 tokens, it calls the `name` function in the ERC20 contract.
 * It inherits all the attributes of a HTML <span> component, hence you can style it just like how you would style a normal <span>
 *
 *
 * @example
 * ### Basic usage
 * ```tsx
 * import { TokenProvider, TokenName } from "thirdweb/react";
 * import { ethereum } from "thirdweb/chains";
 *
 * <TokenProvider {...props}>
 *   <TokenName  />
 * </TokenProvider>
 * ```
 * Result:
 * ```html
 * <span>Ether</span>
 * ```
 *
 * ### Custom name resolver
 * By default TokenName will call the `name` method of the token contract.
 * However if you have a different way to fetch the name, you can pass the function to the `nameResolver` prop.
 * Note: nameResolver should either be a string or a function (async) that returns a string.
 * ```tsx
 * async function fetchNameMethod() {
 *   // your own fetching logic
 *   return "the token name";
 * }
 *
 * <TokenName nameResolver={fetchNameMethod} />
 * ```
 *
 * Alternatively you can also pass in a string directly:
 * ```tsx
 * <TokenName nameResolver="USD Coin Circle" />
 * ```
 *
 *
 * ### Format the name (capitalize, truncate, etc.)
 * The TokenName component accepts a `formatFn` which takes in a string and outputs a string
 * The function is used to modify the name of the token
 *
 * ```tsx
 * const concatStr = (str: string):string => str + "Token"
 *
 * <TokenName formatFn={concatStr} />
 * ```
 *
 * Result:
 * ```html
 * <span>Ether Token</span>
 * ```
 *
 * ### Show a loading sign when the name is being fetched
 * ```tsx
 * import { TokenProvider, TokenName } from "thirdweb/react";
 *
 * <TokenProvider address="0x...">
 *   <TokenName loadingComponent={<Spinner />} />
 * </TokenProvider>
 * ```
 *
 * ### Fallback to something when the name fails to resolve
 * ```tsx
 * <TokenProvider address="0x...">
 *   <TokenName fallbackComponent={"Failed to load"} />
 * </TokenProvider>
 * ```
 *
 * ### Custom query options for useQuery
 * This component uses `@tanstack-query`'s useQuery internally.
 * You can use the `queryOptions` prop for more fine-grained control
 * ```tsx
 * <TokenName
 *   queryOptions={{
 *     enabled: isEnabled,
 *     retry: 4,
 *   }}
 * />
 * ```
 *
 * @component
 * @token
 * @beta
 */
export function TokenName({ nameResolver, formatFn, loadingComponent, fallbackComponent, queryOptions, ...restProps }) {
    const { address, client, chain } = useTokenContext();
    const nameQuery = useQuery({
        queryKey: getQueryKeys({ chainId: chain.id, nameResolver, address }),
        queryFn: async () => fetchTokenName({ address, chain, client, nameResolver }),
        ...queryOptions,
    });
    if (nameQuery.isLoading) {
        return loadingComponent || null;
    }
    if (!nameQuery.data) {
        return fallbackComponent || null;
    }
    if (formatFn && typeof formatFn === "function") {
        return _jsx("span", { ...restProps, children: formatFn(nameQuery.data) });
    }
    return _jsx("span", { ...restProps, children: nameQuery.data });
}
/**
 * @internal Exported for tests only
 */
export async function fetchTokenName(props) {
    const { nameResolver, address, client, chain } = props;
    if (typeof nameResolver === "string") {
        return nameResolver;
    }
    if (typeof nameResolver === "function") {
        return nameResolver();
    }
    if (address.toLowerCase() === NATIVE_TOKEN_ADDRESS.toLowerCase()) {
        // Don't wanna use `getChainName` because it has some side effect (it catches error and defaults to "ETH")
        return getChainMetadata(chain).then((data) => data.nativeCurrency.name);
    }
    // Try to fetch the name from both the `name` function and the contract metadata
    // then prioritize its result
    const contract = getContract({ address, client, chain });
    const [_name, contractMetadata] = await Promise.all([
        name({ contract }).catch(() => undefined),
        getContractMetadata({ contract }).catch(() => undefined),
    ]);
    if (typeof _name === "string") {
        return _name;
    }
    if (typeof contractMetadata?.name === "string") {
        return contractMetadata.name;
    }
    throw new Error("Failed to resolve name from both name() and contract metadata");
}
/**
 * @internal
 */
export function getQueryKeys(props) {
    const { chainId, address, nameResolver } = props;
    return [
        "_internal_token_name_",
        chainId,
        address,
        {
            resolver: typeof nameResolver === "string"
                ? nameResolver
                : typeof nameResolver === "function"
                    ? getFunctionId(nameResolver)
                    : undefined,
        },
    ];
}
//# sourceMappingURL=name.js.map