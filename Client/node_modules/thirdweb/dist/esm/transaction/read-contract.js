import { parseAbiItem, } from "abitype";
import { decodeAbiParameters } from "viem";
import { isAbiFunction } from "./utils.js";
import { eth_call } from "../rpc/actions/eth_call.js";
import { getRpcClient } from "../rpc/rpc.js";
import { encodeAbiParameters } from "../utils/abi/encodeAbiParameters.js";
import { prepareMethod, } from "../utils/abi/prepare-method.js";
import { getAddress } from "../utils/address.js";
/**
 * ### Reads state from a deployed smart contract.
 *
 * Use this for raw read calls from a contract, but you can also use read [extensions](https://portal.thirdweb.com/typescript/v5/extensions/use) for predefined methods for common standards.
 *
 * @param options - The transaction options.
 * @returns A promise that resolves with the result of the read call.
 * @transaction
 * @example
 *
 * ### Raw contract call (recommended)
 *
 * You can read from any contract by using the solidity signature of the function you want to call.
 *
 * ```ts
 * import { getContract } from "thirdweb";
 * import { sepolia } from "thirdweb/chains";
 * import { useReadContract } from "thirdweb/react";
 *
 * const contract = getContract({
 *   client,
 *   address: "0x...",
 *   chain: sepolia,
 * });
 *
 * const { data, isLoading } = useReadContract({
 *   contract,
 *   method: "function tokenURI(uint256 tokenId) returns (string)",
 *   params: [1n],
 * });
 * ```
 *
 * Note that this is type safe, the params types will be enforced based on the signature.
 *
 * ### Raw contract call with `resolveMethod`
 *
 * If you don't have the solidity signature of the function you want to call, you can use the `resolveMethod` helper to resolve the method from any deployed contract.
 *
 * Note that this is not type safe, and will also have a 1 time overhead of resolving the contract ABI.
 *
 * ```ts
 * import { getContract, resolveMethod } from "thirdweb";
 * import { sepolia } from "thirdweb/chains";
 * import { useReadContract } from "thirdweb/react";
 *
 * const contract = getContract({
 *   client,
 *   address: "0x...",
 *   chain: sepolia,
 * });
 *
 * const { data, isLoading } = useReadContract({
 *   contract,
 *   method: resolveMethod("tokenURI"),
 *   params: [1n],
 * });
 * ```
 */
export async function readContract(options) {
    const { contract, method, params } = options;
    const resolvePreparedMethod = async () => {
        if (Array.isArray(method)) {
            return method;
        }
        if (isAbiFunction(method)) {
            return prepareMethod(method);
        }
        if (typeof method === "function") {
            return prepareMethod(
            // @ts-expect-error - we're sure it's a function
            (await method(contract)));
        }
        // if the method starts with the string `function ` we always will want to try to parse it
        if (typeof method === "string" && method.startsWith("function ")) {
            // @ts-expect-error - method *is* string in this case
            const abiItem = parseAbiItem(method);
            if (abiItem.type === "function") {
                return prepareMethod(abiItem);
            }
            throw new Error(`"method" passed is not of type "function"`);
        }
        // check if we have a "abi" on the contract
        if (contract.abi && contract.abi?.length > 0) {
            // extract the abiFunction from it
            const abiFunction = contract.abi?.find((item) => item.type === "function" && item.name === method);
            // if we were able to find it -> return it
            if (abiFunction) {
                return prepareMethod(abiFunction);
            }
        }
        throw new Error(`Could not resolve method "${method}".`);
    };
    // resolve in parallel
    const [resolvedPreparedMethod, resolvedParams] = await Promise.all([
        resolvePreparedMethod(),
        typeof params === "function" ? params() : params,
    ]);
    let encodedData;
    // if we have no inputs, we know it's just the signature
    if (resolvedPreparedMethod[1].length === 0) {
        encodedData = resolvedPreparedMethod[0];
    }
    else {
        // we do a "manual" concat here to avoid the overhead of the "concatHex" function
        // we can do this because we know the specific formats of the values
        encodedData = (resolvedPreparedMethod[0] +
            encodeAbiParameters(resolvedPreparedMethod[1], 
            // @ts-expect-error - TODO: fix this type issue
            resolvedParams).slice(2));
    }
    const rpcRequest = getRpcClient({
        chain: contract.chain,
        client: contract.client,
    });
    const result = await eth_call(rpcRequest, {
        data: encodedData,
        to: contract.address,
        from: options.from ? getAddress(options.from) : undefined,
    });
    // use the prepared method to decode the result
    const decoded = decodeAbiParameters(resolvedPreparedMethod[2], result);
    if (Array.isArray(decoded) && decoded.length === 1) {
        return decoded[0];
    }
    return decoded;
}
//# sourceMappingURL=read-contract.js.map