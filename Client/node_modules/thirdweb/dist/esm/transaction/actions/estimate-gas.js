import * as ox__Hex from "ox/Hex";
import { formatTransactionRequest } from "viem";
import { roundUpGas } from "../../gas/op-gas-fee-reducer.js";
import { getAddress } from "../../utils/address.js";
import { resolvePromisedValue } from "../../utils/promise/resolve-promised-value.js";
import { extractError } from "../extract-error.js";
const cache = new WeakMap();
/**
 * Estimates the gas required to execute a transaction. The gas is returned as a `bigint` and in gwei units.
 * @param options - The options for estimating gas.
 * @returns A promise that resolves to the estimated gas as a bigint.
 * @transaction
 * @example
 * ```ts
 * import { estimateGas } from "thirdweb";
 * const gas = await estimateGas({
 *  transaction,
 *  from: "0x...",
 * });
 * ```
 */
export async function estimateGas(options) {
    // from is:
    // 1. the user specified from address
    // 2. the passed in account address
    // 3. the passed in wallet's account address
    const fromAddress = typeof options.from === "string"
        ? (options.from ?? undefined)
        : (options.from?.address ?? options.account?.address);
    const txWithFrom = { ...options.transaction, from: fromAddress };
    if (cache.has(txWithFrom)) {
        // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set
        return cache.get(txWithFrom);
    }
    const { account } = options;
    const promise = (async () => {
        const predefinedGas = await resolvePromisedValue(options.transaction.gas);
        // if we have a predefined gas value in the TX -> always use that
        if (predefinedGas !== undefined) {
            return predefinedGas;
        }
        // if the wallet itself overrides the estimateGas function, use that
        if (account?.estimateGas) {
            try {
                let gas = await account.estimateGas(options.transaction);
                if (options.transaction.chain.experimental?.increaseZeroByteCount) {
                    gas = roundUpGas(gas);
                }
                return gas;
            }
            catch (error) {
                throw await extractError({
                    error,
                    contract: options.transaction.__contract,
                });
            }
        }
        // load up encode function if we need it
        const { encode } = await import("./encode.js");
        const [encodedData, toAddress, value, authorizationList] = await Promise.all([
            encode(options.transaction),
            resolvePromisedValue(options.transaction.to),
            resolvePromisedValue(options.transaction.value),
            resolvePromisedValue(options.transaction.authorizationList),
        ]);
        // load up the rpc client and the estimateGas function if we need it
        const [{ getRpcClient }, { eth_estimateGas }] = await Promise.all([
            import("../../rpc/rpc.js"),
            import("../../rpc/actions/eth_estimateGas.js"),
        ]);
        const rpcRequest = getRpcClient(options.transaction);
        try {
            let gas = await eth_estimateGas(rpcRequest, formatTransactionRequest({
                to: toAddress ? getAddress(toAddress) : undefined,
                data: encodedData,
                from: fromAddress ? getAddress(fromAddress) : undefined,
                value,
                // TODO: Remove this casting when we migrate this file to Ox
                authorizationList: authorizationList?.map((auth) => ({
                    ...auth,
                    r: ox__Hex.fromNumber(auth.r),
                    s: ox__Hex.fromNumber(auth.s),
                    nonce: Number(auth.nonce),
                    contractAddress: getAddress(auth.address),
                })),
            }));
            if (options.transaction.chain.experimental?.increaseZeroByteCount) {
                gas = roundUpGas(gas);
            }
            return gas;
        }
        catch (error) {
            throw await extractError({
                error,
                contract: options.transaction.__contract,
            });
        }
    })();
    cache.set(txWithFrom, promise);
    return promise;
}
//# sourceMappingURL=estimate-gas.js.map