import {
  $e,
  Ee,
  Kr,
  Q,
  Tt,
  Ye,
  de,
  esm_exports,
  formatJsonRpcError,
  formatJsonRpcRequest,
  formatJsonRpcResult,
  import_pino,
  isHttpUrl,
  k,
  o,
  parseConnectionError,
  pr,
  qe,
  require_events,
  safeJsonParse,
  safeJsonStringify
} from "./chunk-WX53EMW6.js";
import "./chunk-TJPCO3UF.js";
import "./chunk-COI5HHKB.js";
import "./chunk-FUPOJN5U.js";
import "./chunk-HXWRQBIO.js";
import {
  __commonJS,
  __toESM
} from "./chunk-OS7ZSSJM.js";

// node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
    var __global__ = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof global !== "undefined" && global;
    var __globalThis__ = function() {
      function F2() {
        this.fetch = false;
        this.DOMException = __global__.DOMException;
      }
      F2.prototype = __global__;
      return new F2();
    }();
    (function(globalThis2) {
      var irrelevant = function(exports2) {
        var g4 = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
        typeof global !== "undefined" && global || {};
        var support = {
          searchParams: "URLSearchParams" in g4,
          iterable: "Symbol" in g4 && "iterator" in Symbol,
          blob: "FileReader" in g4 && "Blob" in g4 && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in g4,
          arrayBuffer: "ArrayBuffer" in g4
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
            throw new TypeError('Invalid character in header field name: "' + name + '"');
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              if (header.length != 2) {
                throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
              }
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body._noBody) return;
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
          var encoding = match ? match[1] : "utf-8";
          reader.readAsText(blob, encoding);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
              this._noBody = true;
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
          }
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              var isConsumed = consumed(this);
              if (isConsumed) {
                return isConsumed;
              } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                return Promise.resolve(
                  this._bodyArrayBuffer.buffer.slice(
                    this._bodyArrayBuffer.byteOffset,
                    this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                  )
                );
              } else {
                return Promise.resolve(this._bodyArrayBuffer);
              }
            } else if (support.blob) {
              return this.blob().then(readBlobAsArrayBuffer);
            } else {
              throw new Error("could not read as ArrayBuffer");
            }
          };
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          if (!(this instanceof Request)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal || function() {
            if ("AbortController" in g4) {
              var ctrl = new AbortController();
              return ctrl.signal;
            }
          }();
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options.cache === "no-store" || options.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
              }
            }
          }
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              try {
                headers.append(key, value);
              } catch (error) {
                console.warn("Response " + error.message);
              }
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!(this instanceof Response)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          if (this.status < 200 || this.status > 599) {
            throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
          }
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 200, statusText: "" });
          response.ok = false;
          response.status = 0;
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = g4.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch2(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
                options.status = 200;
              } else {
                options.status = xhr.status;
              }
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve(new Response(body, options));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request timed out"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url) {
              try {
                return url === "" && g4.location.href ? g4.location.href : url;
              } catch (e) {
                return url;
              }
            }
            xhr.open(request.method, fixUrl(request.url), true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init && typeof init.headers === "object" && !(init.headers instanceof Headers || g4.Headers && init.headers instanceof g4.Headers)) {
              var names = [];
              Object.getOwnPropertyNames(init.headers).forEach(function(name) {
                names.push(normalizeName(name));
                xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
              });
              request.headers.forEach(function(value, name) {
                if (names.indexOf(name) === -1) {
                  xhr.setRequestHeader(name, value);
                }
              });
            } else {
              request.headers.forEach(function(value, name) {
                xhr.setRequestHeader(name, value);
              });
            }
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!g4.fetch) {
          g4.fetch = fetch2;
          g4.Headers = Headers;
          g4.Request = Request;
          g4.Response = Response;
        }
        exports2.Headers = Headers;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch2;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      }({});
    })(__globalThis__);
    __globalThis__.fetch.ponyfill = true;
    delete __globalThis__.fetch.polyfill;
    var ctx = __global__.fetch ? __global__ : __globalThis__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  }
});

// node_modules/@walletconnect/ethereum-provider/dist/index.es.js
var import_events3 = __toESM(require_events());

// node_modules/@walletconnect/jsonrpc-http-connection/dist/index.es.js
var import_events = __toESM(require_events());
var import_cross_fetch = __toESM(require_browser_ponyfill());
var P = Object.defineProperty;
var w = Object.defineProperties;
var E = Object.getOwnPropertyDescriptors;
var c = Object.getOwnPropertySymbols;
var L = Object.prototype.hasOwnProperty;
var O = Object.prototype.propertyIsEnumerable;
var l = (r, t, e) => t in r ? P(r, t, { enumerable: true, configurable: true, writable: true, value: e }) : r[t] = e;
var p = (r, t) => {
  for (var e in t || (t = {})) L.call(t, e) && l(r, e, t[e]);
  if (c) for (var e of c(t)) O.call(t, e) && l(r, e, t[e]);
  return r;
};
var v = (r, t) => w(r, E(t));
var j = { Accept: "application/json", "Content-Type": "application/json" };
var T = "POST";
var d = { headers: j, method: T };
var g = 10;
var f = class {
  constructor(t, e = false) {
    if (this.url = t, this.disableProviderPing = e, this.events = new import_events.EventEmitter(), this.isAvailable = false, this.registering = false, !isHttpUrl(t)) throw new Error(`Provided URL is not compatible with HTTP connection: ${t}`);
    this.url = t, this.disableProviderPing = e;
  }
  get connected() {
    return this.isAvailable;
  }
  get connecting() {
    return this.registering;
  }
  on(t, e) {
    this.events.on(t, e);
  }
  once(t, e) {
    this.events.once(t, e);
  }
  off(t, e) {
    this.events.off(t, e);
  }
  removeListener(t, e) {
    this.events.removeListener(t, e);
  }
  async open(t = this.url) {
    await this.register(t);
  }
  async close() {
    if (!this.isAvailable) throw new Error("Connection already closed");
    this.onClose();
  }
  async send(t) {
    this.isAvailable || await this.register();
    try {
      const e = safeJsonStringify(t), s = await (await (0, import_cross_fetch.default)(this.url, v(p({}, d), { body: e }))).json();
      this.onPayload({ data: s });
    } catch (e) {
      this.onError(t.id, e);
    }
  }
  async register(t = this.url) {
    if (!isHttpUrl(t)) throw new Error(`Provided URL is not compatible with HTTP connection: ${t}`);
    if (this.registering) {
      const e = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= e || this.events.listenerCount("open") >= e) && this.events.setMaxListeners(e + 1), new Promise((s, i) => {
        this.events.once("register_error", (n) => {
          this.resetMaxListeners(), i(n);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.isAvailable > "u") return i(new Error("HTTP connection is missing or invalid"));
          s();
        });
      });
    }
    this.url = t, this.registering = true;
    try {
      if (!this.disableProviderPing) {
        const e = safeJsonStringify({ id: 1, jsonrpc: "2.0", method: "test", params: [] });
        await (0, import_cross_fetch.default)(t, v(p({}, d), { body: e }));
      }
      this.onOpen();
    } catch (e) {
      const s = this.parseError(e);
      throw this.events.emit("register_error", s), this.onClose(), s;
    }
  }
  onOpen() {
    this.isAvailable = true, this.registering = false, this.events.emit("open");
  }
  onClose() {
    this.isAvailable = false, this.registering = false, this.events.emit("close");
  }
  onPayload(t) {
    if (typeof t.data > "u") return;
    const e = typeof t.data == "string" ? safeJsonParse(t.data) : t.data;
    this.events.emit("payload", e);
  }
  onError(t, e) {
    const s = this.parseError(e), i = s.message || s.toString(), n = formatJsonRpcError(t, i);
    this.events.emit("payload", n);
  }
  parseError(t, e = this.url) {
    return parseConnectionError(t, e, "HTTP");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > g && this.events.setMaxListeners(g);
  }
};

// node_modules/@walletconnect/universal-provider/dist/index.es.js
var import_events2 = __toESM(require_events());
var tt = "error";
var Nt = "wss://relay.walletconnect.org";
var St = "wc";
var Dt = "universal_provider";
var _ = `${St}@2:${Dt}:`;
var et = "https://rpc.walletconnect.org/v1/";
var w2 = "generic";
var qt = `${et}bundler`;
var d2 = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
function jt() {
}
function B(s) {
  return s == null || typeof s != "object" && typeof s != "function";
}
function G(s) {
  return ArrayBuffer.isView(s) && !(s instanceof DataView);
}
function Rt(s) {
  if (B(s)) return s;
  if (Array.isArray(s) || G(s) || s instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && s instanceof SharedArrayBuffer) return s.slice(0);
  const t = Object.getPrototypeOf(s), e = t.constructor;
  if (s instanceof Date || s instanceof Map || s instanceof Set) return new e(s);
  if (s instanceof RegExp) {
    const i = new e(s);
    return i.lastIndex = s.lastIndex, i;
  }
  if (s instanceof DataView) return new e(s.buffer.slice(0));
  if (s instanceof Error) {
    const i = new e(s.message);
    return i.stack = s.stack, i.name = s.name, i.cause = s.cause, i;
  }
  if (typeof File < "u" && s instanceof File) return new e([s], s.name, { type: s.type, lastModified: s.lastModified });
  if (typeof s == "object") {
    const i = Object.create(t);
    return Object.assign(i, s);
  }
  return s;
}
function st(s) {
  return typeof s == "object" && s !== null;
}
function it(s) {
  return Object.getOwnPropertySymbols(s).filter((t) => Object.prototype.propertyIsEnumerable.call(s, t));
}
function rt(s) {
  return s == null ? s === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(s);
}
var _t = "[object RegExp]";
var nt = "[object String]";
var at = "[object Number]";
var ct = "[object Boolean]";
var ot = "[object Arguments]";
var Ut = "[object Symbol]";
var Ft = "[object Date]";
var Lt = "[object Map]";
var xt = "[object Set]";
var Mt = "[object Array]";
var Bt = "[object ArrayBuffer]";
var Gt = "[object Object]";
var Jt = "[object DataView]";
var zt = "[object Uint8Array]";
var kt = "[object Uint8ClampedArray]";
var Wt = "[object Uint16Array]";
var Kt = "[object Uint32Array]";
var Vt = "[object Int8Array]";
var Xt = "[object Int16Array]";
var Yt = "[object Int32Array]";
var Qt = "[object Float32Array]";
var Zt = "[object Float64Array]";
function Tt2(s, t) {
  return y(s, void 0, s, /* @__PURE__ */ new Map(), t);
}
function y(s, t, e, i = /* @__PURE__ */ new Map(), r = void 0) {
  const a = r == null ? void 0 : r(s, t, e, i);
  if (a != null) return a;
  if (B(s)) return s;
  if (i.has(s)) return i.get(s);
  if (Array.isArray(s)) {
    const n = new Array(s.length);
    i.set(s, n);
    for (let c2 = 0; c2 < s.length; c2++) n[c2] = y(s[c2], c2, e, i, r);
    return Object.hasOwn(s, "index") && (n.index = s.index), Object.hasOwn(s, "input") && (n.input = s.input), n;
  }
  if (s instanceof Date) return new Date(s.getTime());
  if (s instanceof RegExp) {
    const n = new RegExp(s.source, s.flags);
    return n.lastIndex = s.lastIndex, n;
  }
  if (s instanceof Map) {
    const n = /* @__PURE__ */ new Map();
    i.set(s, n);
    for (const [c2, h] of s) n.set(c2, y(h, c2, e, i, r));
    return n;
  }
  if (s instanceof Set) {
    const n = /* @__PURE__ */ new Set();
    i.set(s, n);
    for (const c2 of s) n.add(y(c2, void 0, e, i, r));
    return n;
  }
  if (typeof Buffer < "u" && Buffer.isBuffer(s)) return s.subarray();
  if (G(s)) {
    const n = new (Object.getPrototypeOf(s)).constructor(s.length);
    i.set(s, n);
    for (let c2 = 0; c2 < s.length; c2++) n[c2] = y(s[c2], c2, e, i, r);
    return n;
  }
  if (s instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && s instanceof SharedArrayBuffer) return s.slice(0);
  if (s instanceof DataView) {
    const n = new DataView(s.buffer.slice(0), s.byteOffset, s.byteLength);
    return i.set(s, n), g2(n, s, e, i, r), n;
  }
  if (typeof File < "u" && s instanceof File) {
    const n = new File([s], s.name, { type: s.type });
    return i.set(s, n), g2(n, s, e, i, r), n;
  }
  if (s instanceof Blob) {
    const n = new Blob([s], { type: s.type });
    return i.set(s, n), g2(n, s, e, i, r), n;
  }
  if (s instanceof Error) {
    const n = new s.constructor();
    return i.set(s, n), n.message = s.message, n.name = s.name, n.stack = s.stack, n.cause = s.cause, g2(n, s, e, i, r), n;
  }
  if (typeof s == "object" && te(s)) {
    const n = Object.create(Object.getPrototypeOf(s));
    return i.set(s, n), g2(n, s, e, i, r), n;
  }
  return s;
}
function g2(s, t, e = s, i, r) {
  const a = [...Object.keys(t), ...it(t)];
  for (let n = 0; n < a.length; n++) {
    const c2 = a[n], h = Object.getOwnPropertyDescriptor(s, c2);
    (h == null || h.writable) && (s[c2] = y(t[c2], c2, e, i, r));
  }
}
function te(s) {
  switch (rt(s)) {
    case ot:
    case Mt:
    case Bt:
    case Jt:
    case ct:
    case Ft:
    case Qt:
    case Zt:
    case Vt:
    case Xt:
    case Yt:
    case Lt:
    case at:
    case Gt:
    case _t:
    case xt:
    case nt:
    case Ut:
    case zt:
    case kt:
    case Wt:
    case Kt:
      return true;
    default:
      return false;
  }
}
function ee(s, t) {
  return Tt2(s, (e, i, r, a) => {
    const n = t == null ? void 0 : t(e, i, r, a);
    if (n != null) return n;
    if (typeof s == "object") switch (Object.prototype.toString.call(s)) {
      case at:
      case nt:
      case ct: {
        const c2 = new s.constructor(s == null ? void 0 : s.valueOf());
        return g2(c2, s), c2;
      }
      case ot: {
        const c2 = {};
        return g2(c2, s), c2.length = s.length, c2[Symbol.iterator] = s[Symbol.iterator], c2;
      }
      default:
        return;
    }
  });
}
function ht(s) {
  return ee(s);
}
function pt(s) {
  return s !== null && typeof s == "object" && rt(s) === "[object Arguments]";
}
function se(s) {
  return G(s);
}
function ie(s) {
  var _a;
  if (typeof s != "object" || s == null) return false;
  if (Object.getPrototypeOf(s) === null) return true;
  if (Object.prototype.toString.call(s) !== "[object Object]") {
    const e = s[Symbol.toStringTag];
    return e == null || !((_a = Object.getOwnPropertyDescriptor(s, Symbol.toStringTag)) == null ? void 0 : _a.writable) ? false : s.toString() === `[object ${e}]`;
  }
  let t = s;
  for (; Object.getPrototypeOf(t) !== null; ) t = Object.getPrototypeOf(t);
  return Object.getPrototypeOf(s) === t;
}
function re(s, ...t) {
  const e = t.slice(0, -1), i = t[t.length - 1];
  let r = s;
  for (let a = 0; a < e.length; a++) {
    const n = e[a];
    r = U2(r, n, i, /* @__PURE__ */ new Map());
  }
  return r;
}
function U2(s, t, e, i) {
  if (B(s) && (s = Object(s)), t == null || typeof t != "object") return s;
  if (i.has(t)) return Rt(i.get(t));
  if (i.set(t, s), Array.isArray(t)) {
    t = t.slice();
    for (let a = 0; a < t.length; a++) t[a] = t[a] ?? void 0;
  }
  const r = [...Object.keys(t), ...it(t)];
  for (let a = 0; a < r.length; a++) {
    const n = r[a];
    let c2 = t[n], h = s[n];
    if (pt(c2) && (c2 = { ...c2 }), pt(h) && (h = { ...h }), typeof Buffer < "u" && Buffer.isBuffer(c2) && (c2 = ht(c2)), Array.isArray(c2)) if (typeof h == "object" && h != null) {
      const j3 = [], R = Reflect.ownKeys(h);
      for (let f2 = 0; f2 < R.length; f2++) {
        const X = R[f2];
        j3[X] = h[X];
      }
      h = j3;
    } else h = [];
    const v3 = e(h, c2, n, s, t, i);
    v3 != null ? s[n] = v3 : Array.isArray(c2) || st(h) && st(c2) ? s[n] = U2(h, c2, e, i) : h == null && ie(c2) ? s[n] = U2({}, c2, e, i) : h == null && se(c2) ? s[n] = ht(c2) : (h === void 0 || c2 !== void 0) && (s[n] = c2);
  }
  return s;
}
function ne(s, ...t) {
  return re(s, ...t, jt);
}
var ae = Object.defineProperty;
var ce = Object.defineProperties;
var oe = Object.getOwnPropertyDescriptors;
var dt = Object.getOwnPropertySymbols;
var he = Object.prototype.hasOwnProperty;
var pe = Object.prototype.propertyIsEnumerable;
var ut = (s, t, e) => t in s ? ae(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var F = (s, t) => {
  for (var e in t || (t = {})) he.call(t, e) && ut(s, e, t[e]);
  if (dt) for (var e of dt(t)) pe.call(t, e) && ut(s, e, t[e]);
  return s;
};
var de2 = (s, t) => ce(s, oe(t));
function p2(s, t, e) {
  var i;
  const r = Ye(s);
  return ((i = t.rpcMap) == null ? void 0 : i[r.reference]) || `${et}?chainId=${r.namespace}:${r.reference}&projectId=${e}`;
}
function P2(s) {
  return s.includes(":") ? s.split(":")[1] : s;
}
function lt(s) {
  return s.map((t) => `${t.split(":")[0]}:${t.split(":")[1]}`);
}
function ue(s, t) {
  const e = Object.keys(t.namespaces).filter((r) => r.includes(s));
  if (!e.length) return [];
  const i = [];
  return e.forEach((r) => {
    const a = t.namespaces[r].accounts;
    i.push(...a);
  }), i;
}
function J(s = {}, t = {}) {
  const e = ft(s), i = ft(t);
  return ne(e, i);
}
function ft(s) {
  var t, e, i, r;
  const a = {};
  if (!qe(s)) return a;
  for (const [n, c2] of Object.entries(s)) {
    const h = Tt(n) ? [n] : c2.chains, v3 = c2.methods || [], j3 = c2.events || [], R = c2.rpcMap || {}, f2 = pr(n);
    a[f2] = de2(F(F({}, a[f2]), c2), { chains: Q(h, (t = a[f2]) == null ? void 0 : t.chains), methods: Q(v3, (e = a[f2]) == null ? void 0 : e.methods), events: Q(j3, (i = a[f2]) == null ? void 0 : i.events), rpcMap: F(F({}, R), (r = a[f2]) == null ? void 0 : r.rpcMap) });
  }
  return a;
}
function le(s) {
  return s.includes(":") ? s.split(":")[2] : s;
}
function mt(s) {
  const t = {};
  for (const [e, i] of Object.entries(s)) {
    const r = i.methods || [], a = i.events || [], n = i.accounts || [], c2 = Tt(e) ? [e] : i.chains ? i.chains : lt(i.accounts);
    t[e] = { chains: c2, methods: r, events: a, accounts: n };
  }
  return t;
}
function z(s) {
  return typeof s == "number" ? s : s.includes("0x") ? parseInt(s, 16) : (s = s.includes(":") ? s.split(":")[1] : s, isNaN(Number(s)) ? s : Number(s));
}
var vt = {};
var o3 = (s) => vt[s];
var k2 = (s, t) => {
  vt[s] = t;
};
var fe = Object.defineProperty;
var me = (s, t, e) => t in s ? fe(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var b = (s, t, e) => me(s, typeof t != "symbol" ? t + "" : t, e);
var ve = class {
  constructor(t) {
    b(this, "name", "polkadot"), b(this, "client"), b(this, "httpProviders"), b(this, "events"), b(this, "namespace"), b(this, "chainId"), this.namespace = t.namespace, this.events = o3("events"), this.client = o3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d2.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i;
      const r = P2(e);
      t[r] = this.createHttpProvider(r, (i = this.namespace.rpcMap) == null ? void 0 : i[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i = this.createHttpProvider(t, e);
    i && (this.httpProviders[t] = i);
  }
  createHttpProvider(t, e) {
    const i = e || p2(t, this.namespace, this.client.core.projectId);
    if (!i) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f(i, o3("disableProviderPing")));
  }
};
var ge = Object.defineProperty;
var Pe = Object.defineProperties;
var we = Object.getOwnPropertyDescriptors;
var gt = Object.getOwnPropertySymbols;
var ye = Object.prototype.hasOwnProperty;
var be = Object.prototype.propertyIsEnumerable;
var W = (s, t, e) => t in s ? ge(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var Pt = (s, t) => {
  for (var e in t || (t = {})) ye.call(t, e) && W(s, e, t[e]);
  if (gt) for (var e of gt(t)) be.call(t, e) && W(s, e, t[e]);
  return s;
};
var wt = (s, t) => Pe(s, we(t));
var I = (s, t, e) => W(s, typeof t != "symbol" ? t + "" : t, e);
var Ie = class {
  constructor(t) {
    I(this, "name", "eip155"), I(this, "client"), I(this, "chainId"), I(this, "namespace"), I(this, "httpProviders"), I(this, "events"), this.namespace = t.namespace, this.events = o3("events"), this.client = o3("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());
  }
  async request(t) {
    switch (t.request.method) {
      case "eth_requestAccounts":
        return this.getAccounts();
      case "eth_accounts":
        return this.getAccounts();
      case "wallet_switchEthereumChain":
        return await this.handleSwitchChain(t);
      case "eth_chainId":
        return parseInt(this.getDefaultChain());
      case "wallet_getCapabilities":
        return await this.getCapabilities(t);
      case "wallet_getCallsStatus":
        return await this.getCallStatus(t);
    }
    return this.namespace.methods.includes(t.request.method) ? await this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(parseInt(t), e), this.chainId = parseInt(t), this.events.emit(d2.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId.toString();
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  createHttpProvider(t, e) {
    const i = e || p2(`${this.name}:${t}`, this.namespace, this.client.core.projectId);
    if (!i) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f(i, o3("disableProviderPing")));
  }
  setHttpProvider(t, e) {
    const i = this.createHttpProvider(t, e);
    i && (this.httpProviders[t] = i);
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i;
      const r = parseInt(P2(e));
      t[r] = this.createHttpProvider(r, (i = this.namespace.rpcMap) == null ? void 0 : i[e]);
    }), t;
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  getHttpProvider() {
    const t = this.chainId, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  async handleSwitchChain(t) {
    var e, i;
    let r = t.request.params ? (e = t.request.params[0]) == null ? void 0 : e.chainId : "0x0";
    r = r.startsWith("0x") ? r : `0x${r}`;
    const a = parseInt(r, 16);
    if (this.isChainApproved(a)) this.setDefaultChain(`${a}`);
    else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({ topic: t.topic, request: { method: t.request.method, params: [{ chainId: r }] }, chainId: (i = this.namespace.chains) == null ? void 0 : i[0] }), this.setDefaultChain(`${a}`);
    else throw new Error(`Failed to switch to chain 'eip155:${a}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
    return null;
  }
  isChainApproved(t) {
    return this.namespace.chains.includes(`${this.name}:${t}`);
  }
  async getCapabilities(t) {
    var e, i, r;
    const a = (i = (e = t.request) == null ? void 0 : e.params) == null ? void 0 : i[0];
    if (!a) throw new Error("Missing address parameter in `wallet_getCapabilities` request");
    const n = this.client.session.get(t.topic), c2 = ((r = n == null ? void 0 : n.sessionProperties) == null ? void 0 : r.capabilities) || {};
    if (c2 != null && c2[a]) return c2 == null ? void 0 : c2[a];
    const h = await this.client.request(t);
    try {
      await this.client.session.update(t.topic, { sessionProperties: wt(Pt({}, n.sessionProperties || {}), { capabilities: wt(Pt({}, c2 || {}), { [a]: h }) }) });
    } catch (v3) {
      console.warn("Failed to update session with capabilities", v3);
    }
    return h;
  }
  async getCallStatus(t) {
    var e, i;
    const r = this.client.session.get(t.topic), a = (e = r.sessionProperties) == null ? void 0 : e.bundler_name;
    if (a) {
      const c2 = this.getBundlerUrl(t.chainId, a);
      try {
        return await this.getUserOperationReceipt(c2, t);
      } catch (h) {
        console.warn("Failed to fetch call status from bundler", h, c2);
      }
    }
    const n = (i = r.sessionProperties) == null ? void 0 : i.bundler_url;
    if (n) try {
      return await this.getUserOperationReceipt(n, t);
    } catch (c2) {
      console.warn("Failed to fetch call status from custom bundler", c2, n);
    }
    if (this.namespace.methods.includes(t.request.method)) return await this.client.request(t);
    throw new Error("Fetching call status not approved by the wallet.");
  }
  async getUserOperationReceipt(t, e) {
    var i;
    const r = new URL(t), a = await fetch(r, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(formatJsonRpcRequest("eth_getUserOperationReceipt", [(i = e.request.params) == null ? void 0 : i[0]])) });
    if (!a.ok) throw new Error(`Failed to fetch user operation receipt - ${a.status}`);
    return await a.json();
  }
  getBundlerUrl(t, e) {
    return `${qt}?projectId=${this.client.core.projectId}&chainId=${t}&bundler=${e}`;
  }
};
var $e2 = Object.defineProperty;
var Oe = (s, t, e) => t in s ? $e2(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var $ = (s, t, e) => Oe(s, typeof t != "symbol" ? t + "" : t, e);
var Ae = class {
  constructor(t) {
    $(this, "name", "solana"), $(this, "client"), $(this, "httpProviders"), $(this, "events"), $(this, "namespace"), $(this, "chainId"), this.namespace = t.namespace, this.events = o3("events"), this.client = o3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d2.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i;
      const r = P2(e);
      t[r] = this.createHttpProvider(r, (i = this.namespace.rpcMap) == null ? void 0 : i[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i = this.createHttpProvider(t, e);
    i && (this.httpProviders[t] = i);
  }
  createHttpProvider(t, e) {
    const i = e || p2(t, this.namespace, this.client.core.projectId);
    if (!i) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f(i, o3("disableProviderPing")));
  }
};
var He = Object.defineProperty;
var Ee2 = (s, t, e) => t in s ? He(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var O2 = (s, t, e) => Ee2(s, typeof t != "symbol" ? t + "" : t, e);
var Ce = class {
  constructor(t) {
    O2(this, "name", "cosmos"), O2(this, "client"), O2(this, "httpProviders"), O2(this, "events"), O2(this, "namespace"), O2(this, "chainId"), this.namespace = t.namespace, this.events = o3("events"), this.client = o3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i;
      const r = P2(e);
      t[r] = this.createHttpProvider(r, (i = this.namespace.rpcMap) == null ? void 0 : i[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i = this.createHttpProvider(t, e);
    i && (this.httpProviders[t] = i);
  }
  createHttpProvider(t, e) {
    const i = e || p2(t, this.namespace, this.client.core.projectId);
    if (!i) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f(i, o3("disableProviderPing")));
  }
};
var Ne = Object.defineProperty;
var Se = (s, t, e) => t in s ? Ne(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var A = (s, t, e) => Se(s, typeof t != "symbol" ? t + "" : t, e);
var De = class {
  constructor(t) {
    A(this, "name", "algorand"), A(this, "client"), A(this, "httpProviders"), A(this, "events"), A(this, "namespace"), A(this, "chainId"), this.namespace = t.namespace, this.events = o3("events"), this.client = o3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    if (!this.httpProviders[t]) {
      const i = e || p2(`${this.name}:${t}`, this.namespace, this.client.core.projectId);
      if (!i) throw new Error(`No RPC url provided for chainId: ${t}`);
      this.setHttpProvider(t, i);
    }
    this.chainId = t, this.events.emit(d2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i;
      t[e] = this.createHttpProvider(e, (i = this.namespace.rpcMap) == null ? void 0 : i[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i = this.createHttpProvider(t, e);
    i && (this.httpProviders[t] = i);
  }
  createHttpProvider(t, e) {
    const i = e || p2(t, this.namespace, this.client.core.projectId);
    return typeof i > "u" ? void 0 : new o(new f(i, o3("disableProviderPing")));
  }
};
var qe2 = Object.defineProperty;
var je = (s, t, e) => t in s ? qe2(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var H = (s, t, e) => je(s, typeof t != "symbol" ? t + "" : t, e);
var Re = class {
  constructor(t) {
    H(this, "name", "cip34"), H(this, "client"), H(this, "httpProviders"), H(this, "events"), H(this, "namespace"), H(this, "chainId"), this.namespace = t.namespace, this.events = o3("events"), this.client = o3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      const i = this.getCardanoRPCUrl(e), r = P2(e);
      t[r] = this.createHttpProvider(r, i);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  getCardanoRPCUrl(t) {
    const e = this.namespace.rpcMap;
    if (e) return e[t];
  }
  setHttpProvider(t, e) {
    const i = this.createHttpProvider(t, e);
    i && (this.httpProviders[t] = i);
  }
  createHttpProvider(t, e) {
    const i = e || this.getCardanoRPCUrl(t);
    if (!i) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f(i, o3("disableProviderPing")));
  }
};
var _e = Object.defineProperty;
var Ue = (s, t, e) => t in s ? _e(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var E2 = (s, t, e) => Ue(s, typeof t != "symbol" ? t + "" : t, e);
var Fe = class {
  constructor(t) {
    E2(this, "name", "elrond"), E2(this, "client"), E2(this, "httpProviders"), E2(this, "events"), E2(this, "namespace"), E2(this, "chainId"), this.namespace = t.namespace, this.events = o3("events"), this.client = o3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d2.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i;
      const r = P2(e);
      t[r] = this.createHttpProvider(r, (i = this.namespace.rpcMap) == null ? void 0 : i[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i = this.createHttpProvider(t, e);
    i && (this.httpProviders[t] = i);
  }
  createHttpProvider(t, e) {
    const i = e || p2(t, this.namespace, this.client.core.projectId);
    if (!i) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f(i, o3("disableProviderPing")));
  }
};
var Le = Object.defineProperty;
var xe = (s, t, e) => t in s ? Le(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var C = (s, t, e) => xe(s, typeof t != "symbol" ? t + "" : t, e);
var Me = class {
  constructor(t) {
    C(this, "name", "multiversx"), C(this, "client"), C(this, "httpProviders"), C(this, "events"), C(this, "namespace"), C(this, "chainId"), this.namespace = t.namespace, this.events = o3("events"), this.client = o3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d2.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i;
      const r = P2(e);
      t[r] = this.createHttpProvider(r, (i = this.namespace.rpcMap) == null ? void 0 : i[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i = this.createHttpProvider(t, e);
    i && (this.httpProviders[t] = i);
  }
  createHttpProvider(t, e) {
    const i = e || p2(t, this.namespace, this.client.core.projectId);
    if (!i) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f(i, o3("disableProviderPing")));
  }
};
var Be = Object.defineProperty;
var Ge = (s, t, e) => t in s ? Be(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var N = (s, t, e) => Ge(s, typeof t != "symbol" ? t + "" : t, e);
var Je = class {
  constructor(t) {
    N(this, "name", "near"), N(this, "client"), N(this, "httpProviders"), N(this, "events"), N(this, "namespace"), N(this, "chainId"), this.namespace = t.namespace, this.events = o3("events"), this.client = o3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    if (this.chainId = t, !this.httpProviders[t]) {
      const i = e || p2(`${this.name}:${t}`, this.namespace);
      if (!i) throw new Error(`No RPC url provided for chainId: ${t}`);
      this.setHttpProvider(t, i);
    }
    this.events.emit(d2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i;
      t[e] = this.createHttpProvider(e, (i = this.namespace.rpcMap) == null ? void 0 : i[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i = this.createHttpProvider(t, e);
    i && (this.httpProviders[t] = i);
  }
  createHttpProvider(t, e) {
    const i = e || p2(t, this.namespace);
    return typeof i > "u" ? void 0 : new o(new f(i, o3("disableProviderPing")));
  }
};
var ze = Object.defineProperty;
var ke = (s, t, e) => t in s ? ze(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var S = (s, t, e) => ke(s, typeof t != "symbol" ? t + "" : t, e);
var We = class {
  constructor(t) {
    S(this, "name", "tezos"), S(this, "client"), S(this, "httpProviders"), S(this, "events"), S(this, "namespace"), S(this, "chainId"), this.namespace = t.namespace, this.events = o3("events"), this.client = o3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    if (this.chainId = t, !this.httpProviders[t]) {
      const i = e || p2(`${this.name}:${t}`, this.namespace);
      if (!i) throw new Error(`No RPC url provided for chainId: ${t}`);
      this.setHttpProvider(t, i);
    }
    this.events.emit(d2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      t[e] = this.createHttpProvider(e);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i = this.createHttpProvider(t, e);
    i && (this.httpProviders[t] = i);
  }
  createHttpProvider(t, e) {
    const i = e || p2(t, this.namespace);
    return typeof i > "u" ? void 0 : new o(new f(i));
  }
};
var Ke = Object.defineProperty;
var Ve = (s, t, e) => t in s ? Ke(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var D = (s, t, e) => Ve(s, typeof t != "symbol" ? t + "" : t, e);
var Xe = class {
  constructor(t) {
    D(this, "name", w2), D(this, "client"), D(this, "httpProviders"), D(this, "events"), D(this, "namespace"), D(this, "chainId"), this.namespace = t.namespace, this.events = o3("events"), this.client = o3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace.chains = [...new Set((this.namespace.chains || []).concat(t.chains || []))], this.namespace.accounts = [...new Set((this.namespace.accounts || []).concat(t.accounts || []))], this.namespace.methods = [...new Set((this.namespace.methods || []).concat(t.methods || []))], this.namespace.events = [...new Set((this.namespace.events || []).concat(t.events || []))], this.httpProviders = this.createHttpProviders();
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider(t.chainId).request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d2.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    var t, e;
    const i = {};
    return (e = (t = this.namespace) == null ? void 0 : t.accounts) == null || e.forEach((r) => {
      const a = Ye(r);
      i[`${a.namespace}:${a.reference}`] = this.createHttpProvider(r);
    }), i;
  }
  getHttpProvider(t) {
    const e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i = this.createHttpProvider(t, e);
    i && (this.httpProviders[t] = i);
  }
  createHttpProvider(t, e) {
    const i = e || p2(t, this.namespace, this.client.core.projectId);
    if (!i) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f(i, o3("disableProviderPing")));
  }
};
var Ye2 = Object.defineProperty;
var Qe = Object.defineProperties;
var Ze = Object.getOwnPropertyDescriptors;
var yt = Object.getOwnPropertySymbols;
var Te = Object.prototype.hasOwnProperty;
var ts = Object.prototype.propertyIsEnumerable;
var K = (s, t, e) => t in s ? Ye2(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var L2 = (s, t) => {
  for (var e in t || (t = {})) Te.call(t, e) && K(s, e, t[e]);
  if (yt) for (var e of yt(t)) ts.call(t, e) && K(s, e, t[e]);
  return s;
};
var V = (s, t) => Qe(s, Ze(t));
var u = (s, t, e) => K(s, typeof t != "symbol" ? t + "" : t, e);
var x = class _x {
  constructor(t) {
    u(this, "client"), u(this, "namespaces"), u(this, "optionalNamespaces"), u(this, "sessionProperties"), u(this, "scopedProperties"), u(this, "events", new import_events2.default()), u(this, "rpcProviders", {}), u(this, "session"), u(this, "providerOpts"), u(this, "logger"), u(this, "uri"), u(this, "disableProviderPing", false), this.providerOpts = t, this.logger = typeof (t == null ? void 0 : t.logger) < "u" && typeof (t == null ? void 0 : t.logger) != "string" ? t.logger : (0, import_pino.default)(k({ level: (t == null ? void 0 : t.logger) || tt })), this.disableProviderPing = (t == null ? void 0 : t.disableProviderPing) || false;
  }
  static async init(t) {
    const e = new _x(t);
    return await e.initialize(), e;
  }
  async request(t, e, i) {
    const [r, a] = this.validateChain(e);
    if (!this.session) throw new Error("Please call connect() before request()");
    return await this.getProvider(r).request({ request: L2({}, t), chainId: `${r}:${a}`, topic: this.session.topic, expiry: i });
  }
  sendAsync(t, e, i, r) {
    const a = (/* @__PURE__ */ new Date()).getTime();
    this.request(t, i, r).then((n) => e(null, formatJsonRpcResult(a, n))).catch((n) => e(n, void 0));
  }
  async enable() {
    if (!this.client) throw new Error("Sign Client not initialized");
    return this.session || await this.connect({ namespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties, scopedProperties: this.scopedProperties }), await this.requestAccounts();
  }
  async disconnect() {
    var t;
    if (!this.session) throw new Error("Please call connect() before enable()");
    await this.client.disconnect({ topic: (t = this.session) == null ? void 0 : t.topic, reason: de("USER_DISCONNECTED") }), await this.cleanup();
  }
  async connect(t) {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (this.setNamespaces(t), await this.cleanupPendingPairings(), !t.skipPairing) return await this.pair(t.pairingTopic);
  }
  async authenticate(t, e) {
    if (!this.client) throw new Error("Sign Client not initialized");
    this.setNamespaces(t), await this.cleanupPendingPairings();
    const { uri: i, response: r } = await this.client.authenticate(t, e);
    i && (this.uri = i, this.events.emit("display_uri", i));
    const a = await r();
    if (this.session = a.session, this.session) {
      const n = mt(this.session.namespaces);
      this.namespaces = J(this.namespaces, n), await this.persist("namespaces", this.namespaces), this.onConnect();
    }
    return a;
  }
  on(t, e) {
    this.events.on(t, e);
  }
  once(t, e) {
    this.events.once(t, e);
  }
  removeListener(t, e) {
    this.events.removeListener(t, e);
  }
  off(t, e) {
    this.events.off(t, e);
  }
  get isWalletConnect() {
    return true;
  }
  async pair(t) {
    const { uri: e, approval: i } = await this.client.connect({ pairingTopic: t, requiredNamespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties, scopedProperties: this.scopedProperties });
    e && (this.uri = e, this.events.emit("display_uri", e));
    const r = await i();
    this.session = r;
    const a = mt(r.namespaces);
    return this.namespaces = J(this.namespaces, a), await this.persist("namespaces", this.namespaces), await this.persist("optionalNamespaces", this.optionalNamespaces), this.onConnect(), this.session;
  }
  setDefaultChain(t, e) {
    try {
      if (!this.session) return;
      const [i, r] = this.validateChain(t), a = this.getProvider(i);
      a.name === w2 ? a.setDefaultChain(`${i}:${r}`, e) : a.setDefaultChain(r, e);
    } catch (i) {
      if (!/Please call connect/.test(i.message)) throw i;
    }
  }
  async cleanupPendingPairings(t = {}) {
    this.logger.info("Cleaning up inactive pairings...");
    const e = this.client.pairing.getAll();
    if ($e(e)) {
      for (const i of e) t.deletePairings ? this.client.core.expirer.set(i.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(i.topic);
      this.logger.info(`Inactive pairings cleared: ${e.length}`);
    }
  }
  abortPairingAttempt() {
    this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.");
  }
  async checkStorage() {
    this.namespaces = await this.getFromStore("namespaces") || {}, this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.session && this.createProviders();
  }
  async initialize() {
    this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
  }
  async createClient() {
    var t, e;
    if (this.client = this.providerOpts.client || await Ee.init({ core: this.providerOpts.core, logger: this.providerOpts.logger || tt, relayUrl: this.providerOpts.relayUrl || Nt, projectId: this.providerOpts.projectId, metadata: this.providerOpts.metadata, storageOptions: this.providerOpts.storageOptions, storage: this.providerOpts.storage, name: this.providerOpts.name, customStoragePrefix: this.providerOpts.customStoragePrefix, telemetryEnabled: this.providerOpts.telemetryEnabled }), this.providerOpts.session) try {
      this.session = this.client.session.get(this.providerOpts.session.topic);
    } catch (i) {
      throw this.logger.error("Failed to get session", i), new Error(`The provided session: ${(e = (t = this.providerOpts) == null ? void 0 : t.session) == null ? void 0 : e.topic} doesn't exist in the Sign client`);
    }
    else {
      const i = this.client.session.getAll();
      this.session = i[0];
    }
    this.logger.trace("SignClient Initialized");
  }
  createProviders() {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (!this.session) throw new Error("Session not initialized. Please call connect() before enable()");
    const t = [...new Set(Object.keys(this.session.namespaces).map((e) => pr(e)))];
    k2("client", this.client), k2("events", this.events), k2("disableProviderPing", this.disableProviderPing), t.forEach((e) => {
      if (!this.session) return;
      const i = ue(e, this.session), r = lt(i), a = J(this.namespaces, this.optionalNamespaces), n = V(L2({}, a[e]), { accounts: i, chains: r });
      switch (e) {
        case "eip155":
          this.rpcProviders[e] = new Ie({ namespace: n });
          break;
        case "algorand":
          this.rpcProviders[e] = new De({ namespace: n });
          break;
        case "solana":
          this.rpcProviders[e] = new Ae({ namespace: n });
          break;
        case "cosmos":
          this.rpcProviders[e] = new Ce({ namespace: n });
          break;
        case "polkadot":
          this.rpcProviders[e] = new ve({ namespace: n });
          break;
        case "cip34":
          this.rpcProviders[e] = new Re({ namespace: n });
          break;
        case "elrond":
          this.rpcProviders[e] = new Fe({ namespace: n });
          break;
        case "multiversx":
          this.rpcProviders[e] = new Me({ namespace: n });
          break;
        case "near":
          this.rpcProviders[e] = new Je({ namespace: n });
          break;
        case "tezos":
          this.rpcProviders[e] = new We({ namespace: n });
          break;
        default:
          this.rpcProviders[w2] ? this.rpcProviders[w2].updateNamespace(n) : this.rpcProviders[w2] = new Xe({ namespace: n });
      }
    });
  }
  registerEventListeners() {
    if (typeof this.client > "u") throw new Error("Sign Client is not initialized");
    this.client.on("session_ping", (t) => {
      var e;
      const { topic: i } = t;
      i === ((e = this.session) == null ? void 0 : e.topic) && this.events.emit("session_ping", t);
    }), this.client.on("session_event", (t) => {
      var e;
      const { params: i, topic: r } = t;
      if (r !== ((e = this.session) == null ? void 0 : e.topic)) return;
      const { event: a } = i;
      if (a.name === "accountsChanged") {
        const n = a.data;
        n && $e(n) && this.events.emit("accountsChanged", n.map(le));
      } else if (a.name === "chainChanged") {
        const n = i.chainId, c2 = i.event.data, h = pr(n), v3 = z(n) !== z(c2) ? `${h}:${z(c2)}` : n;
        this.onChainChanged(v3);
      } else this.events.emit(a.name, a.data);
      this.events.emit("session_event", t);
    }), this.client.on("session_update", ({ topic: t, params: e }) => {
      var i, r;
      if (t !== ((i = this.session) == null ? void 0 : i.topic)) return;
      const { namespaces: a } = e, n = (r = this.client) == null ? void 0 : r.session.get(t);
      this.session = V(L2({}, n), { namespaces: a }), this.onSessionUpdate(), this.events.emit("session_update", { topic: t, params: e });
    }), this.client.on("session_delete", async (t) => {
      var e;
      t.topic === ((e = this.session) == null ? void 0 : e.topic) && (await this.cleanup(), this.events.emit("session_delete", t), this.events.emit("disconnect", V(L2({}, de("USER_DISCONNECTED")), { data: t.topic })));
    }), this.on(d2.DEFAULT_CHAIN_CHANGED, (t) => {
      this.onChainChanged(t, true);
    });
  }
  getProvider(t) {
    return this.rpcProviders[t] || this.rpcProviders[w2];
  }
  onSessionUpdate() {
    Object.keys(this.rpcProviders).forEach((t) => {
      var e;
      this.getProvider(t).updateNamespace((e = this.session) == null ? void 0 : e.namespaces[t]);
    });
  }
  setNamespaces(t) {
    const { namespaces: e, optionalNamespaces: i, sessionProperties: r, scopedProperties: a } = t;
    e && Object.keys(e).length && (this.namespaces = e), i && Object.keys(i).length && (this.optionalNamespaces = i), this.sessionProperties = r, this.scopedProperties = a;
  }
  validateChain(t) {
    const [e, i] = (t == null ? void 0 : t.split(":")) || ["", ""];
    if (!this.namespaces || !Object.keys(this.namespaces).length) return [e, i];
    if (e && !Object.keys(this.namespaces || {}).map((n) => pr(n)).includes(e)) throw new Error(`Namespace '${e}' is not configured. Please call connect() first with namespace config.`);
    if (e && i) return [e, i];
    const r = pr(Object.keys(this.namespaces)[0]), a = this.rpcProviders[r].getDefaultChain();
    return [r, a];
  }
  async requestAccounts() {
    const [t] = this.validateChain();
    return await this.getProvider(t).requestAccounts();
  }
  async onChainChanged(t, e = false) {
    if (!this.namespaces) return;
    const [i, r] = this.validateChain(t);
    r && (e || this.getProvider(i).setDefaultChain(r), this.namespaces[i] ? this.namespaces[i].defaultChain = r : this.namespaces[`${i}:${r}`] ? this.namespaces[`${i}:${r}`].defaultChain = r : this.namespaces[`${i}:${r}`] = { defaultChain: r }, this.events.emit("chainChanged", r), await this.persist("namespaces", this.namespaces));
  }
  onConnect() {
    this.createProviders(), this.events.emit("connect", { session: this.session });
  }
  async cleanup() {
    this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, await this.deleteFromStore("namespaces"), await this.deleteFromStore("optionalNamespaces"), await this.deleteFromStore("sessionProperties"), this.session = void 0, await this.cleanupPendingPairings({ deletePairings: true }), await this.cleanupStorage();
  }
  async persist(t, e) {
    var i;
    const r = ((i = this.session) == null ? void 0 : i.topic) || "";
    await this.client.core.storage.setItem(`${_}/${t}${r}`, e);
  }
  async getFromStore(t) {
    var e;
    const i = ((e = this.session) == null ? void 0 : e.topic) || "";
    return await this.client.core.storage.getItem(`${_}/${t}${i}`);
  }
  async deleteFromStore(t) {
    var e;
    const i = ((e = this.session) == null ? void 0 : e.topic) || "";
    await this.client.core.storage.removeItem(`${_}/${t}${i}`);
  }
  async cleanupStorage() {
    var t;
    try {
      if (((t = this.client) == null ? void 0 : t.session.length) > 0) return;
      const e = await this.client.core.storage.getKeys();
      for (const i of e) i.startsWith(_) && await this.client.core.storage.removeItem(i);
    } catch (e) {
      this.logger.warn("Failed to cleanup storage", e);
    }
  }
};
var es = x;

// node_modules/@walletconnect/ethereum-provider/dist/index.es.js
var T2 = "wc";
var $2 = "ethereum_provider";
var j2 = `${T2}@2:${$2}:`;
var q = "https://rpc.walletconnect.org/v1/";
var u2 = ["eth_sendTransaction", "personal_sign"];
var M = ["eth_accounts", "eth_requestAccounts", "eth_sendRawTransaction", "eth_sign", "eth_signTransaction", "eth_signTypedData", "eth_signTypedData_v3", "eth_signTypedData_v4", "eth_sendTransaction", "personal_sign", "wallet_switchEthereumChain", "wallet_addEthereumChain", "wallet_getPermissions", "wallet_requestPermissions", "wallet_registerOnboarding", "wallet_watchAsset", "wallet_scanQRCode", "wallet_sendCalls", "wallet_getCapabilities", "wallet_getCallsStatus", "wallet_showCallsStatus"];
var m2 = ["chainChanged", "accountsChanged"];
var O3 = ["chainChanged", "accountsChanged", "message", "disconnect", "connect"];
var N2 = Object.defineProperty;
var D2 = Object.defineProperties;
var U3 = Object.getOwnPropertyDescriptors;
var P3 = Object.getOwnPropertySymbols;
var Q2 = Object.prototype.hasOwnProperty;
var L3 = Object.prototype.propertyIsEnumerable;
var y2 = (a, t, s) => t in a ? N2(a, t, { enumerable: true, configurable: true, writable: true, value: s }) : a[t] = s;
var g3 = (a, t) => {
  for (var s in t || (t = {})) Q2.call(t, s) && y2(a, s, t[s]);
  if (P3) for (var s of P3(t)) L3.call(t, s) && y2(a, s, t[s]);
  return a;
};
var _2 = (a, t) => D2(a, U3(t));
var o4 = (a, t, s) => y2(a, typeof t != "symbol" ? t + "" : t, s);
function v2(a) {
  return Number(a[0].split(":")[1]);
}
function C2(a) {
  return `0x${a.toString(16)}`;
}
function x2(a) {
  const { chains: t, optionalChains: s, methods: i, optionalMethods: e, events: n, optionalEvents: h, rpcMap: l2 } = a;
  if (!$e(t)) throw new Error("Invalid chains");
  const r = { chains: t, methods: i || u2, events: n || m2, rpcMap: g3({}, t.length ? { [v2(t)]: l2[v2(t)] } : {}) }, d3 = n == null ? void 0 : n.filter((p3) => !m2.includes(p3)), c2 = i == null ? void 0 : i.filter((p3) => !u2.includes(p3));
  if (!s && !h && !e && !(d3 != null && d3.length) && !(c2 != null && c2.length)) return { required: t.length ? r : void 0 };
  const I2 = (d3 == null ? void 0 : d3.length) && (c2 == null ? void 0 : c2.length) || !s, f2 = { chains: [...new Set(I2 ? r.chains.concat(s || []) : s)], methods: [...new Set(r.methods.concat(e != null && e.length ? e : M))], events: [...new Set(r.events.concat(h != null && h.length ? h : O3))], rpcMap: l2 };
  return { required: t.length ? r : void 0, optional: s.length ? f2 : void 0 };
}
var w3 = class _w {
  constructor() {
    o4(this, "events", new import_events3.EventEmitter()), o4(this, "namespace", "eip155"), o4(this, "accounts", []), o4(this, "signer"), o4(this, "chainId", 1), o4(this, "modal"), o4(this, "rpc"), o4(this, "STORAGE_KEY", j2), o4(this, "on", (t, s) => (this.events.on(t, s), this)), o4(this, "once", (t, s) => (this.events.once(t, s), this)), o4(this, "removeListener", (t, s) => (this.events.removeListener(t, s), this)), o4(this, "off", (t, s) => (this.events.off(t, s), this)), o4(this, "parseAccount", (t) => this.isCompatibleChainId(t) ? this.parseAccountId(t).address : t), this.signer = {}, this.rpc = {};
  }
  static async init(t) {
    const s = new _w();
    return await s.initialize(t), s;
  }
  async request(t, s) {
    return await this.signer.request(t, this.formatChainId(this.chainId), s);
  }
  sendAsync(t, s, i) {
    this.signer.sendAsync(t, s, this.formatChainId(this.chainId), i);
  }
  get connected() {
    return this.signer.client ? this.signer.client.core.relayer.connected : false;
  }
  get connecting() {
    return this.signer.client ? this.signer.client.core.relayer.connecting : false;
  }
  async enable() {
    return this.session || await this.connect(), await this.request({ method: "eth_requestAccounts" });
  }
  async connect(t) {
    if (!this.signer.client) throw new Error("Provider not initialized. Call init() first");
    this.loadConnectOpts(t);
    const { required: s, optional: i } = x2(this.rpc);
    try {
      const e = await new Promise(async (h, l2) => {
        var r;
        this.rpc.showQrModal && ((r = this.modal) == null || r.subscribeModal((c2) => {
          !c2.open && !this.signer.session && (this.signer.abortPairingAttempt(), l2(new Error("Connection request reset. Please try again.")));
        }));
        const d3 = t != null && t.scopedProperties ? { [this.namespace]: t.scopedProperties } : void 0;
        await this.signer.connect(_2(g3({ namespaces: g3({}, s && { [this.namespace]: s }) }, i && { optionalNamespaces: { [this.namespace]: i } }), { pairingTopic: t == null ? void 0 : t.pairingTopic, scopedProperties: d3 })).then((c2) => {
          h(c2);
        }).catch((c2) => {
          l2(new Error(c2.message));
        });
      });
      if (!e) return;
      const n = Kr(e.namespaces, [this.namespace]);
      this.setChainIds(this.rpc.chains.length ? this.rpc.chains : n), this.setAccounts(n), this.events.emit("connect", { chainId: C2(this.chainId) });
    } catch (e) {
      throw this.signer.logger.error(e), e;
    } finally {
      this.modal && this.modal.closeModal();
    }
  }
  async authenticate(t, s) {
    if (!this.signer.client) throw new Error("Provider not initialized. Call init() first");
    this.loadConnectOpts({ chains: t == null ? void 0 : t.chains });
    try {
      const i = await new Promise(async (n, h) => {
        var l2;
        this.rpc.showQrModal && ((l2 = this.modal) == null || l2.subscribeModal((r) => {
          !r.open && !this.signer.session && (this.signer.abortPairingAttempt(), h(new Error("Connection request reset. Please try again.")));
        })), await this.signer.authenticate(_2(g3({}, t), { chains: this.rpc.chains }), s).then((r) => {
          n(r);
        }).catch((r) => {
          h(new Error(r.message));
        });
      }), e = i.session;
      if (e) {
        const n = Kr(e.namespaces, [this.namespace]);
        this.setChainIds(this.rpc.chains.length ? this.rpc.chains : n), this.setAccounts(n), this.events.emit("connect", { chainId: C2(this.chainId) });
      }
      return i;
    } catch (i) {
      throw this.signer.logger.error(i), i;
    } finally {
      this.modal && this.modal.closeModal();
    }
  }
  async disconnect() {
    this.session && await this.signer.disconnect(), this.reset();
  }
  get isWalletConnect() {
    return true;
  }
  get session() {
    return this.signer.session;
  }
  registerEventListeners() {
    this.signer.on("session_event", (t) => {
      const { params: s } = t, { event: i } = s;
      i.name === "accountsChanged" ? (this.accounts = this.parseAccounts(i.data), this.events.emit("accountsChanged", this.accounts)) : i.name === "chainChanged" ? this.setChainId(this.formatChainId(i.data)) : this.events.emit(i.name, i.data), this.events.emit("session_event", t);
    }), this.signer.on("chainChanged", (t) => {
      const s = parseInt(t);
      this.chainId = s, this.events.emit("chainChanged", C2(this.chainId)), this.persist();
    }), this.signer.on("session_update", (t) => {
      this.events.emit("session_update", t);
    }), this.signer.on("session_delete", (t) => {
      this.reset(), this.events.emit("session_delete", t), this.events.emit("disconnect", _2(g3({}, de("USER_DISCONNECTED")), { data: t.topic, name: "USER_DISCONNECTED" }));
    }), this.signer.on("display_uri", (t) => {
      var s, i;
      this.rpc.showQrModal && ((s = this.modal) == null || s.closeModal(), (i = this.modal) == null || i.openModal({ uri: t })), this.events.emit("display_uri", t);
    });
  }
  switchEthereumChain(t) {
    this.request({ method: "wallet_switchEthereumChain", params: [{ chainId: t.toString(16) }] });
  }
  isCompatibleChainId(t) {
    return typeof t == "string" ? t.startsWith(`${this.namespace}:`) : false;
  }
  formatChainId(t) {
    return `${this.namespace}:${t}`;
  }
  parseChainId(t) {
    return Number(t.split(":")[1]);
  }
  setChainIds(t) {
    const s = t.filter((i) => this.isCompatibleChainId(i)).map((i) => this.parseChainId(i));
    s.length && (this.chainId = s[0], this.events.emit("chainChanged", C2(this.chainId)), this.persist());
  }
  setChainId(t) {
    if (this.isCompatibleChainId(t)) {
      const s = this.parseChainId(t);
      this.chainId = s, this.switchEthereumChain(s);
    }
  }
  parseAccountId(t) {
    const [s, i, e] = t.split(":");
    return { chainId: `${s}:${i}`, address: e };
  }
  setAccounts(t) {
    this.accounts = t.filter((s) => this.parseChainId(this.parseAccountId(s).chainId) === this.chainId).map((s) => this.parseAccountId(s).address), this.events.emit("accountsChanged", this.accounts);
  }
  getRpcConfig(t) {
    var s, i;
    const e = (s = t == null ? void 0 : t.chains) != null ? s : [], n = (i = t == null ? void 0 : t.optionalChains) != null ? i : [], h = e.concat(n);
    if (!h.length) throw new Error("No chains specified in either `chains` or `optionalChains`");
    const l2 = e.length ? (t == null ? void 0 : t.methods) || u2 : [], r = e.length ? (t == null ? void 0 : t.events) || m2 : [], d3 = (t == null ? void 0 : t.optionalMethods) || [], c2 = (t == null ? void 0 : t.optionalEvents) || [], I2 = (t == null ? void 0 : t.rpcMap) || this.buildRpcMap(h, t.projectId), f2 = (t == null ? void 0 : t.qrModalOptions) || void 0;
    return { chains: e == null ? void 0 : e.map((p3) => this.formatChainId(p3)), optionalChains: n.map((p3) => this.formatChainId(p3)), methods: l2, events: r, optionalMethods: d3, optionalEvents: c2, rpcMap: I2, showQrModal: !!(t != null && t.showQrModal), qrModalOptions: f2, projectId: t.projectId, metadata: t.metadata };
  }
  buildRpcMap(t, s) {
    const i = {};
    return t.forEach((e) => {
      i[e] = this.getRpcUrl(e, s);
    }), i;
  }
  async initialize(t) {
    if (this.rpc = this.getRpcConfig(t), this.chainId = this.rpc.chains.length ? v2(this.rpc.chains) : v2(this.rpc.optionalChains), this.signer = await es.init({ projectId: this.rpc.projectId, metadata: this.rpc.metadata, disableProviderPing: t.disableProviderPing, relayUrl: t.relayUrl, storage: t.storage, storageOptions: t.storageOptions, customStoragePrefix: t.customStoragePrefix, telemetryEnabled: t.telemetryEnabled, logger: t.logger }), this.registerEventListeners(), await this.loadPersistedSession(), this.rpc.showQrModal) {
      let s;
      try {
        const { WalletConnectModal: i } = await import("./dist-ZKCV6QDS.js");
        s = i;
      } catch {
        throw new Error("To use QR modal, please install @walletconnect/modal package");
      }
      if (s) try {
        this.modal = new s(g3({ projectId: this.rpc.projectId }, this.rpc.qrModalOptions));
      } catch (i) {
        throw this.signer.logger.error(i), new Error("Could not generate WalletConnectModal Instance");
      }
    }
  }
  loadConnectOpts(t) {
    if (!t) return;
    const { chains: s, optionalChains: i, rpcMap: e } = t;
    s && $e(s) && (this.rpc.chains = s.map((n) => this.formatChainId(n)), s.forEach((n) => {
      this.rpc.rpcMap[n] = (e == null ? void 0 : e[n]) || this.getRpcUrl(n);
    })), i && $e(i) && (this.rpc.optionalChains = [], this.rpc.optionalChains = i == null ? void 0 : i.map((n) => this.formatChainId(n)), i.forEach((n) => {
      this.rpc.rpcMap[n] = (e == null ? void 0 : e[n]) || this.getRpcUrl(n);
    }));
  }
  getRpcUrl(t, s) {
    var i;
    return ((i = this.rpc.rpcMap) == null ? void 0 : i[t]) || `${q}?chainId=eip155:${t}&projectId=${s || this.rpc.projectId}`;
  }
  async loadPersistedSession() {
    if (this.session) try {
      const t = await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`), s = this.session.namespaces[`${this.namespace}:${t}`] ? this.session.namespaces[`${this.namespace}:${t}`] : this.session.namespaces[this.namespace];
      this.setChainIds(t ? [this.formatChainId(t)] : s == null ? void 0 : s.accounts), this.setAccounts(s == null ? void 0 : s.accounts);
    } catch (t) {
      this.signer.logger.error("Failed to load persisted session, clearing state..."), this.signer.logger.error(t), await this.disconnect().catch((s) => this.signer.logger.warn(s));
    }
  }
  reset() {
    this.chainId = 1, this.accounts = [];
  }
  persist() {
    this.session && this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`, this.chainId);
  }
  parseAccounts(t) {
    return typeof t == "string" || t instanceof String ? [this.parseAccount(t)] : t.map((s) => this.parseAccount(s));
  }
};
var z2 = w3;
export {
  z2 as EthereumProvider,
  O3 as OPTIONAL_EVENTS,
  M as OPTIONAL_METHODS,
  m2 as REQUIRED_EVENTS,
  u2 as REQUIRED_METHODS,
  w3 as default
};
//# sourceMappingURL=index.es-HLDWRUXG.js.map
