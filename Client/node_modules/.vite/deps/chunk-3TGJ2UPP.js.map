{
  "version": 3,
  "sources": ["../../thirdweb/src/utils/ipfs.ts", "../../thirdweb/src/storage/download.ts"],
  "sourcesContent": ["import type { ThirdwebClient } from \"../client/client.js\";\nimport type { FileOrBufferOrString } from \"../storage/upload/types.js\";\n\nexport type ResolveSchemeOptions = {\n  client: ThirdwebClient;\n  uri: string;\n};\n\nconst DEFAULT_GATEWAY = \"https://{clientId}.ipfscdn.io/ipfs/{cid}\";\n\n/**\n * Resolves the scheme of a given URI and returns the corresponding URL.\n * If the URI starts with \"ipfs://\", it constructs a URL using the IPFS client ID and the IPFS gateway.\n * If the URI starts with \"http\", it returns the URI as is.\n * Otherwise, it throws an error indicating an invalid URI scheme.\n * @param options - The options object containing the URI and the IPFS client.\n * @returns The resolved URL.\n * @throws Error if the URI scheme is invalid.\n * @example\n * ```ts\n * import { resolveScheme } from \"thirdweb/storage\";\n * const url = resolveScheme({\n *  client,\n *  uri: \"ipfs://Qm...\",\n * });\n * ```\n * @storage\n */\nexport function resolveScheme(options: ResolveSchemeOptions) {\n  if (options.uri.startsWith(\"ipfs://\")) {\n    const gateway =\n      options.client.config?.storage?.gatewayUrl ?? DEFAULT_GATEWAY;\n    const clientId = options.client.clientId;\n    const cid = findIPFSCidFromUri(options.uri);\n\n    let bundleId: string | undefined = undefined;\n    if (typeof globalThis !== \"undefined\" && \"Application\" in globalThis) {\n      // shims use wallet connect RN module which injects Application info in globalThis\n      // biome-ignore lint/suspicious/noExplicitAny: get around globalThis typing\n      bundleId = (globalThis as any).Application.applicationId;\n    }\n\n    // purposefully using SPLIT here and not replace for CID to avoid cases where users don't know the schema\n    // also only splitting on `/ipfs` to avoid cases where people pass non `/` terminated gateway urls\n    return `${\n      gateway.replace(\"{clientId}\", clientId).split(\"/ipfs\")[0]\n    }/ipfs/${cid}${bundleId ? `?bundleId=${bundleId}` : \"\"}`;\n  }\n  if (options.uri.startsWith(\"http\")) {\n    return options.uri;\n  }\n  throw new Error(`Invalid URI scheme, expected \"ipfs://\" or \"http(s)://\"`);\n}\n\n/**\n * @internal\n */\nexport function findIPFSCidFromUri(uri: string) {\n  if (!uri.startsWith(\"ipfs://\")) {\n    // do not touch URIs that are not ipfs URIs\n    return uri;\n  }\n\n  // first index of `/Qm` or `/bafy` in the uri (case insensitive)\n  const firstIndex = uri.search(/\\/(Qm|baf)/i);\n  // we start one character after the first `/` to avoid including it in the CID\n  return uri.slice(firstIndex + 1);\n}\n/**\n * Uploads or extracts URIs from the given files.\n * @template T - The type of the files (File, Buffer, String).\n * @param files - The files to upload or extract URIs from.\n * @param client - The Thirdweb client.\n * @param [startNumber] - The starting number for rewriting file names.\n * @returns - A promise that resolves to an array of URIs.\n * @throws {Error} - If the files are not all of the same type (all URI or all FileOrBufferOrString).\n * @internal\n *\n */\nexport async function uploadOrExtractURIs<\n  T extends FileOrBufferOrString | Record<string, unknown>,\n>(files: T[], client: ThirdwebClient, startNumber?: number): Promise<string[]> {\n  if (isUriList(files)) {\n    return files;\n  }\n  if (isMetadataList(files)) {\n    const { upload } = await import(\"../storage/upload.js\");\n    const uris = await upload({\n      client,\n      files,\n      rewriteFileNames: {\n        fileStartNumber: startNumber || 0,\n      },\n    });\n    return Array.isArray(uris) ? uris : [uris];\n  }\n  throw new Error(\n    \"Files must all be of the same type (all URI or all FileOrBufferOrString)\",\n  );\n}\n\n/**\n * Retrieves the base URI from a batch of URIs.\n *\n * @param uris - An array of URIs.\n * @returns The base URI shared by all URIs in the batch.\n * @throws If the batch contains URIs with different base URIs or if no base URI is found.\n * @internal\n */\nexport function getBaseUriFromBatch(uris: string | string[]): string {\n  // biome-ignore lint/style/noParameterAssign: lemme do my stuff\n  uris = Array.isArray(uris) ? uris : [uris];\n  const [base, ...rest] = uris.map((uri) => {\n    // remove query parameters\n    // biome-ignore lint/style/noParameterAssign: lemme do my stuff\n    [uri] = uri.split(\"?\") as [string];\n    // remove fragments\n    // biome-ignore lint/style/noParameterAssign: lemme do my stuff\n    [uri] = uri.split(\"#\") as [string];\n\n    // if the URI ends with a `/`, remove it\n    if (uri.endsWith(\"/\")) {\n      // biome-ignore lint/style/noParameterAssign: lemme do my stuff\n      uri = uri.slice(0, -1);\n    }\n\n    // remove the last part of the URI & add the trailing `/`\n    return `${uri.split(\"/\").slice(0, -1).join(\"/\")}/`;\n  });\n\n  if (!base) {\n    throw new Error(\"Batch of URIs is empty\");\n  }\n\n  if (rest.some((uri) => uri !== base)) {\n    throw new Error(\"All URIs in the batch must have the same base URI\");\n  }\n  return base;\n}\n\nfunction isUriList<T extends FileOrBufferOrString | Record<string, unknown>>(\n  metadatas: (string | T)[],\n): metadatas is string[] {\n  return metadatas.every((m) => typeof m === \"string\");\n}\n\nfunction isMetadataList<\n  T extends FileOrBufferOrString | Record<string, unknown>,\n>(metadatas: (string | T)[]): metadatas is T[] {\n  return metadatas.every((m) => typeof m !== \"string\");\n}\n", "import { getClientFetch } from \"../utils/fetch.js\";\nimport { type ResolveSchemeOptions, resolveScheme } from \"../utils/ipfs.js\";\nimport { IS_TEST } from \"../utils/process.js\";\nimport type { Prettify } from \"../utils/type-utils.js\";\nimport { getFromMockStorage } from \"./mock.js\";\n\nexport type DownloadOptions = Prettify<\n  ResolveSchemeOptions & {\n    requestTimeoutMs?: number;\n  }\n>;\n\n/**\n * Downloads a file from the specified IPFS, Arweave, or HTTP URI.\n *\n * `download` will parse the provided URI based on its scheme (ipfs://, ar://, https://) and convert it to a URL to fetch the file from thirdweb's storage service.\n *\n * @param options - The download options.\n * @param options.client - The Thirdweb client. See [createThirdwebClient](https://portal.thirdweb.com/references/typescript/v5/createThirdwebClient).\n * @param options.uri - The URI of the file to download. Can be IPFS, Arweave, or HTTP.\n * @param [options.requestTimeoutMs] - The maximum time in milliseconds to wait for the request to complete. Defaults to 60 seconds (60,000 milliseconds).\n *\n * @returns Asynchronously returns the network response from fetching the file.\n * @throws An error if the URI scheme is invalid or if the request fails.\n *\n * @example\n * Download a file from IPFS:\n * ```ts\n * import { download } from \"thirdweb/storage\";\n * import { createThirdwebClient } from \"thirdweb\";\n *\n * const client = createThirdwebClient({ clientId: \"YOUR_CLIENT_ID\" });\n *\n * const file = await download({\n *  client,\n *  uri: \"ipfs://Qm...\",\n * });\n * ```\n *\n * Download a file from Arweave:\n * ```ts\n * import { download } from \"thirdweb/storage\";\n * import { createThirdwebClient } from \"thirdweb\";\n *\n * const client = createThirdwebClient({ clientId: \"YOUR_CLIENT_ID\" });\n *\n * const file = await download({\n *  client,\n *  uri: \"ar://{arweave-transaction-id}\",\n * });\n * ```\n *\n * Download a file from HTTP:\n * ```ts\n * import { download } from \"thirdweb/storage\";\n * import { createThirdwebClient } from \"thirdweb\";\n *\n * const client = createThirdwebClient({ clientId: \"YOUR_CLIENT_ID\" });\n *\n * const file = await download({\n *  client,\n *  uri: \"https://example.com/file.txt\",\n * });\n * ```\n *\n * @storage\n */\nexport async function download(options: DownloadOptions) {\n  if (IS_TEST) {\n    const hash = options.uri.split(\"://\")[1];\n    if (!hash) {\n      throw new Error(\"Invalid hash\");\n    }\n    const data = getFromMockStorage(hash);\n    if (data) {\n      return {\n        ok: true,\n        status: 200,\n        json: () => Promise.resolve(data),\n      } as Response;\n    }\n  }\n\n  let url: string;\n  if (options.uri.startsWith(\"ar://\")) {\n    const { resolveArweaveScheme } = await import(\"../utils/arweave.js\");\n    url = resolveArweaveScheme(options);\n  } else {\n    url = resolveScheme(options);\n  }\n\n  const res = await getClientFetch(options.client)(url, {\n    keepalive: options.client.config?.storage?.fetch?.keepalive,\n    headers: options.client.config?.storage?.fetch?.headers,\n    requestTimeoutMs:\n      options.requestTimeoutMs ??\n      options.client.config?.storage?.fetch?.requestTimeoutMs ??\n      60000,\n  });\n\n  if (!res.ok) {\n    const error = await res.text();\n    throw new Error(\n      `Failed to download file: ${res.status} ${res.statusText} ${error || \"\"}`,\n    );\n  }\n  return res;\n}\n"],
  "mappings": ";;;;;;;;;AAQA,IAAM,kBAAkB;AAoBlB,SAAU,cAAc,SAA6B;AApB3D;AAqBE,MAAI,QAAQ,IAAI,WAAW,SAAS,GAAG;AACrC,UAAM,YACJ,mBAAQ,OAAO,WAAf,mBAAuB,YAAvB,mBAAgC,eAAc;AAChD,UAAM,WAAW,QAAQ,OAAO;AAChC,UAAM,MAAM,mBAAmB,QAAQ,GAAG;AAE1C,QAAI,WAA+B;AACnC,QAAI,OAAO,eAAe,eAAe,iBAAiB,YAAY;AAGpE,iBAAY,WAAmB,YAAY;IAC7C;AAIA,WAAO,GACL,QAAQ,QAAQ,cAAc,QAAQ,EAAE,MAAM,OAAO,EAAE,CAAC,CAC1D,SAAS,GAAG,GAAG,WAAW,aAAa,QAAQ,KAAK,EAAE;EACxD;AACA,MAAI,QAAQ,IAAI,WAAW,MAAM,GAAG;AAClC,WAAO,QAAQ;EACjB;AACA,QAAM,IAAI,MAAM,wDAAwD;AAC1E;AAKM,SAAU,mBAAmB,KAAW;AAC5C,MAAI,CAAC,IAAI,WAAW,SAAS,GAAG;AAE9B,WAAO;EACT;AAGA,QAAM,aAAa,IAAI,OAAO,aAAa;AAE3C,SAAO,IAAI,MAAM,aAAa,CAAC;AACjC;;;ACAA,eAAsB,SAAS,SAAwB;AAnEvD;AAoEE,MAAI,SAAS;AACX,UAAM,OAAO,QAAQ,IAAI,MAAM,KAAK,EAAE,CAAC;AACvC,QAAI,CAAC,MAAM;AACT,YAAM,IAAI,MAAM,cAAc;IAChC;AACA,UAAM,OAAO,mBAAmB,IAAI;AACpC,QAAI,MAAM;AACR,aAAO;QACL,IAAI;QACJ,QAAQ;QACR,MAAM,MAAM,QAAQ,QAAQ,IAAI;;IAEpC;EACF;AAEA,MAAI;AACJ,MAAI,QAAQ,IAAI,WAAW,OAAO,GAAG;AACnC,UAAM,EAAE,qBAAoB,IAAK,MAAM,OAAO,uBAAqB;AACnE,UAAM,qBAAqB,OAAO;EACpC,OAAO;AACL,UAAM,cAAc,OAAO;EAC7B;AAEA,QAAM,MAAM,MAAM,eAAe,QAAQ,MAAM,EAAE,KAAK;IACpD,YAAW,yBAAQ,OAAO,WAAf,mBAAuB,YAAvB,mBAAgC,UAAhC,mBAAuC;IAClD,UAAS,yBAAQ,OAAO,WAAf,mBAAuB,YAAvB,mBAAgC,UAAhC,mBAAuC;IAChD,kBACE,QAAQ,sBACR,yBAAQ,OAAO,WAAf,mBAAuB,YAAvB,mBAAgC,UAAhC,mBAAuC,qBACvC;GACH;AAED,MAAI,CAAC,IAAI,IAAI;AACX,UAAM,QAAQ,MAAM,IAAI,KAAI;AAC5B,UAAM,IAAI,MACR,4BAA4B,IAAI,MAAM,IAAI,IAAI,UAAU,IAAI,SAAS,EAAE,EAAE;EAE7E;AACA,SAAO;AACT;",
  "names": []
}
