import {
  stringify
} from "./chunk-2CIJO3V3.js";
import {
  getCachedChain
} from "./chunk-6OSAHK2J.js";
import {
  getClientFetch
} from "./chunk-Q3BUNRF4.js";
import {
  getThirdwebDomains
} from "./chunk-5UJ7PIRT.js";

// node_modules/thirdweb/dist/esm/pay/utils/definitions.js
var getPayBaseUrl = () => {
  const payDomain = getThirdwebDomains().pay;
  return payDomain.startsWith("localhost") ? `http://${payDomain}` : `https://${payDomain}`;
};
var getPayBuyWithCryptoStatusUrl = () => `${getPayBaseUrl()}/buy-with-crypto/status/v1`;
var getPayBuyWithCryptoQuoteEndpoint = () => `${getPayBaseUrl()}/buy-with-crypto/quote/v1`;
var getPayBuyWithCryptoTransferEndpoint = () => `${getPayBaseUrl()}/buy-with-crypto/transfer/v1`;
var getPayBuyWithFiatQuoteEndpoint = () => `${getPayBaseUrl()}/buy-with-fiat/quote/v1`;
var getPayBuyWithFiatStatusEndpoint = () => `${getPayBaseUrl()}/buy-with-fiat/status/v1`;
var getPayBuyWithFiatHistoryEndpoint = () => `${getPayBaseUrl()}/buy-with-fiat/history/v1`;
var getPayBuyWithCryptoHistoryEndpoint = () => `${getPayBaseUrl()}/buy-with-crypto/history/v1`;
var getPaySupportedDestinations = () => `${getPayBaseUrl()}/destination-tokens/v1`;
var getPaySupportedSources = () => `${getPayBaseUrl()}/buy-with-crypto/source-tokens/v1`;
var getPayBuyHistoryEndpoint = () => `${getPayBaseUrl()}/wallet/history/v1`;
var getPayConvertCryptoToFiatEndpoint = () => `${getPayBaseUrl()}/convert/crypto-to-fiat/v1`;

// node_modules/thirdweb/dist/esm/pay/buyWithCrypto/getStatus.js
async function getBuyWithCryptoStatus(buyWithCryptoTransaction) {
  try {
    if (!buyWithCryptoTransaction.transactionHash) {
      throw new Error("Transaction hash is required");
    }
    const queryString = new URLSearchParams({
      transactionHash: buyWithCryptoTransaction.transactionHash,
      chainId: buyWithCryptoTransaction.chainId.toString()
    }).toString();
    const url = `${getPayBuyWithCryptoStatusUrl()}?${queryString}`;
    const response = await getClientFetch(buyWithCryptoTransaction.client)(url);
    if (!response.ok) {
      const error = await response.text().catch(() => null);
      throw new Error(`HTTP error! status: ${response.status} - ${response.statusText}: ${error || "unknown error"}`);
    }
    const data = (await response.json()).result;
    return data;
  } catch (error) {
    console.error("Fetch error:", error);
    throw new Error(`Fetch failed: ${error}`);
  }
}

// node_modules/thirdweb/dist/esm/pay/buyWithCrypto/getQuote.js
async function getBuyWithCryptoQuote(params) {
  try {
    const clientFetch = getClientFetch(params.client);
    const response = await clientFetch(getPayBuyWithCryptoQuoteEndpoint(), {
      method: "POST",
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json"
      },
      body: stringify({
        fromAddress: params.fromAddress,
        toAddress: params.toAddress,
        fromChainId: params.fromChainId.toString(),
        fromTokenAddress: params.fromTokenAddress,
        toChainId: params.toChainId.toString(),
        toTokenAddress: params.toTokenAddress,
        fromAmount: params.fromAmount,
        toAmount: params.toAmount,
        maxSlippageBPS: params.maxSlippageBPS,
        intentId: params.intentId,
        purchaseData: params.purchaseData
      })
    });
    if (!response.ok) {
      const errorObj = await response.json();
      if (errorObj && "error" in errorObj) {
        throw errorObj;
      }
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = (await response.json()).result;
    const approvalData = data.approval;
    const swapRoute = {
      transactionRequest: {
        chain: getCachedChain(data.transactionRequest.chainId),
        client: params.client,
        data: data.transactionRequest.data,
        to: data.transactionRequest.to,
        value: BigInt(data.transactionRequest.value),
        extraGas: 50000n
        // extra gas buffer
      },
      approvalData,
      swapDetails: {
        fromAddress: data.fromAddress,
        toAddress: data.toAddress,
        fromToken: data.fromToken,
        toToken: data.toToken,
        fromAmount: data.fromAmount,
        fromAmountWei: data.fromAmountWei,
        toAmountMinWei: data.toAmountMinWei,
        toAmountMin: data.toAmountMin,
        toAmountWei: data.toAmountWei,
        toAmount: data.toAmount,
        estimated: data.estimated,
        maxSlippageBPS: data.maxSlippageBPS
      },
      paymentTokens: data.paymentTokens,
      processingFees: data.processingFees,
      client: params.client
    };
    return swapRoute;
  } catch (error) {
    console.error("Error getting buy with crypto quote", error);
    throw error;
  }
}

// node_modules/thirdweb/dist/esm/pay/buyWithCrypto/getTransfer.js
async function getBuyWithCryptoTransfer(params) {
  try {
    const clientFetch = getClientFetch(params.client);
    const response = await clientFetch(getPayBuyWithCryptoTransferEndpoint(), {
      method: "POST",
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json"
      },
      body: stringify({
        fromAddress: params.fromAddress,
        toAddress: params.toAddress,
        chainId: params.chainId,
        tokenAddress: params.tokenAddress,
        amount: params.amount,
        purchaseData: params.purchaseData,
        feePayer: params.feePayer
      })
    });
    if (!response.ok) {
      const errorObj = await response.json();
      if (errorObj && "error" in errorObj) {
        throw errorObj;
      }
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = (await response.json()).result;
    const transfer = {
      transactionRequest: {
        chain: getCachedChain(data.transactionRequest.chainId),
        client: params.client,
        data: data.transactionRequest.data,
        to: data.transactionRequest.to,
        value: BigInt(data.transactionRequest.value),
        extraGas: 50000n
        // extra gas buffer
      },
      approvalData: data.approval,
      fromAddress: data.fromAddress,
      toAddress: data.toAddress,
      paymentToken: data.paymentToken,
      processingFee: data.processingFee,
      estimatedGasCostUSDCents: data.estimatedGasCostUSDCents,
      client: params.client
    };
    return transfer;
  } catch (error) {
    console.error("Error getting buy with crypto transfer", error);
    throw error;
  }
}

export {
  getPayBuyWithFiatQuoteEndpoint,
  getPayBuyWithFiatStatusEndpoint,
  getPayBuyWithFiatHistoryEndpoint,
  getPayBuyWithCryptoHistoryEndpoint,
  getPaySupportedDestinations,
  getPaySupportedSources,
  getPayBuyHistoryEndpoint,
  getPayConvertCryptoToFiatEndpoint,
  getBuyWithCryptoStatus,
  getBuyWithCryptoQuote,
  getBuyWithCryptoTransfer
};
//# sourceMappingURL=chunk-5V756HST.js.map
