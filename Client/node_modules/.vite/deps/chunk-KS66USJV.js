import {
  serializeTransaction
} from "./chunk-3CCNHYRS.js";
import {
  secp256k1
} from "./chunk-AYP3M5MU.js";
import {
  keccak256
} from "./chunk-QIKOD3PZ.js";
import {
  from,
  from2,
  fromBytes
} from "./chunk-O2PTR6DB.js";
import {
  getClientFetch
} from "./chunk-Q3BUNRF4.js";
import {
  getThirdwebBaseUrl
} from "./chunk-5UJ7PIRT.js";

// node_modules/ox/_esm/core/internal/entropy.js
var extraEntropy = false;

// node_modules/ox/_esm/core/Secp256k1.js
function randomPrivateKey(options = {}) {
  const { as = "Hex" } = options;
  const bytes = secp256k1.utils.randomPrivateKey();
  if (as === "Hex")
    return fromBytes(bytes);
  return bytes;
}
function sign(options) {
  const { extraEntropy: extraEntropy2 = extraEntropy, hash, payload, privateKey } = options;
  const { r, s, recovery } = secp256k1.sign(from(payload), from(privateKey), {
    extraEntropy: typeof extraEntropy2 === "boolean" ? extraEntropy2 : from2(extraEntropy2).slice(2),
    lowS: true,
    ...hash ? { prehash: true } : {}
  });
  return {
    r,
    s,
    yParity: recovery
  };
}

// node_modules/thirdweb/dist/esm/transaction/actions/sign-transaction.js
function signTransaction({ transaction, privateKey }) {
  const serializedTransaction = serializeTransaction({ transaction });
  const signature = sign({
    payload: keccak256(serializedTransaction),
    privateKey
  });
  return serializeTransaction({
    transaction: { ...transaction, ...signature }
  });
}

// node_modules/thirdweb/dist/esm/wallets/in-app/core/users/getUser.js
async function getUser({ client, walletAddress, email, phone, id, externalWalletAddress, ecosystem }) {
  if (!client.secretKey) {
    throw new Error("A secret key is required to query for users. If you're making this request from the server, please add a secret key to your client.");
  }
  const url = new URL(`${getThirdwebBaseUrl("inAppWallet")}/api/2023-11-30/embedded-wallet/user-details`);
  if (walletAddress) {
    url.searchParams.set("queryBy", "walletAddress");
    url.searchParams.set("walletAddress", walletAddress);
  } else if (email) {
    url.searchParams.set("queryBy", "email");
    url.searchParams.set("email", email);
  } else if (phone) {
    url.searchParams.set("queryBy", "phone");
    url.searchParams.set("phone", phone);
  } else if (id) {
    url.searchParams.set("queryBy", "id");
    url.searchParams.set("id", id);
  } else if (externalWalletAddress) {
    url.searchParams.set("queryBy", "externalWalletAddress");
    url.searchParams.set("externalWalletAddress", externalWalletAddress);
  } else {
    throw new Error("Please provide a walletAddress, email, phone, id, or externalWalletAddress to query for users.");
  }
  const clientFetch = getClientFetch(client, ecosystem);
  const res = await clientFetch(url.toString());
  if (!res.ok) {
    const error = await res.text().catch(() => "Unknown error");
    throw new Error(`Failed to get profiles. ${res.status} ${res.statusText}: ${error}`);
  }
  const data = await res.json();
  return data.map((item) => ({
    userId: item.userId,
    walletAddress: item.walletAddress,
    smartAccountAddress: item.smartAccountAddress,
    email: item.email,
    phone: item.phone,
    createdAt: item.createdAt,
    profiles: item.linkedAccounts.map((profile) => {
      return {
        type: profile.type === "siwe" ? "wallet" : profile.type,
        details: profile.details
      };
    })
  }))[0] || null;
}

export {
  randomPrivateKey,
  sign,
  signTransaction,
  getUser
};
//# sourceMappingURL=chunk-KS66USJV.js.map
