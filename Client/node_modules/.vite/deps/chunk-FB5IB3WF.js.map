{
  "version": 3,
  "sources": ["../../thirdweb/src/wallets/injected/index.ts"],
  "sourcesContent": ["import type { EIP1193Provider } from \"viem\";\nimport {\n  type SignTypedDataParameters,\n  getTypesForEIP712Domain,\n  serializeTypedData,\n  validateTypedData,\n} from \"viem\";\nimport { trackTransaction } from \"../../analytics/track/transaction.js\";\nimport type { Chain } from \"../../chains/types.js\";\nimport { getCachedChain, getChainMetadata } from \"../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport {\n  type Hex,\n  numberToHex,\n  stringToHex,\n  uint8ArrayToHex,\n} from \"../../utils/encoding/hex.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parse-typed-data.js\";\nimport type { InjectedSupportedWalletIds } from \"../__generated__/wallet-ids.js\";\nimport type { Account, SendTransactionOption } from \"../interfaces/wallet.js\";\nimport type { DisconnectFn, SwitchChainFn } from \"../types.js\";\nimport { getValidPublicRPCUrl } from \"../utils/chains.js\";\nimport { normalizeChainId } from \"../utils/normalizeChainId.js\";\nimport type { WalletEmitter } from \"../wallet-emitter.js\";\nimport type { WalletId } from \"../wallet-types.js\";\nimport { injectedProvider } from \"./mipdStore.js\";\n\n// TODO: save the provider in data\nexport function getInjectedProvider(walletId: WalletId) {\n  const provider = injectedProvider(walletId);\n  if (!provider) {\n    throw new Error(`No injected provider found for wallet: \"${walletId}\"`);\n  }\n\n  return provider;\n}\n\n/**\n * @internal\n */\nexport async function connectEip1193Wallet({\n  id,\n  provider,\n  emitter,\n  client,\n  chain,\n}: {\n  id: InjectedSupportedWalletIds | ({} & string);\n  provider: EIP1193Provider;\n  client: ThirdwebClient;\n  chain?: Chain;\n  emitter: WalletEmitter<InjectedSupportedWalletIds>;\n}): Promise<ReturnType<typeof onConnect>> {\n  let addresses: string[] | undefined;\n  const retries = 3;\n  let attempts = 0;\n  // retry 3 times, some providers take a while to return accounts on connect\n  while (!addresses?.[0] && attempts < retries) {\n    try {\n      addresses = await provider.request({\n        method: \"eth_requestAccounts\",\n      });\n    } catch (e) {\n      console.error(e);\n      if (extractErrorMessage(e)?.toLowerCase()?.includes(\"rejected\")) {\n        throw e;\n      }\n      await new Promise((resolve) => setTimeout(resolve, 500));\n    }\n    attempts++;\n  }\n\n  const addr = addresses?.[0];\n  if (!addr) {\n    throw new Error(\"Failed to connect to wallet, no accounts available\");\n  }\n\n  // use the first account\n  const address = getAddress(addr);\n\n  // get the chainId the provider is on\n  const chainId = await provider\n    .request({ method: \"eth_chainId\" })\n    .then(normalizeChainId)\n    .catch((e) => {\n      throw new Error(\"Error reading chainId from provider\", e);\n    });\n\n  let connectedChain =\n    chain && chain.id === chainId ? chain : getCachedChain(chainId);\n\n  try {\n    // if we want a specific chainId and it is not the same as the provider chainId, trigger switchChain\n    // we check for undefined chain ID since some chain-specific wallets like Abstract will not send a chain ID on connection\n    if (chain && typeof chain.id !== \"undefined\" && chain.id !== chainId) {\n      await switchChain(provider, chain);\n      connectedChain = chain;\n    }\n  } catch {\n    console.warn(\n      `Error switching to chain ${chain?.id} - defaulting to wallet chain (${chainId})`,\n    );\n  }\n\n  return onConnect({\n    provider,\n    address,\n    chain: connectedChain,\n    emitter,\n    client,\n    id,\n  });\n}\n\n/**\n * @internal\n */\nexport async function autoConnectEip1193Wallet({\n  id,\n  provider,\n  emitter,\n  client,\n  chain,\n}: {\n  id: InjectedSupportedWalletIds | ({} & string);\n  provider: EIP1193Provider;\n  emitter: WalletEmitter<InjectedSupportedWalletIds>;\n  client: ThirdwebClient;\n  chain?: Chain;\n}): Promise<ReturnType<typeof onConnect>> {\n  // connected accounts\n  const addresses = await provider.request({\n    method: \"eth_accounts\",\n  });\n\n  const addr = addresses[0];\n  if (!addr) {\n    throw new Error(\"Failed to connect to wallet, no accounts available\");\n  }\n\n  // use the first account\n  const address = getAddress(addr);\n\n  // get the chainId the provider is on\n  const chainId = await provider\n    .request({ method: \"eth_chainId\" })\n    .then(normalizeChainId);\n\n  const connectedChain =\n    chain && chain.id === chainId ? chain : getCachedChain(chainId);\n\n  return onConnect({\n    provider,\n    address,\n    chain: connectedChain,\n    emitter,\n    client,\n    id,\n  });\n}\n\nfunction createAccount({\n  provider,\n  address,\n  client,\n  id,\n}: {\n  provider: EIP1193Provider;\n  address: string;\n  client: ThirdwebClient;\n  id: WalletId | ({} & string);\n}) {\n  const account: Account = {\n    address: getAddress(address),\n    async sendTransaction(tx: SendTransactionOption) {\n      const gasFees = tx.gasPrice\n        ? {\n            gasPrice: tx.gasPrice ? numberToHex(tx.gasPrice) : undefined,\n          }\n        : {\n            maxFeePerGas: tx.maxFeePerGas\n              ? numberToHex(tx.maxFeePerGas)\n              : undefined,\n            maxPriorityFeePerGas: tx.maxPriorityFeePerGas\n              ? numberToHex(tx.maxPriorityFeePerGas)\n              : undefined,\n          };\n      const params = [\n        {\n          ...gasFees,\n          nonce: tx.nonce ? numberToHex(tx.nonce) : undefined,\n          accessList: tx.accessList,\n          value: tx.value ? numberToHex(tx.value) : undefined,\n          gas: tx.gas ? numberToHex(tx.gas) : undefined,\n          from: this.address,\n          to: tx.to ? getAddress(tx.to) : undefined,\n          data: tx.data,\n          ...tx.eip712,\n        },\n      ];\n\n      const transactionHash = (await provider.request({\n        method: \"eth_sendTransaction\",\n        // @ts-expect-error - overriding types here\n        params,\n      })) as Hex;\n\n      trackTransaction({\n        client,\n        chainId: tx.chainId,\n        walletAddress: getAddress(address),\n        walletType: id,\n        transactionHash,\n        contractAddress: tx.to ?? undefined,\n        gasPrice: tx.gasPrice,\n      });\n\n      return {\n        transactionHash,\n      };\n    },\n    async signMessage({ message }) {\n      if (!account.address) {\n        throw new Error(\"Provider not setup\");\n      }\n\n      const messageToSign = (() => {\n        if (typeof message === \"string\") {\n          return stringToHex(message);\n        }\n        if (message.raw instanceof Uint8Array) {\n          return uint8ArrayToHex(message.raw);\n        }\n        return message.raw;\n      })();\n\n      return await provider.request({\n        method: \"personal_sign\",\n        params: [messageToSign, getAddress(account.address)],\n      });\n    },\n    async signTypedData(typedData) {\n      if (!provider || !account.address) {\n        throw new Error(\"Provider not setup\");\n      }\n      const parsedTypedData = parseTypedData(typedData);\n\n      const { domain, message, primaryType } =\n        parsedTypedData as unknown as SignTypedDataParameters;\n\n      const types = {\n        EIP712Domain: getTypesForEIP712Domain({ domain }),\n        ...parsedTypedData.types,\n      };\n\n      // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n      // as we can't statically check this with TypeScript.\n      validateTypedData({ domain, message, primaryType, types });\n\n      const stringifiedData = serializeTypedData({\n        domain: domain ?? {},\n        message,\n        primaryType,\n        types,\n      });\n\n      return await provider.request({\n        method: \"eth_signTypedData_v4\",\n        params: [getAddress(account.address), stringifiedData],\n      });\n    },\n    async watchAsset(asset) {\n      const result = await provider.request(\n        {\n          method: \"wallet_watchAsset\",\n          params: asset,\n        },\n        { retryCount: 0 },\n      );\n      return result;\n    },\n  };\n\n  return account;\n}\n\n/**\n * Call this method when the wallet provider is connected or auto connected\n * @internal\n */\nasync function onConnect({\n  provider,\n  address,\n  chain,\n  emitter,\n  client,\n  id,\n}: {\n  provider: EIP1193Provider;\n  address: string;\n  chain: Chain;\n  emitter: WalletEmitter<InjectedSupportedWalletIds>;\n  client: ThirdwebClient;\n  id: WalletId | ({} & string);\n}): Promise<[Account, Chain, DisconnectFn, SwitchChainFn]> {\n  const account = createAccount({ provider, address, client, id });\n  async function disconnect() {\n    provider.removeListener(\"accountsChanged\", onAccountsChanged);\n    provider.removeListener(\"chainChanged\", onChainChanged);\n    provider.removeListener(\"disconnect\", onDisconnect);\n  }\n\n  async function onDisconnect() {\n    disconnect();\n    emitter.emit(\"disconnect\", undefined);\n  }\n\n  function onAccountsChanged(accounts: string[]) {\n    if (accounts[0]) {\n      const newAccount = createAccount({\n        provider,\n        address: getAddress(accounts[0]),\n        client,\n        id,\n      });\n\n      emitter.emit(\"accountChanged\", newAccount);\n      emitter.emit(\"accountsChanged\", accounts);\n    } else {\n      onDisconnect();\n    }\n  }\n\n  function onChainChanged(newChainId: string) {\n    const newChain = getCachedChain(normalizeChainId(newChainId));\n    emitter.emit(\"chainChanged\", newChain);\n  }\n\n  if (provider.on) {\n    provider.on(\"accountsChanged\", onAccountsChanged);\n    provider.on(\"chainChanged\", onChainChanged);\n    provider.on(\"disconnect\", onDisconnect);\n  }\n\n  return [\n    account,\n    chain,\n    onDisconnect,\n    (newChain) => switchChain(provider, newChain),\n  ] as const;\n}\n\n/**\n * @internal\n */\nasync function switchChain(provider: EIP1193Provider, chain: Chain) {\n  const hexChainId = numberToHex(chain.id);\n  try {\n    await provider.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{ chainId: hexChainId }],\n    });\n  } catch {\n    // if chain does not exist, add the chain\n    const apiChain = await getChainMetadata(chain);\n    await provider.request({\n      method: \"wallet_addEthereumChain\",\n      params: [\n        {\n          chainId: hexChainId,\n          chainName: apiChain.name,\n          nativeCurrency: apiChain.nativeCurrency,\n          rpcUrls: getValidPublicRPCUrl(apiChain), // no client id on purpose here\n          blockExplorerUrls: apiChain.explorers?.map((x) => x.url),\n        },\n      ],\n    });\n  }\n}\n\nfunction extractErrorMessage(e: unknown) {\n  if (e instanceof Error) {\n    return e.message;\n  }\n  if (typeof e === \"string\") {\n    return e;\n  }\n  if (typeof e === \"object\" && e !== null) {\n    return JSON.stringify(e);\n  }\n  return String(e);\n}\n"],
  "mappings": "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",
  "names": []
}
