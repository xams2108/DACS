{
  "version": 3,
  "sources": ["../../thirdweb/src/transaction/actions/to-serializable-transaction.ts"],
  "sourcesContent": ["import { getGasOverridesForTransaction } from \"../../gas/fee-data.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { isZkSyncChain } from \"../../utils/any-evm/zksync/isZkSyncChain.js\";\nimport { resolvePromisedValue } from \"../../utils/promise/resolve-promised-value.js\";\nimport type { Account } from \"../../wallets/interfaces/wallet.js\";\nimport type { PreparedTransaction } from \"../prepare-transaction.js\";\nimport type { SerializableTransaction } from \"../serialize-transaction.js\";\nimport { encode } from \"./encode.js\";\nimport { estimateGas } from \"./estimate-gas.js\";\n\nexport type ToSerializableTransactionOptions = {\n  /**\n   * The transaction to convert to a serializable transaction.\n   */\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n  transaction: PreparedTransaction<any>;\n  /**\n   * The from address or account to use for gas estimation and authorization signing.\n   */\n  from?: string | Account;\n};\n\n/**\n * Converts a prepared transaction to a transaction with populated options.\n * @param options - The transaction and additional options for conversion\n * @returns A serializable transaction for inspection or submission to an account.\n *\n *  For easier transaction sending, {@see sendTransaction}\n * @example\n * ```ts\n * import { prepareTransaction, toSerializableTransaction } from \"thirdweb\";\n *\n * const transaction = await prepareTransaction({\n *   transaction: {\n *     to: \"0x...\",\n *     value: 100,\n *   },\n * });\n * const finalTx = await toSerializableTransaction({\n *   transaction,\n * });\n *\n * account.sendTransaction(finalTx);\n * ```\n * @transaction\n */\nexport async function toSerializableTransaction(\n  options: ToSerializableTransactionOptions,\n) {\n  // zk chains require a different rpc method for gas estimation and gas fees\n  const isZkSync = await isZkSyncChain(options.transaction.chain);\n  if (isZkSync) {\n    const { getZkGasFees } = await import(\n      \"./zksync/send-eip712-transaction.js\"\n    );\n    const { gas, maxFeePerGas, maxPriorityFeePerGas } = await getZkGasFees({\n      transaction: options.transaction,\n      from:\n        typeof options.from === \"string\" // Is this just an address?\n          ? getAddress(options.from)\n          : options.from !== undefined // Is this an account?\n            ? getAddress(options.from.address)\n            : undefined,\n    });\n    // passing these values here will avoid re-fetching them below\n    options.transaction = {\n      ...options.transaction,\n      gas,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n    };\n  }\n\n  const rpcRequest = getRpcClient(options.transaction);\n  const chainId = options.transaction.chain.id;\n  const from = options.from;\n  let [\n    data,\n    nonce,\n    gas,\n    feeData,\n    to,\n    accessList,\n    value,\n    authorizationList,\n    type,\n  ] = await Promise.all([\n    encode(options.transaction),\n    (async () => {\n      // if the user has specified a nonce, use that\n      const resolvedNonce = await resolvePromisedValue(\n        options.transaction.nonce,\n      );\n      if (resolvedNonce !== undefined) {\n        return resolvedNonce;\n      }\n\n      return from // otherwise get the next nonce (import the method to do so)\n        ? await import(\"../../rpc/actions/eth_getTransactionCount.js\").then(\n            ({ eth_getTransactionCount }) =>\n              eth_getTransactionCount(rpcRequest, {\n                address:\n                  typeof from === \"string\"\n                    ? getAddress(from)\n                    : getAddress(from.address),\n                blockTag: \"pending\",\n              }),\n          )\n        : undefined;\n    })(),\n    // takes the same options as the sendTransaction function thankfully!\n    estimateGas({\n      ...options,\n      from: options.from,\n    }),\n    getGasOverridesForTransaction(options.transaction),\n    resolvePromisedValue(options.transaction.to),\n    resolvePromisedValue(options.transaction.accessList),\n    resolvePromisedValue(options.transaction.value),\n    resolvePromisedValue(options.transaction.authorizationList),\n    resolvePromisedValue(options.transaction.type),\n  ]);\n\n  const extraGas = await resolvePromisedValue(options.transaction.extraGas);\n  if (extraGas) {\n    gas += extraGas;\n  }\n\n  return {\n    to,\n    chainId,\n    data,\n    gas,\n    nonce,\n    accessList,\n    value,\n    authorizationList,\n    type,\n    ...feeData,\n  } satisfies SerializableTransaction;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AA+CA,eAAsB,0BACpB,SAAyC;AAGzC,QAAM,WAAW,MAAM,cAAc,QAAQ,YAAY,KAAK;AAC9D,MAAI,UAAU;AACZ,UAAM,EAAE,aAAY,IAAK,MAAM,OAC7B,uCAAqC;AAEvC,UAAM,EAAE,KAAAA,MAAK,cAAc,qBAAoB,IAAK,MAAM,aAAa;MACrE,aAAa,QAAQ;MACrB,MACE,OAAO,QAAQ,SAAS,WACpB,WAAW,QAAQ,IAAI,IACvB,QAAQ,SAAS,SACf,WAAW,QAAQ,KAAK,OAAO,IAC/B;KACT;AAED,YAAQ,cAAc;MACpB,GAAG,QAAQ;MACX,KAAAA;MACA;MACA;;EAEJ;AAEA,QAAM,aAAa,aAAa,QAAQ,WAAW;AACnD,QAAM,UAAU,QAAQ,YAAY,MAAM;AAC1C,QAAM,OAAO,QAAQ;AACrB,MAAI,CACF,MACA,OACA,KACA,SACA,IACA,YACA,OACA,mBACA,IAAI,IACF,MAAM,QAAQ,IAAI;IACpB,OAAO,QAAQ,WAAW;KACzB,YAAW;AAEV,YAAM,gBAAgB,MAAM,qBAC1B,QAAQ,YAAY,KAAK;AAE3B,UAAI,kBAAkB,QAAW;AAC/B,eAAO;MACT;AAEA,aAAO,OACH,MAAM,OAAO,uCAA8C,EAAE,KAC3D,CAAC,EAAE,wBAAuB,MACxB,wBAAwB,YAAY;QAClC,SACE,OAAO,SAAS,WACZ,WAAW,IAAI,IACf,WAAW,KAAK,OAAO;QAC7B,UAAU;OACX,CAAC,IAEN;IACN,GAAE;;IAEF,YAAY;MACV,GAAG;MACH,MAAM,QAAQ;KACf;IACD,8BAA8B,QAAQ,WAAW;IACjD,qBAAqB,QAAQ,YAAY,EAAE;IAC3C,qBAAqB,QAAQ,YAAY,UAAU;IACnD,qBAAqB,QAAQ,YAAY,KAAK;IAC9C,qBAAqB,QAAQ,YAAY,iBAAiB;IAC1D,qBAAqB,QAAQ,YAAY,IAAI;GAC9C;AAED,QAAM,WAAW,MAAM,qBAAqB,QAAQ,YAAY,QAAQ;AACxE,MAAI,UAAU;AACZ,WAAO;EACT;AAEA,SAAO;IACL;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,GAAG;;AAEP;",
  "names": ["gas"]
}
