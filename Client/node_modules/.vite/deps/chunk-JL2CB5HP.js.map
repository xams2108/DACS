{
  "version": 3,
  "sources": ["../../thirdweb/src/transaction/types.ts", "../../thirdweb/src/rpc/actions/eth_getLogs.ts", "../../thirdweb/src/event/actions/get-events.ts", "../../thirdweb/src/utils/retry.ts", "../../thirdweb/src/event/actions/watch-events.ts", "../../thirdweb/src/transaction/actions/simulate.ts", "../../thirdweb/src/pay/buyWithCrypto/getHistory.ts"],
  "sourcesContent": ["import type {\n  Abi,\n  AbiFunction,\n  AbiParameter,\n  AbiParametersToPrimitiveTypes,\n  ExtractAbiFunction,\n  ParseAbiItem,\n} from \"abitype\";\nimport type { TransactionReceipt as ViemTransactionReceipt } from \"viem\";\nimport type { ThirdwebContract } from \"../contract/contract.js\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\nimport { isObjectWithKeys } from \"../utils/type-guards.js\";\nimport type {\n  PreparedTransaction,\n  StaticPrepareTransactionOptions,\n} from \"./prepare-transaction.js\";\n\nexport type SendTransactionResult = {\n  readonly transactionHash: Hex;\n};\n\nexport type TransactionReceipt = ViemTransactionReceipt;\n\nexport type WithOverrides<T> = T & {\n  overrides?: Omit<\n    StaticPrepareTransactionOptions,\n    \"to\" | \"from\" | \"data\" | \"maxFeePerBlobGas\" | \"chain\" | \"client\"\n  >;\n};\n\nexport type ParamsOption<inputs extends readonly AbiParameter[]> =\n  inputs extends {\n    length: 0;\n  }\n    ? // allow omitting \"params\" if there are no inputs\n      { params?: readonly unknown[] }\n    : {\n        params:\n          | Readonly<AbiParametersToPrimitiveTypes<inputs>>\n          | (() => Promise<Readonly<AbiParametersToPrimitiveTypes<inputs>>>);\n      };\n\nexport type BaseTransactionOptions<\n  T extends object = object,\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n  abi extends Abi = any,\n> = {\n  contract: ThirdwebContract<abi>;\n} & T;\n// type-guard\n/**\n * Checks if the given value is of type TxOpts.\n * @param value - The value to check.\n * @returns True if the value is of type TxOpts, false otherwise.\n * @internal\n */\nexport function isBaseTransactionOptions(\n  value: unknown,\n): value is PreparedTransaction {\n  return (\n    isObjectWithKeys(value, [\"__contract\"]) &&\n    isObjectWithKeys(value.__contract, [\"address\", \"chain\"]) &&\n    typeof value.__contract.address === \"string\"\n  );\n}\n\nexport type ParseMethod<\n  abi extends Abi,\n  method extends\n    | AbiFunction\n    | string\n    | ((contract: ThirdwebContract<abi>) => Promise<AbiFunction>),\n> = method extends AbiFunction // if the method IS an AbiFunction, return it\n  ? method\n  : method extends string // we now know we are in \"string\" territory\n    ? // if the string starts with `function` then we can parse it\n      method extends `function ${string}`\n      ? ParseAbiItem<method> extends AbiFunction\n        ? ParseAbiItem<method>\n        : never\n      : // do we have an ABI to check, check the length\n        abi extends { length: 0 }\n        ? // if not, we return AbiFunction\n          AbiFunction\n        : // if we do have a length, extract the abi function\n          ExtractAbiFunction<abi, method>\n    : // this means its neither have an AbiFunction NOR a string -> never\n      AbiFunction;\n", "import {\n  type BlockNumber,\n  type BlockTag,\n  type EIP1193RequestFn,\n  type EIP1474Methods,\n  type Hash,\n  type LogTopic,\n  type RpcLog,\n  formatLog,\n} from \"viem\";\nimport { type Address, getAddress } from \"../../utils/address.js\";\nimport { numberToHex } from \"../../utils/encoding/hex.js\";\n\nexport type GetLogsBlockParams =\n  | {\n      fromBlock?: BlockNumber | BlockTag;\n      toBlock?: BlockNumber | BlockTag;\n      blockHash?: never;\n      blockRange?: never;\n    }\n  | {\n      fromBlock?: never;\n      toBlock?: never;\n      blockHash?: Hash;\n      blockRange?: never;\n    }\n  | {\n      fromBlock?: BlockNumber | \"latest\";\n      toBlock?: never;\n      blockRange: BlockNumber;\n      blockHash?: never;\n    }\n  | {\n      fromBlock?: never;\n      toBlock?: BlockNumber | \"latest\";\n      blockRange: BlockNumber;\n      blockHash?: never;\n    }\n  | {\n      fromBlock?: never;\n      toBlock?: never;\n      blockRange: BlockNumber;\n      blockHash?: never;\n    };\n\nexport type GetLogsParams = {\n  topics?: LogTopic[];\n  address?: Address;\n} & GetLogsBlockParams;\n\n/**\n * Retrieves logs from the Ethereum blockchain based on the specified parameters.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for retrieving logs.\n * @returns A promise that resolves to the retrieved logs.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_getLogs } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const logs = await eth_getLogs(rpcRequest, {\n *  address: \"0x...\",\n *  fromBlock: 123456n,\n *  toBlock: 123456n,\n * });\n * ```\n */\nexport async function eth_getLogs(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: GetLogsParams = {},\n) {\n  const topics = params.topics ?? [];\n\n  let logs: RpcLog[];\n  // in the case we have a blockHash\n  if (params.blockHash) {\n    const param: {\n      address?: Address | Address[];\n      topics: LogTopic[];\n      blockHash: `0x${string}`;\n    } = {\n      topics,\n      blockHash: params.blockHash,\n    };\n    if (params.address) {\n      param.address = getAddress(params.address);\n    }\n    logs = await request({\n      method: \"eth_getLogs\",\n      params: [param],\n    });\n  }\n  // otherwise\n  else {\n    const param: {\n      address?: Address | Address[];\n      topics?: LogTopic[];\n    } & (\n      | {\n          fromBlock?: BlockTag | `0x${string}`;\n          toBlock?: BlockTag | `0x${string}`;\n          blockHash?: never;\n        }\n      | {\n          fromBlock?: never;\n          toBlock?: never;\n          blockHash?: `0x${string}`;\n        }\n    ) = { topics };\n    if (params.address) {\n      param.address = params.address;\n    }\n\n    if (params.fromBlock) {\n      param.fromBlock =\n        typeof params.fromBlock === \"bigint\"\n          ? numberToHex(params.fromBlock)\n          : params.fromBlock;\n    }\n    if (params.toBlock) {\n      param.toBlock =\n        typeof params.toBlock === \"bigint\"\n          ? numberToHex(params.toBlock)\n          : params.toBlock;\n    }\n\n    logs = await request({\n      method: \"eth_getLogs\",\n      params: [param],\n    });\n  }\n\n  return logs.map((log) => formatLog(log));\n}\n", "import type {\n  Abi,\n  AbiEvent,\n  ExtractAbiEvent,\n  ExtractAbiEventNames,\n} from \"abitype\";\nimport { type Log, formatLog } from \"viem\";\nimport { resolveContractAbi } from \"../../contract/actions/resolve-abi.js\";\nimport type { ThirdwebContract } from \"../../contract/contract.js\";\nimport {\n  type ContractEvent,\n  getContractEvents as getContractEventsInsight,\n} from \"../../insight/get-events.js\";\nimport { eth_blockNumber } from \"../../rpc/actions/eth_blockNumber.js\";\nimport {\n  type GetLogsBlockParams,\n  type GetLogsParams,\n  eth_getLogs,\n} from \"../../rpc/actions/eth_getLogs.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { type Hex, numberToHex } from \"../../utils/encoding/hex.js\";\nimport type { Prettify } from \"../../utils/type-utils.js\";\nimport { type PreparedEvent, prepareEvent } from \"../prepare-event.js\";\nimport { isAbiEvent } from \"../utils.js\";\nimport { type ParseEventLogsResult, parseEventLogs } from \"./parse-logs.js\";\n\nexport type GetContractEventsOptionsDirect<\n  abi extends Abi,\n  abiEvents extends PreparedEvent<AbiEvent>[],\n  TStrict extends boolean,\n> = {\n  contract: ThirdwebContract<abi>;\n  events?: abiEvents;\n  strict?: TStrict;\n  useIndexer?: boolean;\n};\n\nexport type GetContractEventsOptions<\n  abi extends Abi,\n  abiEvents extends PreparedEvent<AbiEvent>[],\n  TStrict extends boolean,\n> = Prettify<\n  GetContractEventsOptionsDirect<abi, abiEvents, TStrict> & GetLogsBlockParams\n>;\n\nexport type GetContractEventsResult<\n  abiEvents extends PreparedEvent<AbiEvent>[],\n  TStrict extends boolean,\n> = ParseEventLogsResult<abiEvents, TStrict>;\n\ntype GetLogsParamsExtra = {\n  signature?: string;\n} & GetLogsParams;\n\n/**\n * Retrieves events from a contract based on the provided options.\n * @param options - The options for retrieving events.\n * @returns A promise that resolves to an array of parsed event logs.\n * Note: toBlock and fromBlock are both inclusive.\n * @example\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * const events = await getContractEvents({\n *  contract: myContract,\n *  fromBlock: 123456n,\n *  toBlock: 123456n,\n *  events: [preparedEvent, preparedEvent2],\n * });\n * ```\n * @example\n * Optionally specify a blockRange as the number of blocks to retrieve. toBlock will default to the current block number.\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * const events = await getContractEvents({\n *  contract: myContract,\n *  blockRange: 123456n,\n *  events: [preparedEvent, preparedEvent2],\n * });\n * ```\n * @example\n * Use fromBlock with blockRange for pagination.\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * const events = await getContractEvents({\n *  contract: myContract,\n *  fromBlock: lastBlockFetched,\n *  blockRange: 123456n,\n *  events: [preparedEvent, preparedEvent2],\n * });\n * ```\n * @example\n * Retrieve events for a specific block hash.\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * const events = await getContractEvents({\n *  contract: myContract,\n *  blockHash: \"0x...\",\n *  events: [preparedEvent, preparedEvent2],\n * });\n * ```\n * @contract\n */\nexport async function getContractEvents<\n  const abi extends Abi,\n  const abiEvents extends PreparedEvent<AbiEvent>[] = PreparedEvent<\n    ExtractAbiEvent<abi, ExtractAbiEventNames<abi>>\n  >[],\n  const TStrict extends boolean = true,\n>(\n  options: GetContractEventsOptions<abi, abiEvents, TStrict>,\n): Promise<GetContractEventsResult<abiEvents, TStrict>> {\n  const {\n    contract,\n    events,\n    blockRange,\n    useIndexer = true,\n    ...restParams\n  } = options;\n\n  const rpcRequest = getRpcClient(contract);\n\n  if (\n    restParams.blockHash &&\n    (blockRange || restParams.fromBlock || restParams.toBlock)\n  ) {\n    throw new Error(\"Cannot specify blockHash and range simultaneously,\");\n  }\n\n  const latestBlockNumber = await eth_blockNumber(rpcRequest);\n\n  // Compute toBlock and fromBlock if blockRange was passed\n  if (blockRange) {\n    const { fromBlock, toBlock } = restParams;\n\n    // Make sure the inputs were properly defined\n    if (\n      fromBlock !== undefined &&\n      toBlock !== undefined &&\n      BigInt(toBlock) - BigInt(fromBlock) !== BigInt(blockRange)\n    ) {\n      throw new Error(\n        \"Incompatible blockRange with specified fromBlock and toBlock. Please only define fromBlock or toBlock when specifying blockRange.\",\n      );\n    }\n\n    if (fromBlock !== undefined) {\n      restParams.toBlock = BigInt(fromBlock) + BigInt(blockRange) - 1n; // Subtract one because toBlock is inclusive\n    } else if (toBlock !== undefined) {\n      restParams.fromBlock = BigInt(toBlock) - BigInt(blockRange) + 1n; // Add one because fromBlock is inclusive\n    } else {\n      // If no from or to block specified, use the latest block as the to block\n      restParams.toBlock = latestBlockNumber;\n      restParams.fromBlock = latestBlockNumber - BigInt(blockRange) + 1n; // Add one because fromBlock is inclusive\n    }\n  }\n\n  let resolvedEvents = events ?? [];\n\n  // if we have an abi on the contract, we can encode the topics with it\n  if (!events?.length && !!contract) {\n    if (useIndexer) {\n      // fetch all events from the indexer, no need to get events from ABI\n      const events = await getContractEventsInsight({\n        client: contract.client,\n        chains: [contract.chain],\n        contractAddress: contract.address,\n        decodeLogs: true,\n        queryOptions: {\n          limit: 500,\n          filter_block_hash: restParams.blockHash,\n          filter_block_number_gte: restParams.fromBlock,\n          filter_block_number_lte: restParams.toBlock,\n        },\n      }).catch(() => {\n        // chain might not support indexer\n        return null;\n      });\n      if (events) {\n        return toLog(events) as GetContractEventsResult<abiEvents, TStrict>;\n      }\n    }\n\n    // if we have a contract *WITH* an abi we can use that\n    if (contract.abi?.length) {\n      // @ts-expect-error - we can't make typescript happy here, but we know this is an abi event\n      resolvedEvents = contract.abi\n        .filter(isAbiEvent)\n        .map((abiEvent) => prepareEvent({ signature: abiEvent }));\n    } else {\n      const runtimeAbi = await resolveContractAbi(contract);\n      // @ts-expect-error - we can't make typescript happy here, but we know this is an abi event\n      resolvedEvents = runtimeAbi\n        .filter(isAbiEvent)\n        .map((abiEvent) => prepareEvent({ signature: abiEvent }));\n    }\n  }\n\n  const logsParams: GetLogsParamsExtra[] =\n    events && events.length > 0\n      ? // if we have events passed in then we use those\n        events.map((e) => ({\n          ...restParams,\n          address: getAddress(contract.address),\n          topics: e.topics,\n        }))\n      : // otherwise we want \"all\" events (aka not pass any topics at all)\n        [{ ...restParams, address: getAddress(contract.address) }];\n\n  let logs: Log[][] = [];\n\n  // try fetching from insight if available\n  if (useIndexer) {\n    try {\n      logs = await Promise.all(\n        logsParams.map((p) =>\n          getLogsFromInsight({\n            params: p,\n            contract,\n          }),\n        ),\n      );\n    } catch (e) {\n      console.warn(\"Error fetching from insight, falling back to rpc\", e);\n      // fetch from rpc\n      logs = await Promise.all(\n        logsParams.map((ethLogParams) => eth_getLogs(rpcRequest, ethLogParams)),\n      );\n    }\n  } else {\n    // fetch from rpc\n    logs = await Promise.all(\n      logsParams.map((ethLogParams) => eth_getLogs(rpcRequest, ethLogParams)),\n    );\n  }\n\n  const flattenLogs = logs\n    .flat()\n    .sort((a, b) => Number((a.blockNumber ?? 0n) - (b.blockNumber ?? 0n)));\n  return parseEventLogs({\n    logs: flattenLogs,\n    events: resolvedEvents,\n  });\n}\n\nasync function getLogsFromInsight(options: {\n  params: GetLogsParamsExtra;\n  contract: ThirdwebContract<Abi>;\n}): Promise<Log[]> {\n  const { params, contract } = options;\n\n  const fromBlock =\n    typeof params.fromBlock === \"bigint\" ? Number(params.fromBlock) : undefined;\n\n  const toBlock =\n    typeof params.toBlock === \"bigint\" ? Number(params.toBlock) : undefined;\n\n  const r = await getContractEventsInsight({\n    client: contract.client,\n    chains: [contract.chain],\n    contractAddress: contract.address,\n    queryOptions: {\n      limit: 500,\n      filter_block_hash: params.blockHash,\n      filter_block_number_gte: fromBlock,\n      filter_block_number_lte: toBlock,\n      filter_topic_0: params.topics?.[0] as Hex | undefined,\n      filter_topic_1: params.topics?.[1] as Hex | undefined,\n      filter_topic_2: params.topics?.[2] as Hex | undefined,\n      filter_topic_3: params.topics?.[3] as Hex | undefined,\n    },\n  });\n\n  return toLog(r);\n}\n\nfunction toLog(r: ContractEvent[]) {\n  const cleanedEventData = r.map((tx) => ({\n    chainId: tx.chain_id,\n    blockNumber: numberToHex(Number(tx.block_number)),\n    blockHash: tx.block_hash as Hex,\n    blockTimestamp: tx.block_timestamp,\n    transactionHash: tx.transaction_hash as Hex,\n    transactionIndex: numberToHex(tx.transaction_index),\n    logIndex: numberToHex(tx.log_index),\n    address: tx.address,\n    data: tx.data as Hex,\n    topics: tx.topics as [`0x${string}`, ...`0x${string}`[]] | [] | undefined,\n    ...(tx.decoded\n      ? {\n          eventName: tx.decoded.name,\n          args: {\n            ...tx.decoded.indexed_params,\n            ...tx.decoded.non_indexed_params,\n          },\n        }\n      : {}),\n  }));\n\n  return cleanedEventData\n    .map((e) => formatLog(e))\n    .sort((a, b) => Number((a.blockNumber ?? 0n) - (b.blockNumber ?? 0n)));\n}\n", "/**\n * Attempts to execute a function that returns a promise and retries if the function throws an error.\n *\n * @param {Function} fn - A function that returns a promise to be executed.\n * @param {Object} options - Configuration options for the retry behavior.\n * @param {number} [options.retries=1] - The number of times to retry the function before failing.\n * @param {number} [options.delay=0] - The delay in milliseconds between retries.\n * @returns {Promise<void>} The result of the function execution if successful.\n */\n\nexport async function retry<T>(\n  fn: () => Promise<T>,\n  options: { retries?: number; delay?: number },\n): Promise<T> {\n  const retries = options.retries ?? 1;\n  const delay = options.delay ?? 0;\n  let lastError: Error | null = null;\n  for (let i = 0; i < retries; i++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error as Error;\n      if (delay > 0) {\n        await new Promise((resolve) => setTimeout(resolve, delay));\n      }\n    }\n  }\n  throw lastError;\n}\n", "import type { Abi, AbiEvent } from \"abitype\";\nimport {\n  type GetContractEventsOptionsDirect,\n  getContractEvents,\n} from \"./get-events.js\";\n\nimport { watchBlockNumber } from \"../../rpc/watchBlockNumber.js\";\nimport { retry } from \"../../utils/retry.js\";\nimport type { Prettify } from \"../../utils/type-utils.js\";\nimport type { PreparedEvent } from \"../prepare-event.js\";\nimport type { ParseEventLogsResult } from \"./parse-logs.js\";\n\nexport type WatchContractEventsOptions<\n  abi extends Abi,\n  abiEvents extends PreparedEvent<AbiEvent>[],\n  TStrict extends boolean,\n> = Prettify<\n  GetContractEventsOptionsDirect<abi, abiEvents, TStrict> & {\n    onEvents: (events: ParseEventLogsResult<abiEvents, TStrict>) => void;\n    latestBlockNumber?: bigint;\n  }\n>;\n\n/**\n * Listens for  contract events from the blockchain.\n * @param options - The options for retrieving contract events.\n * @returns The unwatch function.\n * @example\n * ### Listen to all events for a contract\n * ```ts\n * import { watchContractEvents } from \"thirdweb\";\n * const unwatch = watchContractEvents({\n *  contract: myContract,\n *  onEvents: (events) => {\n *   // do something with the events\n *  },\n * });\n * ```\n *\n * ### Listen to specific events for a contract\n * ```ts\n * import { prepareEvent, watchContractEvents } from \"thirdweb\";\n * const myEvent = prepareEvent({\n *  event: \"event MyEvent(uint256 myArg)\",\n * });\n * const events = await watchContractEvents({\n *  contract: myContract,\n *  events: [myEvent],\n *  onEvents: (events) => {\n *   // do something with the events\n *  },\n * });\n * ```\n * @contract\n */\nexport function watchContractEvents<\n  const abi extends Abi,\n  const abiEvents extends PreparedEvent<AbiEvent>[],\n  const TStrict extends boolean = true,\n>(options: WatchContractEventsOptions<abi, abiEvents, TStrict>) {\n  // returning this returns the underlying \"unwatch\" function\n  return watchBlockNumber({\n    ...options.contract,\n\n    /**\n     * This function is called every time a new block is mined.\n     * @param blockNumber - The block number of the new block.\n     * @returns A promise that resolves when the function is finished.\n     * @internal\n     */\n    onNewBlockNumber: async (blockNumber) => {\n      const logs = await retry(\n        async () =>\n          getContractEvents({\n            ...options,\n            // fromBlock is inclusive\n            fromBlock: blockNumber,\n            // toBlock is inclusive\n            toBlock: blockNumber,\n            useIndexer: false,\n          }),\n        {\n          retries: 3,\n          delay: 500,\n        },\n      );\n      // if there were any logs associated with our event(s)\n      if (logs.length) {\n        options.onEvents(logs);\n      }\n    },\n    latestBlockNumber: options.latestBlockNumber,\n  });\n}\n", "import type { Abi, AbiFunction } from \"abitype\";\nimport { decodeAbiParameters, formatTransactionRequest } from \"viem\";\nimport { eth_call } from \"../../rpc/actions/eth_call.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport type { PreparedMethod } from \"../../utils/abi/prepare-method.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { resolvePromisedValue } from \"../../utils/promise/resolve-promised-value.js\";\nimport type { Prettify } from \"../../utils/type-utils.js\";\nimport type { Account } from \"../../wallets/interfaces/wallet.js\";\nimport { extractError } from \"../extract-error.js\";\nimport type { PreparedTransaction } from \"../prepare-transaction.js\";\nimport type { ReadContractResult } from \"../read-contract.js\";\nimport { encode } from \"./encode.js\";\n\nexport type SimulateOptions<\n  abi extends Abi,\n  abiFn extends AbiFunction,\n> = Prettify<\n  {\n    transaction: PreparedTransaction<abi, abiFn>;\n  } & (\n    | {\n        account: Account;\n        from?: never;\n      }\n    | {\n        account?: never;\n        from?: string;\n      }\n  )\n>;\n\n/**\n * Simulates the execution of a transaction.\n * @param options - The options for simulating the transaction.\n * @returns A promise that resolves to the result of the simulation.\n * @transaction\n * @example\n * ```ts\n * import { simulateTransaction } from \"thirdweb\";\n * const result = await simulateTransaction({\n *  transaction,\n * });\n * ```\n */\nexport async function simulateTransaction<\n  const abi extends Abi,\n  const abiFn extends AbiFunction,\n>(options: SimulateOptions<abi, abiFn>) {\n  const [data, to, accessList, value] = await Promise.all([\n    encode(options.transaction),\n    resolvePromisedValue(options.transaction.to),\n    resolvePromisedValue(options.transaction.accessList),\n    resolvePromisedValue(options.transaction.value),\n  ]);\n\n  // from is:\n  // 1. the user specified from address\n  // 2. the passed in account address\n  // 3. the passed in wallet's account address\n  const from = options.from ?? options.account?.address ?? undefined;\n\n  const serializedTx = formatTransactionRequest({\n    data,\n    from: from ? getAddress(from) : undefined,\n    to: to ? getAddress(to) : undefined,\n    value,\n    accessList,\n  });\n\n  const rpcRequest = getRpcClient(options.transaction);\n  try {\n    const result = await eth_call(rpcRequest, serializedTx);\n\n    if (!options.transaction.__preparedMethod) {\n      return result;\n    }\n\n    const prepared = await options.transaction.__preparedMethod();\n\n    const decoded = decodeAbiParameters(prepared[2], result);\n\n    if (Array.isArray(decoded) && decoded.length === 1) {\n      return decoded[0];\n    }\n\n    return decoded as ReadContractResult<PreparedMethod<abiFn>[2]>;\n  } catch (error) {\n    throw await extractError({\n      error,\n      contract: options.transaction.__contract,\n    });\n  }\n}\n", "import type { ThirdwebClient } from \"../../client/client.js\";\nimport { getClientFetch } from \"../../utils/fetch.js\";\nimport { getPayBuyWithCryptoHistoryEndpoint } from \"../utils/definitions.js\";\nimport type { BuyWithCryptoStatus } from \"./getStatus.js\";\n\n/**\n * The parameters for [`getBuyWithCryptoHistory`](https://portal.thirdweb.com/references/typescript/v5/getBuyWithCryptoHistory) function\n * It takes the wallet history address and optional cursor and page size. for paginated results.\n * @buyCrypto\n */\nexport type BuyWithCryptoHistoryParams = {\n  /**\n   * A client is the entry point to the thirdweb SDK. It is required for all other actions.\n   *\n   * You can create a client using the `createThirdwebClient` function.\n   * Refer to the [Creating a Client](https://portal.thirdweb.com/typescript/v5/client) documentation for more information.\n   *\n   */\n  client: ThirdwebClient;\n  /**\n   * The address of the wallet to get the wallet history for\n   */\n  walletAddress: string;\n  /**\n   * The number of results to return in a single page. The default value is 10.\n   */\n  count: number;\n  /**\n   * The cursor for the page of results to return. The default value is `undefined`.\n   */\n  start: number;\n};\n\n/**\n * The results for [`getBuyWithCryptoHistory`](https://portal.thirdweb.com/references/typescript/v5/getBuyWithCryptoHistory) function\n * It includes information about transactions that the wallet address has made through thirdweb buy with crypto.\n * @buyCrypto\n */\nexport type BuyWithCryptoHistoryData = {\n  page: BuyWithCryptoStatus[];\n  hasNextPage: boolean;\n};\n\n/**\n * Gets the History of purchases for a given wallet address\n * @param params Object of type [`BuyWithCryptoHistoryParams`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoHistoryParams)\n * @example\n *\n * ```ts\n * import { createThirdwebClient } from \"thirdweb\";\n * import { BuyWithCryptoHistoryData } from \"thirdweb/pay\";\n *\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const walletAddress = \"0x...\";\n * const params = {\n *  client,\n *  walletAddress,\n * };\n *\n * // grabs the history of purchase transactions for the wallet address\n * const status = await getBuyWithCryptoHistory(params)\n * ```\n * @returns Object of type [`BuyWithCryptoHistoryData`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoHistoryData)\n * @buyCrypto\n */\nexport async function getBuyWithCryptoHistory(\n  params: BuyWithCryptoHistoryParams,\n): Promise<BuyWithCryptoHistoryData> {\n  try {\n    const queryParams = new URLSearchParams();\n    queryParams.append(\"walletAddress\", params.walletAddress);\n    queryParams.append(\"start\", params.start.toString());\n    queryParams.append(\"count\", params.count.toString());\n\n    const queryString = queryParams.toString();\n    const url = `${getPayBuyWithCryptoHistoryEndpoint()}?${queryString}`;\n\n    const response = await getClientFetch(params.client)(url);\n\n    // Assuming the response directly matches the SwapResponse interface\n    if (!response.ok) {\n      const error = await response.text().catch(() => null);\n      throw new Error(\n        `HTTP error! status: ${response.status} - ${response.statusText}: ${error || \"unknown error\"}`,\n      );\n    }\n\n    const data: BuyWithCryptoHistoryData = (await response.json()).result;\n    return data;\n  } catch (error) {\n    throw new Error(`Fetch failed: ${error}`);\n  }\n}\n"],
  "mappings": "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",
  "names": ["getContractEvents", "events", "getContractEvents"]
}
