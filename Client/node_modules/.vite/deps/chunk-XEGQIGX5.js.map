{
  "version": 3,
  "sources": ["../../thirdweb/src/chains/constants.ts", "../../thirdweb/src/transaction/actions/estimate-gas-cost.ts", "../../thirdweb/src/transaction/utils.ts", "../../thirdweb/src/utils/encoding/helpers/byte-size.ts", "../../thirdweb/src/utils/abi/encodeAbiParameters.ts", "../../thirdweb/src/utils/abi/prepare-method.ts"],
  "sourcesContent": ["import { baseSepolia } from \"./chain-definitions/base-sepolia.js\";\nimport { base } from \"./chain-definitions/base.js\";\nimport { optimismSepolia } from \"./chain-definitions/optimism-sepolia.js\";\nimport { optimism } from \"./chain-definitions/optimism.js\";\nimport { zoraSepolia } from \"./chain-definitions/zora-sepolia.js\";\nimport { zora } from \"./chain-definitions/zora.js\";\nimport type { Chain } from \"./types.js\";\n\nconst opChains = [\n  base.id,\n  baseSepolia.id,\n  optimism.id,\n  optimismSepolia.id,\n  zora.id,\n  zoraSepolia.id,\n  34443, // mode\n  919, // mode testnet\n  42220, // celo\n  44787, // celo testnet\n  204, // opBNB\n  5611, // opBNB testnet\n];\n\n/**\n * TODO this should be in the chain definition itself\n * @internal\n */\nexport async function isOpStackChain(chain: Chain) {\n  if (chain.id === 1337 || chain.id === 31337) {\n    return false;\n  }\n\n  if (opChains.includes(chain.id)) {\n    return true;\n  }\n  // fallback to checking the stack on rpc\n  try {\n    const { getChainMetadata } = await import(\"./utils.js\");\n    const chainMetadata = await getChainMetadata(chain);\n    return chainMetadata.stackType === \"optimism_bedrock\";\n  } catch {\n    // If the network check fails, assume it's not a OP chain\n    return false;\n  }\n}\n", "import { isOpStackChain } from \"../../chains/constants.js\";\nimport { getDefaultGasOverrides } from \"../../gas/fee-data.js\";\nimport { resolvePromisedValue } from \"../../utils/promise/resolve-promised-value.js\";\nimport { toEther } from \"../../utils/units.js\";\nimport { type EstimateGasOptions, estimateGas } from \"./estimate-gas.js\";\n\nexport type EstimateGasCostResult = {\n  /**\n   * The estimated gas cost in ether.\n   */\n  ether: string;\n  /**\n   * The estimated gas cost in wei.\n   */\n  wei: bigint;\n};\n\n/**\n * Estimate the gas cost of a transaction in ether and wei.\n * @example\n * ```ts\n * import { estimateGasCost } from \"thirdweb\";\n *\n * const gasCost = await estimateGasCost({ transaction });\n * ```\n * @transaction\n */\nexport async function estimateGasCost(\n  options: EstimateGasOptions,\n): Promise<EstimateGasCostResult> {\n  const { transaction } = options;\n  const from = options.from ?? options.account?.address ?? undefined;\n  const gasLimit =\n    (await resolvePromisedValue(transaction.gas)) ||\n    (await estimateGas({ transaction, from }));\n  const fees = await getDefaultGasOverrides(\n    transaction.client,\n    transaction.chain,\n  );\n  const gasPrice = fees.maxFeePerGas || fees.gasPrice;\n  if (gasPrice === undefined) {\n    throw new Error(\n      `Unable to determine gas price for chain ${transaction.chain.id}`,\n    );\n  }\n  let l1Fee: bigint;\n  if (await isOpStackChain(transaction.chain)) {\n    const { estimateL1Fee } = await import(\"../../gas/estimate-l1-fee.js\");\n    l1Fee = await estimateL1Fee({\n      transaction,\n    });\n  } else {\n    l1Fee = 0n;\n  }\n  const wei = gasLimit * gasPrice + l1Fee;\n  return {\n    ether: toEther(wei),\n    wei,\n  };\n}\n", "import type { AbiFunction } from \"abitype\";\nimport { getGasPrice } from \"../gas/get-gas-price.js\";\nimport { estimateGasCost } from \"./actions/estimate-gas-cost.js\";\nimport type { PreparedTransaction } from \"./prepare-transaction.js\";\n\n/**\n * @internal\n */\nexport function isAbiFunction(item: unknown): item is AbiFunction {\n  return !!(\n    item &&\n    typeof item === \"object\" &&\n    \"type\" in item &&\n    item.type === \"function\"\n  );\n}\n\nexport async function getTransactionGasCost(\n  tx: PreparedTransaction,\n  from?: string,\n) {\n  try {\n    const gasCost = await estimateGasCost({\n      transaction: tx,\n      from,\n    });\n\n    const bufferCost = gasCost.wei / 10n;\n\n    // Note: get tx.value AFTER estimateGasCost\n    // add 10% extra gas cost to the estimate to ensure user buys enough to cover the tx cost\n    return gasCost.wei + bufferCost;\n  } catch {\n    if (from) {\n      // try again without passing from\n      return await getTransactionGasCost(tx);\n    }\n    // fallback if both fail, use the tx value + 1M * gas price\n    const gasPrice = await getGasPrice({\n      client: tx.client,\n      chain: tx.chain,\n    });\n\n    return 1_000_000n * gasPrice;\n  }\n}\n", "import { type Hex, isHex } from \"../hex.js\";\n\n/**\n * Calculates the byte size of a Hex string or Uint8Array.\n * If the value is a Hex string, it accounts for the leading \"0x\" prefix.\n * @param value The Hex string or Uint8Array.\n * @returns The byte size of the value.\n * @example\n * ```ts\n * import { byteSize } from \"thirdweb/utils\";\n * const size = byteSize(\"0x1a4\");\n * console.log(size); // 2\n * ```\n */\nexport function byteSize(value: Hex | Uint8Array) {\n  if (isHex(value, { strict: false })) {\n    return Math.ceil((value.length - 2) / 2);\n  }\n  return value.length;\n}\n", "import type {\n  AbiParameter,\n  AbiParameterToPrimitiveType,\n  AbiParametersToPrimitiveTypes,\n} from \"abitype\";\nimport * as ox__Hex from \"ox/Hex\";\nimport { isAddress } from \"../address.js\";\nimport { byteSize } from \"../encoding/helpers/byte-size.js\";\nimport {\n  type Hex,\n  boolToHex,\n  numberToHex,\n  padHex,\n  stringToHex,\n} from \"../encoding/hex.js\";\n\n/**\n * Encodes the given ABI parameters and values into a hexadecimal string.\n * @template TParams - The type of the ABI parameters.\n * @param params - The ABI parameters.\n * @param values - The corresponding values for the ABI parameters.\n * @returns - The encoded ABI parameters as a hexadecimal string.\n * @throws {Error} - If the number of parameters and values do not match.\n * @example\n * ```ts\n * import { encodeAbiParameters } from \"viem\";\n *\n * const params = [\n *  { name: \"param1\", type: \"uint256\" },\n *  { name: \"param2\", type: \"string\" },\n * ];\n * const values = [123, \"hello\"];\n *\n * const data = encodeAbiParameters(params, values);\n * console.log(data);\n * ```\n * @utils\n */\nexport function encodeAbiParameters<\n  const TParams extends readonly AbiParameter[] | readonly unknown[],\n>(\n  params: TParams,\n  values: TParams extends readonly AbiParameter[]\n    ? AbiParametersToPrimitiveTypes<TParams>\n    : never,\n): Hex {\n  if (params.length !== values.length) {\n    throw new Error(\"The number of parameters and values must match.\");\n  }\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParams = prepareParams({\n    params: params as readonly AbiParameter[],\n    values,\n  });\n  const data = encodeParams(preparedParams);\n  if (data.length === 0) {\n    return \"0x\";\n  }\n  return data;\n}\n\n//UTILS\n\ntype PreparedParam = { dynamic: boolean; encoded: Hex };\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] };\ntype Tuple = AbiParameterToPrimitiveType<TupleAbiParameter>;\n\nfunction prepareParams<const TParams extends readonly AbiParameter[]>({\n  params,\n  values,\n}: {\n  params: TParams;\n  values: AbiParametersToPrimitiveTypes<TParams>;\n}) {\n  const preparedParams: PreparedParam[] = [];\n  for (let i = 0; i < params.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    preparedParams.push(prepareParam({ param: params[i]!, value: values[i] }));\n  }\n  return preparedParams;\n}\n\n/**\n * @internal Export for unit test\n */\nexport function prepareParam<const TParam extends AbiParameter>({\n  param,\n  value,\n}: {\n  param: TParam;\n  value: AbiParameterToPrimitiveType<TParam>;\n}): PreparedParam {\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents) {\n    const [length, type] = arrayComponents;\n    return encodeArray(value, { length, param: { ...param, type } });\n  }\n  if (param.type === \"tuple\") {\n    return encodeTuple(value as unknown as Tuple, {\n      param: param as TupleAbiParameter,\n    });\n  }\n  if (param.type === \"address\") {\n    return encodeAddress(value as unknown as Hex);\n  }\n  if (param.type === \"bool\") {\n    return encodeBool(value as unknown as boolean);\n  }\n  if (param.type.startsWith(\"uint\") || param.type.startsWith(\"int\")) {\n    const signed = param.type.startsWith(\"int\");\n    return encodeNumber(value as unknown as number, { signed });\n  }\n  if (param.type.startsWith(\"bytes\")) {\n    return encodeBytes(value as unknown as Hex, { param });\n  }\n  if (param.type === \"string\") {\n    return encodeString(value as unknown as string);\n  }\n  throw new Error(`Unsupported parameter type: ${param.type}`);\n}\n\nfunction encodeParams(preparedParams: PreparedParam[]): Hex {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0;\n  for (let i = 0; i < preparedParams.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    const { dynamic, encoded } = preparedParams[i]!;\n    if (dynamic) {\n      staticSize += 32;\n    } else {\n      staticSize += byteSize(encoded);\n    }\n  }\n\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParams: Hex[] = [];\n  const dynamicParams: Hex[] = [];\n  let dynamicSize = 0;\n  for (let i = 0; i < preparedParams.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    const { dynamic, encoded } = preparedParams[i]!;\n    if (dynamic) {\n      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));\n      dynamicParams.push(encoded);\n      dynamicSize += byteSize(encoded);\n    } else {\n      staticParams.push(encoded);\n    }\n  }\n\n  // 3. Concatenate static and dynamic parts.\n  return ox__Hex.concat(...[...staticParams, ...dynamicParams]);\n}\n\n/////////////////////////////////////////////////////////////////\n\n/**\n * @internal Export for unit test\n */\nexport function encodeAddress(value: Hex): PreparedParam {\n  // We allow empty strings for deployment transactions where there is no to address\n  if ((value as string) !== \"\" && value !== undefined && !isAddress(value)) {\n    throw new Error(`Invalid address: ${value}`);\n  }\n  return { dynamic: false, encoded: padHex(value.toLowerCase() as Hex) };\n}\n\nfunction encodeArray<const TParam extends AbiParameter>(\n  value: AbiParameterToPrimitiveType<TParam>,\n  {\n    length,\n    param,\n  }: {\n    length: number | null;\n    param: TParam;\n  },\n): PreparedParam {\n  const dynamic = length === null;\n\n  if (!Array.isArray(value)) {\n    throw new Error(\"Invalid array value.\");\n  }\n  if (!dynamic && value.length !== length) {\n    throw new Error(\"Invalid array length.\");\n  }\n\n  let dynamicChild = false;\n  const preparedParams: PreparedParam[] = [];\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParam({ param, value: value[i] });\n    if (preparedParam.dynamic) {\n      dynamicChild = true;\n    }\n    preparedParams.push(preparedParam);\n  }\n\n  if (dynamic || dynamicChild) {\n    const data = encodeParams(preparedParams);\n    if (dynamic) {\n      const length_ = numberToHex(preparedParams.length, { size: 32 });\n      return {\n        dynamic: true,\n        encoded:\n          preparedParams.length > 0\n            ? ox__Hex.concat(...[length_, data])\n            : length_,\n      };\n    }\n    if (dynamicChild) {\n      return { dynamic: true, encoded: data };\n    }\n  }\n  return {\n    dynamic: false,\n    encoded: ox__Hex.concat(...preparedParams.map(({ encoded }) => encoded)),\n  };\n}\n\nfunction encodeBytes<const TParam extends AbiParameter>(\n  value: Hex,\n  { param }: { param: TParam },\n): PreparedParam {\n  const [, paramSize] = param.type.split(\"bytes\");\n  const bytesSize = byteSize(value);\n  if (!paramSize) {\n    let value_ = value;\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0) {\n      value_ = padHex(value_, {\n        dir: \"right\",\n        size: Math.ceil((value.length - 2) / 2 / 32) * 32,\n      });\n    }\n    return {\n      dynamic: true,\n      encoded: ox__Hex.concat(\n        ...[padHex(numberToHex(bytesSize, { size: 32 })), value_],\n      ),\n    };\n  }\n  if (bytesSize !== Number.parseInt(paramSize)) {\n    throw new Error(`Invalid bytes${paramSize} size: ${bytesSize}`);\n  }\n  return { dynamic: false, encoded: padHex(value, { dir: \"right\" }) };\n}\n\nfunction encodeBool(value: boolean): PreparedParam {\n  return { dynamic: false, encoded: padHex(boolToHex(value)) };\n}\n\nfunction encodeNumber(\n  value: number,\n  { signed }: { signed: boolean },\n): PreparedParam {\n  return {\n    dynamic: false,\n    encoded: numberToHex(value, {\n      size: 32,\n      signed,\n    }),\n  };\n}\n\nfunction encodeString(value: string): PreparedParam {\n  const hexValue = stringToHex(value);\n  const partsLength = Math.ceil(byteSize(hexValue) / 32);\n  const parts: Hex[] = [];\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(\n      padHex(ox__Hex.slice(hexValue, i * 32, (i + 1) * 32), {\n        dir: \"right\",\n      }),\n    );\n  }\n  return {\n    dynamic: true,\n    encoded: ox__Hex.concat(\n      ...[padHex(numberToHex(byteSize(hexValue), { size: 32 })), ...parts],\n    ),\n  };\n}\n\nfunction encodeTuple<\n  const TParam extends AbiParameter & { components: readonly AbiParameter[] },\n>(\n  value: AbiParameterToPrimitiveType<TParam>,\n  { param }: { param: TParam },\n): PreparedParam {\n  let dynamic = false;\n  const preparedParams: PreparedParam[] = [];\n  for (let i = 0; i < param.components.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    const param_ = param.components[i]!;\n    const index = Array.isArray(value) ? i : param_.name;\n    const preparedParam = prepareParam({\n      param: param_,\n      // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      value: (value as any)[index!] as readonly unknown[],\n    });\n    preparedParams.push(preparedParam);\n    if (preparedParam.dynamic) {\n      dynamic = true;\n    }\n  }\n  return {\n    dynamic,\n    encoded: dynamic\n      ? encodeParams(preparedParams)\n      : ox__Hex.concat(...preparedParams.map(({ encoded }) => encoded)),\n  };\n}\n\nfunction getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n  return matches\n    ? // Return `null` if the array is dynamic.\n      // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n      [matches[2] ? Number(matches[2]) : null, matches[1]!]\n    : undefined;\n}\n", "import { type AbiFunction, type ParseAbiItem, parseAbiItem } from \"abitype\";\nimport { toFunctionSelector } from \"viem\";\nimport { LruMap } from \"../caching/lru.js\";\nimport type { Hex } from \"../encoding/hex.js\";\nimport { stringify } from \"../json.js\";\n\ntype ParseMethod<method extends AbiFunction | `function ${string}`> =\n  // if the method IS an AbiFunction, return it\n  method extends AbiFunction\n    ? method\n    : method extends `function ${string}`\n      ? ParseAbiItem<method> extends AbiFunction\n        ? ParseAbiItem<method>\n        : never\n      : never;\n\nexport type PreparedMethod<TMethod extends AbiFunction | `function ${string}`> =\n  // [\"fn signature\", \"inputs\", \"outputs\"]\n  [Hex, ParseMethod<TMethod>[\"inputs\"], ParseMethod<TMethod>[\"outputs\"]];\n\nconst prepareMethodCache = new LruMap<PreparedMethod<AbiFunction>>(4096);\n\n/**\n * Prepares a method for usage by converting it into a prepared method object.\n * @param method The method to prepare.\n * @returns The prepared method object.\n * @example\n * ```ts\n * import { prepareMethod } from \"thirdweb/utils\";\n * const method = \"function transfer(address to, uint256 value)\";\n * const preparedMethod = prepareMethod(method);\n * ```\n * @contract\n */\nexport function prepareMethod<\n  const TMethod extends AbiFunction | `function ${string}`,\n>(method: TMethod): PreparedMethod<TMethod> {\n  const key = typeof method === \"string\" ? method : stringify(method);\n  if (prepareMethodCache.has(key)) {\n    return prepareMethodCache.get(key) as PreparedMethod<TMethod>;\n  }\n  type ParsedAbiFn = ParseMethod<TMethod>;\n\n  const abiFn =\n    typeof method === \"string\"\n      ? // @ts-expect-error - we're sure it's a string...\n        (parseAbiItem(method) as ParsedAbiFn)\n      : (method as ParsedAbiFn);\n\n  // encode the method signature\n  const sig = toFunctionSelector(abiFn);\n\n  const ret: PreparedMethod<TMethod> = [sig, abiFn.inputs, abiFn.outputs];\n  prepareMethodCache.set(key, ret);\n  return ret;\n}\n"],
  "mappings": "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",
  "names": []
}
