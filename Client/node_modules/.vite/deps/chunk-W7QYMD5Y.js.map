{
  "version": 3,
  "sources": ["../../thirdweb/src/auth/constants.ts", "../../thirdweb/src/auth/serialize-erc6492-signature.ts", "../../ox/core/internal/abi.ts", "../../ox/core/Abi.ts", "../../ox/core/internal/abiItem.ts", "../../ox/core/AbiItem.ts", "../../ox/core/AbiConstructor.ts", "../../ox/core/AbiFunction.ts", "../../ox/erc6492/WrappedSignature.ts", "../../thirdweb/src/extensions/erc1271/__generated__/isValidSignature/read/isValidSignature.ts", "../../thirdweb/src/utils/encoding/from-bytes.ts", "../../thirdweb/src/auth/verify-hash.ts", "../../thirdweb/src/utils/hashing/hashMessage.ts", "../../thirdweb/src/utils/hashing/hashTypedData.ts", "../../thirdweb/src/wallets/smart/lib/signing.ts"],
  "sourcesContent": ["export const ERC_6492_MAGIC_VALUE =\n  \"0x6492649264926492649264926492649264926492649264926492649264926492\" as const;\n", "import { encodeAbiParameters } from \"../utils/abi/encodeAbiParameters.js\";\nimport { concatHex } from \"../utils/encoding/helpers/concat-hex.js\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\nimport { ERC_6492_MAGIC_VALUE } from \"./constants.js\";\nimport type { Erc6492Signature } from \"./types.js\";\n\n/**\n * Serializes a signature for use with [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492). The signature must be generated by a signer for an [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337) Account Factory account with counterfactual deployment addresses.\n *\n * @param {@link Erc6492Signature} signature  The signature object to serialize into Hex format\n * @param {string} signature.address The ERC-4337 Account Factory address\n * @param {Hex} signature.data Account deployment calldata (if not deployed) for counterfactual verification\n * @param {Hex} signature.signature The original signature\n *\n * @returns {Hex} The serialized signature\n *\n * @example\n * ```ts\n * import { serializeErc6492Signature } from 'thirdweb/auth';\n *\n * const serializedSignature = serializeErc6492Signature({\n *  address: '0x...',\n *  data: '0x...',\n *  signature: '0x...',\n * });\n * // 0x000000000000000000000000cafebabecafebabecafebabecafebabecafebabe000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000004deadbeef000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041a461f509887bd19e312c0c58467ce8ff8e300d3c1a90b608a760c5b80318eaf15fe57c96f9175d6cd4daad4663763baa7e78836e067d0163e9a2ccf2ff753f5b1b000000000000000000000000000000000000000000000000000000000000006492649264926492649264926492649264926492649264926492649264926492\n * ```\n * @auth\n */\nexport function serializeErc6492Signature({\n  address,\n  data,\n  signature,\n}: Erc6492Signature): Hex {\n  return concatHex([\n    encodeAbiParameters(\n      [{ type: \"address\" }, { type: \"bytes\" }, { type: \"bytes\" }],\n      [address, data, signature],\n    ),\n    ERC_6492_MAGIC_VALUE,\n  ]);\n}\n", "import type * as Abi from '../Abi.js'\n\n/** @internal */\nexport function isSignatures(\n  value: Abi.Abi | readonly string[],\n): value is readonly string[] {\n  for (const item of value) {\n    if (typeof item !== 'string') return false\n  }\n  return true\n}\n", "import * as abitype from 'abitype'\nimport type * as Errors from './Errors.js'\nimport * as internal from './internal/abi.js'\nimport type * as AbiItem_internal from './internal/abiItem.js'\n\n/** Root type for an ABI. */\nexport type Abi = abitype.Abi\n\n/** @internal */\nexport function format<const abi extends Abi>(abi: abi): format.ReturnType<abi>\n/**\n * Formats an {@link ox#Abi.Abi} into a **Human Readable ABI**.\n *\n * @example\n * ```ts twoslash\n * import { Abi } from 'ox'\n *\n * const formatted = Abi.format([{\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * }])\n *\n * formatted\n * //    ^?\n *\n *\n *\n * ```\n *\n * @param abi - The ABI to format.\n * @returns The formatted ABI.\n */\nexport function format(abi: Abi | readonly unknown[]): readonly string[]\n/** @internal */\nexport function format(abi: Abi | readonly unknown[]): format.ReturnType {\n  return abitype.formatAbi(abi) as never\n}\n\nexport declare namespace format {\n  type ReturnType<abi extends Abi | readonly unknown[] = Abi> =\n    abitype.FormatAbi<abi>\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function from<const abi extends Abi | readonly string[]>(\n  abi: abi &\n    (abi extends readonly string[]\n      ? AbiItem_internal.Signatures<abi>\n      : unknown),\n): from.ReturnType<abi>\n/**\n * Parses an arbitrary **JSON ABI** or **Human Readable ABI** into a typed {@link ox#Abi.Abi}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { Abi } from 'ox'\n *\n * const abi = Abi.from([{\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * }])\n *\n * abi\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * ```ts twoslash\n * import { Abi } from 'ox'\n *\n * const abi = Abi.from([\n *   'function approve(address spender, uint256 amount) returns (bool)'\n * ])\n *\n * abi\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @param abi - The ABI to parse.\n * @returns The typed ABI.\n */\nexport function from(abi: Abi | readonly string[]): Abi\n/** @internal */\nexport function from(abi: Abi | readonly string[]): from.ReturnType {\n  if (internal.isSignatures(abi)) return abitype.parseAbi(abi)\n  return abi\n}\n\nexport declare namespace from {\n  type ReturnType<\n    abi extends Abi | readonly string[] | readonly unknown[] = Abi,\n  > = abi extends readonly string[] ? abitype.ParseAbi<abi> : abi\n\n  type ErrorType = Errors.GlobalErrorType\n}\n", "import type * as abitype from 'abitype'\nimport type * as Abi from '../Abi.js'\nimport type * as AbiItem from '../AbiItem.js'\nimport type * as AbiParameters from '../AbiParameters.js'\nimport * as Address from '../Address.js'\nimport * as Errors from '../Errors.js'\nimport type {\n  Compute,\n  IsNever,\n  IsUnion,\n  TypeErrorMessage,\n  UnionToTuple,\n} from './types.js'\n\n/** @internal */\nexport type ExtractArgs<\n  abi extends Abi.Abi | readonly unknown[] = Abi.Abi,\n  name extends AbiItem.Name<abi> = AbiItem.Name<abi>,\n> = abitype.AbiParametersToPrimitiveTypes<\n  AbiItem.FromAbi<abi extends Abi.Abi ? abi : Abi.Abi, name>['inputs'],\n  'inputs'\n> extends infer args\n  ? [args] extends [never]\n    ? readonly unknown[]\n    : args\n  : readonly unknown[]\n\n/** @internal */\nexport type ExtractForArgs<\n  abi extends Abi.Abi,\n  name extends AbiItem.Name<abi>,\n  args extends ExtractArgs<abi, name>,\n> = IsUnion<name> extends true\n  ? {\n      [key in keyof abi]: abi[key] extends { name: name } ? abi[key] : never\n    }[number]\n  : AbiItem.FromAbi<abi, name> extends infer abiItem extends AbiItem.AbiItem & {\n        inputs: readonly abitype.AbiParameter[]\n      }\n    ? IsUnion<abiItem> extends true // narrow overloads using `args` by converting to tuple and filtering out overloads that don't match\n      ? UnionToTuple<abiItem> extends infer abiItems extends\n          readonly (AbiItem.AbiItem & {\n            inputs: readonly abitype.AbiParameter[]\n          })[]\n        ? IsNever<TupleToUnion<abiItems, abi, name, args>> extends true\n          ? Compute<\n              abiItems[0] & {\n                readonly overloads: UnionToTuple<\n                  Exclude<abiItems[number], abiItems[0]>\n                >\n              }\n            >\n          : TupleToUnion<abiItems, abi, name, args> // convert back to union (removes `never` tuple entries: `['foo', never, 'bar'][number]` => `'foo' | 'bar'`)\n        : never\n      : abiItem\n    : never\n\n/** @internal */\nexport type TupleToUnion<\n  abiItems extends readonly {\n    inputs: readonly abitype.AbiParameter[]\n  }[],\n  abi extends Abi.Abi,\n  name extends AbiItem.Name<abi>,\n  args extends ExtractArgs<abi, name>,\n> = {\n  [k in keyof abiItems]: (\n    readonly [] extends args\n      ? readonly [] // fallback to `readonly []` if `args` has no value (e.g. `args` property not provided)\n      : args\n  ) extends abitype.AbiParametersToPrimitiveTypes<\n    abiItems[k]['inputs'],\n    'inputs'\n  >\n    ? abiItems[k]\n    : never\n}[number]\n\n/** @internal */\nexport type ErrorSignature<\n  name extends string = string,\n  parameters extends string = string,\n> = `error ${name}(${parameters})`\n\n/** @internal */\nexport type IsErrorSignature<signature extends string> =\n  signature extends ErrorSignature<infer name> ? IsName<name> : false\n\n/** @internal */\nexport type EventSignature<\n  name extends string = string,\n  parameters extends string = string,\n> = `event ${name}(${parameters})`\n\n/** @internal */\nexport type IsEventSignature<signature extends string> =\n  signature extends EventSignature<infer name> ? IsName<name> : false\n\n/** @internal */\nexport type FunctionSignature<\n  name extends string = string,\n  tail extends string = string,\n> = `function ${name}(${tail}`\nexport type IsFunctionSignature<signature> =\n  signature extends FunctionSignature<infer name>\n    ? IsName<name> extends true\n      ? signature extends ValidFunctionSignatures\n        ? true\n        : // Check that `Parameters` is not absorbing other types (e.g. `returns`)\n          signature extends `function ${string}(${infer parameters})`\n          ? parameters extends InvalidFunctionParameters\n            ? false\n            : true\n          : false\n      : false\n    : false\n/** @internal */\nexport type Scope = 'public' | 'external' // `internal` or `private` functions wouldn't make it to ABI so can ignore\n\n/** @internal */\nexport type Returns = `returns (${string})` | `returns(${string})`\n\n// Almost all valid function signatures, except `function ${string}(${infer parameters})` since `parameters` can absorb returns\n/** @internal */\nexport type ValidFunctionSignatures =\n  | `function ${string}()`\n  // basic\n  | `function ${string}() ${Returns}`\n  | `function ${string}() ${abitype.AbiStateMutability}`\n  | `function ${string}() ${Scope}`\n  // combinations\n  | `function ${string}() ${abitype.AbiStateMutability} ${Returns}`\n  | `function ${string}() ${Scope} ${Returns}`\n  | `function ${string}() ${Scope} ${abitype.AbiStateMutability}`\n  | `function ${string}() ${Scope} ${abitype.AbiStateMutability} ${Returns}`\n  // Parameters\n  | `function ${string}(${string}) ${Returns}`\n  | `function ${string}(${string}) ${abitype.AbiStateMutability}`\n  | `function ${string}(${string}) ${Scope}`\n  | `function ${string}(${string}) ${abitype.AbiStateMutability} ${Returns}`\n  | `function ${string}(${string}) ${Scope} ${Returns}`\n  | `function ${string}(${string}) ${Scope} ${abitype.AbiStateMutability}`\n  | `function ${string}(${string}) ${Scope} ${abitype.AbiStateMutability} ${Returns}`\n\n/** @internal */\nexport type StructSignature<\n  name extends string = string,\n  properties extends string = string,\n> = `struct ${name} {${properties}}`\n\n/** @internal */\nexport type IsStructSignature<signature extends string> =\n  signature extends StructSignature<infer name> ? IsName<name> : false\n\n/** @internal */\nexport type ConstructorSignature<tail extends string = string> =\n  `constructor(${tail}`\n\n/** @internal */\nexport type IsConstructorSignature<signature> =\n  signature extends ConstructorSignature\n    ? signature extends ValidConstructorSignatures\n      ? true\n      : false\n    : false\n\n/** @internal */\nexport type ValidConstructorSignatures =\n  | `constructor(${string})`\n  | `constructor(${string}) payable`\n\n/** @internal */\nexport type FallbackSignature<abiStateMutability extends '' | ' payable' = ''> =\n  `fallback() external${abiStateMutability}`\n\n/** @internal */\nexport type ReceiveSignature = 'receive() external payable'\n\n// TODO: Maybe use this for signature validation one day\n// https://twitter.com/devanshj__/status/1610423724708343808\n/** @internal */\nexport type IsSignature<type extends string> =\n  | (IsErrorSignature<type> extends true ? true : never)\n  | (IsEventSignature<type> extends true ? true : never)\n  | (IsFunctionSignature<type> extends true ? true : never)\n  | (IsStructSignature<type> extends true ? true : never)\n  | (IsConstructorSignature<type> extends true ? true : never)\n  | (type extends FallbackSignature ? true : never)\n  | (type extends ReceiveSignature ? true : never) extends infer condition\n  ? [condition] extends [never]\n    ? false\n    : true\n  : false\n\n/** @internal */\nexport type Signature<\n  string1 extends string,\n  string2 extends string | unknown = unknown,\n> = IsSignature<string1> extends true\n  ? string1\n  : string extends string1 // if exactly `string` (not narrowed), then pass through as valid\n    ? string1\n    : TypeErrorMessage<`Signature \"${string1}\" is invalid${string2 extends string\n        ? ` at position ${string2}`\n        : ''}.`>\n\n/** @internal */\nexport type Signatures<signatures extends readonly string[]> = {\n  [key in keyof signatures]: Signature<signatures[key], key>\n}\n\n/** @internal */\nexport type IsName<name extends string> = name extends ''\n  ? false\n  : ValidateName<name> extends name\n    ? true\n    : false\n\n/** @internal */\nexport type ValidateName<\n  name extends string,\n  checkCharacters extends boolean = false,\n> = name extends `${string}${' '}${string}`\n  ? TypeErrorMessage<`Identifier \"${name}\" cannot contain whitespace.`>\n  : IsSolidityKeyword<name> extends true\n    ? TypeErrorMessage<`\"${name}\" is a protected Solidity keyword.`>\n    : name extends `${number}`\n      ? TypeErrorMessage<`Identifier \"${name}\" cannot be a number string.`>\n      : name extends `${number}${string}`\n        ? TypeErrorMessage<`Identifier \"${name}\" cannot start with a number.`>\n        : checkCharacters extends true\n          ? IsValidCharacter<name> extends true\n            ? name\n            : TypeErrorMessage<`\"${name}\" contains invalid character.`>\n          : name\n\n/** @internal */\nexport type IsSolidityKeyword<type extends string> =\n  type extends SolidityKeywords ? true : false\n\n/** @internal */\nexport type SolidityKeywords =\n  | 'after'\n  | 'alias'\n  | 'anonymous'\n  | 'apply'\n  | 'auto'\n  | 'byte'\n  | 'calldata'\n  | 'case'\n  | 'catch'\n  | 'constant'\n  | 'copyof'\n  | 'default'\n  | 'defined'\n  | 'error'\n  | 'event'\n  | 'external'\n  | 'false'\n  | 'final'\n  | 'function'\n  | 'immutable'\n  | 'implements'\n  | 'in'\n  | 'indexed'\n  | 'inline'\n  | 'internal'\n  | 'let'\n  | 'mapping'\n  | 'match'\n  | 'memory'\n  | 'mutable'\n  | 'null'\n  | 'of'\n  | 'override'\n  | 'partial'\n  | 'private'\n  | 'promise'\n  | 'public'\n  | 'pure'\n  | 'reference'\n  | 'relocatable'\n  | 'return'\n  | 'returns'\n  | 'sizeof'\n  | 'static'\n  | 'storage'\n  | 'struct'\n  | 'super'\n  | 'supports'\n  | 'switch'\n  | 'this'\n  | 'true'\n  | 'try'\n  | 'typedef'\n  | 'typeof'\n  | 'var'\n  | 'view'\n  | 'virtual'\n  | `address${`[${string}]` | ''}`\n  | `bool${`[${string}]` | ''}`\n  | `string${`[${string}]` | ''}`\n  | `tuple${`[${string}]` | ''}`\n  | `bytes${number | ''}${`[${string}]` | ''}`\n  | `${'u' | ''}int${number | ''}${`[${string}]` | ''}`\n\n/** @internal */\nexport type IsValidCharacter<character extends string> =\n  character extends `${ValidCharacters}${infer tail}`\n    ? tail extends ''\n      ? true\n      : IsValidCharacter<tail>\n    : false\n\n// biome-ignore format: no formatting\n/** @internal */\nexport type ValidCharacters =\n  // uppercase letters\n  | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z'\n  // lowercase letters\n  | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z'\n  // numbers\n  | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'\n  // special characters\n  | '_' | '$'\n\n// Template string inference can absorb `returns`:\n// type Result = `function foo(string) return s (uint256)` extends `function ${string}(${infer Parameters})` ? Parameters : never\n// //   ^? type Result = \"string ) return s (uint256\"\n// So we need to validate against `returns` keyword with all combinations of whitespace\n/** @internal */\nexport type InvalidFunctionParameters =\n  | `${string}${MangledReturns} (${string}`\n  | `${string}) ${MangledReturns}${string}`\n  | `${string})${string}${MangledReturns}${string}(${string}`\n\n// r_e_t_u_r_n_s\n/** @internal */\nexport type MangledReturns =\n  // Single\n  | `r${string}eturns`\n  | `re${string}turns`\n  | `ret${string}urns`\n  | `retu${string}rns`\n  | `retur${string}ns`\n  | `return${string}s`\n  // Double\n  // `r_e*`\n  | `r${string}e${string}turns`\n  | `r${string}et${string}urns`\n  | `r${string}etu${string}rns`\n  | `r${string}etur${string}ns`\n  | `r${string}eturn${string}s`\n  // `re_t*`\n  | `re${string}t${string}urns`\n  | `re${string}tu${string}rns`\n  | `re${string}tur${string}ns`\n  | `re${string}turn${string}s`\n  // `ret_u*`\n  | `ret${string}u${string}rns`\n  | `ret${string}ur${string}ns`\n  | `ret${string}urn${string}s`\n  // `retu_r*`\n  | `retu${string}r${string}ns`\n  | `retu${string}rn${string}s`\n  // `retur_n*`\n  | `retur${string}n${string}s`\n  // Triple\n  // `r_e_t*`\n  | `r${string}e${string}t${string}urns`\n  | `r${string}e${string}tu${string}rns`\n  | `r${string}e${string}tur${string}ns`\n  | `r${string}e${string}turn${string}s`\n  // `re_t_u*`\n  | `re${string}t${string}u${string}rns`\n  | `re${string}t${string}ur${string}ns`\n  | `re${string}t${string}urn${string}s`\n  // `ret_u_r*`\n  | `ret${string}u${string}r${string}ns`\n  | `ret${string}u${string}rn${string}s`\n  // `retu_r_n*`\n  | `retu${string}r${string}n${string}s`\n  // Quadruple\n  // `r_e_t_u*`\n  | `r${string}e${string}t${string}u${string}rns`\n  | `r${string}e${string}t${string}ur${string}ns`\n  | `r${string}e${string}t${string}urn${string}s`\n  // `re_t_u_r*`\n  | `re${string}t${string}u${string}r${string}ns`\n  | `re${string}t${string}u${string}rn${string}s`\n  // `ret_u_r_n*`\n  | `ret${string}u${string}r${string}n${string}s`\n  // Quintuple\n  // `r_e_t_u_r*`\n  | `r${string}e${string}t${string}u${string}r${string}ns`\n  | `r${string}e${string}t${string}u${string}rn${string}s`\n  // `re_t_u_r_n*`\n  | `re${string}t${string}u${string}r${string}n${string}s`\n  // Sextuple\n  // `r_e_t_u_r_n_s`\n  | `r${string}e${string}t${string}u${string}r${string}n${string}s`\n\n/** @internal */\nexport type Widen<type> =\n  | ([unknown] extends [type] ? unknown : never)\n  | (type extends Function ? type : never)\n  | (type extends abitype.ResolvedRegister['bigIntType'] ? bigint : never)\n  | (type extends boolean ? boolean : never)\n  | (type extends abitype.ResolvedRegister['intType'] ? number : never)\n  | (type extends string\n      ? type extends abitype.ResolvedRegister['addressType']\n        ? abitype.ResolvedRegister['addressType']\n        : type extends abitype.ResolvedRegister['bytesType']['inputs']\n          ? abitype.ResolvedRegister['bytesType']\n          : string\n      : never)\n  | (type extends readonly [] ? readonly [] : never)\n  | (type extends Record<string, unknown>\n      ? { [K in keyof type]: Widen<type[K]> }\n      : never)\n  | (type extends { length: number }\n      ? {\n          [K in keyof type]: Widen<type[K]>\n        } extends infer Val extends readonly unknown[]\n        ? readonly [...Val]\n        : never\n      : never)\n\n/** @internal */\nexport function normalizeSignature(signature: string): string {\n  let active = true\n  let current = ''\n  let level = 0\n  let result = ''\n  let valid = false\n\n  for (let i = 0; i < signature.length; i++) {\n    const char = signature[i]!\n\n    // If the character is a separator, we want to reactivate.\n    if (['(', ')', ','].includes(char)) active = true\n\n    // If the character is a \"level\" token, we want to increment/decrement.\n    if (char === '(') level++\n    if (char === ')') level--\n\n    // If we aren't active, we don't want to mutate the result.\n    if (!active) continue\n\n    // If level === 0, we are at the definition level.\n    if (level === 0) {\n      if (char === ' ' && ['event', 'function', 'error', ''].includes(result))\n        result = ''\n      else {\n        result += char\n\n        // If we are at the end of the definition, we must be finished.\n        if (char === ')') {\n          valid = true\n          break\n        }\n      }\n\n      continue\n    }\n\n    // Ignore spaces\n    if (char === ' ') {\n      // If the previous character is a separator, and the current section isn't empty, we want to deactivate.\n      if (signature[i - 1] !== ',' && current !== ',' && current !== ',(') {\n        current = ''\n        active = false\n      }\n      continue\n    }\n\n    result += char\n    current += char\n  }\n\n  if (!valid) throw new Errors.BaseError('Unable to normalize signature.')\n\n  return result\n}\n\n/** @internal */\nexport declare namespace normalizeSignature {\n  export type ErrorType = Errors.BaseError | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function isArgOfType(\n  arg: unknown,\n  abiParameter: AbiParameters.Parameter,\n): boolean {\n  const argType = typeof arg\n  const abiParameterType = abiParameter.type\n  switch (abiParameterType) {\n    case 'address':\n      return Address.validate(arg as Address.Address, { strict: false })\n    case 'bool':\n      return argType === 'boolean'\n    case 'function':\n      return argType === 'string'\n    case 'string':\n      return argType === 'string'\n    default: {\n      if (abiParameterType === 'tuple' && 'components' in abiParameter)\n        return Object.values(abiParameter.components).every(\n          (component, index) => {\n            return isArgOfType(\n              Object.values(arg as unknown[] | Record<string, unknown>)[index],\n              component as AbiParameters.Parameter,\n            )\n          },\n        )\n\n      // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n      // https://regexr.com/6v8hp\n      if (\n        /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(\n          abiParameterType,\n        )\n      )\n        return argType === 'number' || argType === 'bigint'\n\n      // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n      // https://regexr.com/6va55\n      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n        return argType === 'string' || arg instanceof Uint8Array\n\n      // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n      // https://regexr.com/6va6i\n      if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n        return (\n          Array.isArray(arg) &&\n          arg.every((x: unknown) =>\n            isArgOfType(x, {\n              ...abiParameter,\n              // Pop off `[]` or `[M]` from end of type\n              type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n            } as AbiParameters.Parameter),\n          )\n        )\n      }\n\n      return false\n    }\n  }\n}\n\n/** @internal */\nexport function getAmbiguousTypes(\n  sourceParameters: readonly AbiParameters.Parameter[],\n  targetParameters: readonly AbiParameters.Parameter[],\n  args: ExtractArgs,\n): AbiParameters.Parameter['type'][] | undefined {\n  for (const parameterIndex in sourceParameters) {\n    const sourceParameter = sourceParameters[parameterIndex]!\n    const targetParameter = targetParameters[parameterIndex]!\n\n    if (\n      sourceParameter.type === 'tuple' &&\n      targetParameter.type === 'tuple' &&\n      'components' in sourceParameter &&\n      'components' in targetParameter\n    )\n      return getAmbiguousTypes(\n        sourceParameter.components,\n        targetParameter.components,\n        (args as any)[parameterIndex],\n      )\n\n    const types = [sourceParameter.type, targetParameter.type]\n\n    const ambiguous = (() => {\n      if (types.includes('address') && types.includes('bytes20')) return true\n      if (types.includes('address') && types.includes('string'))\n        return Address.validate(args[parameterIndex] as Address.Address, {\n          strict: false,\n        })\n      if (types.includes('address') && types.includes('bytes'))\n        return Address.validate(args[parameterIndex] as Address.Address, {\n          strict: false,\n        })\n      return false\n    })()\n\n    if (ambiguous) return types\n  }\n\n  return\n}\n", "import * as abitype from 'abitype'\nimport type * as Abi from './Abi.js'\nimport * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport * as internal from './internal/abiItem.js'\nimport type { UnionCompute } from './internal/types.js'\n\n/** Root type for an item on an {@link ox#Abi.Abi}. */\nexport type AbiItem = Abi.Abi[number]\n\n/**\n * Extracts an {@link ox#AbiItem.AbiItem} item from an {@link ox#Abi.Abi}, given a name.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'error Foo(string)',\n *   'function foo(string)',\n *   'event Bar(uint256)',\n * ])\n *\n * type Foo = AbiItem.FromAbi<typeof abi, 'Foo'>\n * //   ^?\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n */\nexport type FromAbi<\n  abi extends Abi.Abi,\n  name extends ExtractNames<abi>,\n> = Extract<abi[number], { name: name }>\n\n/**\n * Extracts the names of all {@link ox#AbiItem.AbiItem} items in an {@link ox#Abi.Abi}.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'error Foo(string)',\n *   'function foo(string)',\n *   'event Bar(uint256)',\n * ])\n *\n * type names = AbiItem.Name<typeof abi>\n * //   ^?\n *\n * ```\n */\nexport type Name<abi extends Abi.Abi | readonly unknown[] = Abi.Abi> =\n  abi extends Abi.Abi ? ExtractNames<abi> : string\n\nexport type ExtractNames<abi extends Abi.Abi> = Extract<\n  abi[number],\n  { name: string }\n>['name']\n\n/**\n * Formats an {@link ox#AbiItem.AbiItem} into a **Human Readable ABI Item**.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const formatted = AbiItem.format({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiItem - The ABI Item to format.\n * @returns The formatted ABI Item  .\n */\nexport function format<const abiItem extends AbiItem>(\n  abiItem: abiItem | AbiItem,\n): abitype.FormatAbiItem<abiItem> {\n  return abitype.formatAbiItem(abiItem) as never\n}\n\nexport declare namespace format {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Parses an arbitrary **JSON ABI Item** or **Human Readable ABI Item** into a typed {@link ox#AbiItem.AbiItem}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from(\n *   'function approve(address spender, uint256 amount) returns (bool)' // [!code hl]\n * )\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'function approve(Foo foo) returns (bool)',\n * ])\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiItem - The ABI Item to parse.\n * @returns The typed ABI Item.\n */\nexport function from<\n  const abiItem extends AbiItem | string | readonly string[],\n>(\n  abiItem: (abiItem | AbiItem | string | readonly string[]) &\n    (\n      | (abiItem extends string ? internal.Signature<abiItem> : never)\n      | (abiItem extends readonly string[]\n          ? internal.Signatures<abiItem>\n          : never)\n      | AbiItem\n    ),\n  options: from.Options = {},\n): from.ReturnType<abiItem> {\n  const { prepare = true } = options\n  const item = (() => {\n    if (Array.isArray(abiItem)) return abitype.parseAbiItem(abiItem)\n    if (typeof abiItem === 'string')\n      return abitype.parseAbiItem(abiItem as never)\n    return abiItem\n  })() as AbiItem\n  return {\n    ...item,\n    ...(prepare ? { hash: getSignatureHash(item) } : {}),\n  } as never\n}\n\nexport declare namespace from {\n  type Options = {\n    /**\n     * Whether or not to prepare the extracted item (optimization for encoding performance).\n     * When `true`, the `hash` property is computed and included in the returned value.\n     *\n     * @default true\n     */\n    prepare?: boolean | undefined\n  }\n\n  type ReturnType<abiItem extends AbiItem | string | readonly string[]> =\n    abiItem extends string\n      ? abitype.ParseAbiItem<abiItem>\n      : abiItem extends readonly string[]\n        ? abitype.ParseAbiItem<abiItem>\n        : abiItem\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Extracts an {@link ox#AbiItem.AbiItem} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ABI Items can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiItem.fromAbi(abi, 'Transfer') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Items can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiItem.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Item from an `eth_call` RPC response,\n * a Transaction `input`, or from Event Log `topics`.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */\nexport function fromAbi<\n  const abi extends Abi.Abi | readonly unknown[],\n  name extends Name<abi>,\n  const args extends internal.ExtractArgs<abi, name> | undefined = undefined,\n  //\n  allNames = Name<abi>,\n>(\n  abi: abi | Abi.Abi | readonly unknown[],\n  name: Hex.Hex | (name extends allNames ? name : never),\n  options?: fromAbi.Options<abi, name, args>,\n): fromAbi.ReturnType<abi, name, args> {\n  const { args = [], prepare = true } = (options ??\n    {}) as unknown as fromAbi.Options\n\n  const isSelector = Hex.validate(name, { strict: false })\n  const abiItems = (abi as Abi.Abi).filter((abiItem) => {\n    if (isSelector) {\n      if (abiItem.type === 'function' || abiItem.type === 'error')\n        return getSelector(abiItem) === Hex.slice(name, 0, 4)\n      if (abiItem.type === 'event') return getSignatureHash(abiItem) === name\n      return false\n    }\n    return 'name' in abiItem && abiItem.name === name\n  })\n\n  if (abiItems.length === 0) throw new NotFoundError({ name: name as string })\n  if (abiItems.length === 1)\n    return {\n      ...abiItems[0],\n      ...(prepare ? { hash: getSignatureHash(abiItems[0]!) } : {}),\n    } as never\n\n  let matchedAbiItem: AbiItem | undefined = undefined\n  for (const abiItem of abiItems) {\n    if (!('inputs' in abiItem)) continue\n    if (!args || args.length === 0) {\n      if (!abiItem.inputs || abiItem.inputs.length === 0)\n        return {\n          ...abiItem,\n          ...(prepare ? { hash: getSignatureHash(abiItem) } : {}),\n        } as never\n      continue\n    }\n    if (!abiItem.inputs) continue\n    if (abiItem.inputs.length === 0) continue\n    if (abiItem.inputs.length !== args.length) continue\n    const matched = args.every((arg, index) => {\n      const abiParameter = 'inputs' in abiItem && abiItem.inputs![index]\n      if (!abiParameter) return false\n      return internal.isArgOfType(arg, abiParameter)\n    })\n    if (matched) {\n      // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n      if (\n        matchedAbiItem &&\n        'inputs' in matchedAbiItem &&\n        matchedAbiItem.inputs\n      ) {\n        const ambiguousTypes = internal.getAmbiguousTypes(\n          abiItem.inputs,\n          matchedAbiItem.inputs,\n          args as readonly unknown[],\n        )\n        if (ambiguousTypes)\n          throw new AmbiguityError(\n            {\n              abiItem,\n              type: ambiguousTypes[0]!,\n            },\n            {\n              abiItem: matchedAbiItem,\n              type: ambiguousTypes[1]!,\n            },\n          )\n      }\n\n      matchedAbiItem = abiItem\n    }\n  }\n\n  const abiItem = (() => {\n    if (matchedAbiItem) return matchedAbiItem\n    const [abiItem, ...overloads] = abiItems\n    return { ...abiItem!, overloads }\n  })()\n\n  if (!abiItem) throw new NotFoundError({ name: name as string })\n  return {\n    ...abiItem,\n    ...(prepare ? { hash: getSignatureHash(abiItem) } : {}),\n  } as never\n}\n\nexport declare namespace fromAbi {\n  type Options<\n    abi extends Abi.Abi | readonly unknown[] = Abi.Abi,\n    name extends Name<abi> = Name<abi>,\n    args extends\n      | internal.ExtractArgs<abi, name>\n      | undefined = internal.ExtractArgs<abi, name>,\n    ///\n    allArgs = internal.ExtractArgs<abi, name>,\n  > = {\n    /**\n     * Whether or not to prepare the extracted item (optimization for encoding performance).\n     * When `true`, the `hash` property is computed and included in the returned value.\n     *\n     * @default true\n     */\n    prepare?: boolean | undefined\n  } & UnionCompute<\n    readonly [] extends allArgs\n      ? {\n          args?:\n            | allArgs // show all options\n            // infer value, widen inferred value of `args` conditionally to match `allArgs`\n            | (abi extends Abi.Abi\n                ? args extends allArgs\n                  ? internal.Widen<args>\n                  : never\n                : never)\n            | undefined\n        }\n      : {\n          args?:\n            | allArgs // show all options\n            | (internal.Widen<args> & (args extends allArgs ? unknown : never)) // infer value, widen inferred value of `args` match `allArgs` (e.g. avoid union `args: readonly [123n] | readonly [bigint]`)\n            | undefined\n        }\n  >\n\n  type ReturnType<\n    abi extends Abi.Abi | readonly unknown[] = Abi.Abi,\n    name extends Name<abi> = Name<abi>,\n    args extends\n      | internal.ExtractArgs<abi, name>\n      | undefined = internal.ExtractArgs<abi, name>,\n    fallback = AbiItem,\n  > = abi extends Abi.Abi\n    ? Abi.Abi extends abi\n      ? fallback\n      : internal.ExtractForArgs<\n          abi,\n          name,\n          args extends internal.ExtractArgs<abi, name>\n            ? args\n            : internal.ExtractArgs<abi, name>\n        >\n    : fallback\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Computes the [4-byte selector](https://solidity-by-example.org/function-selector/) for an {@link ox#AbiItem.AbiItem}.\n *\n * Useful for computing function selectors for calldata.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const selector = AbiItem.getSelector('function ownerOf(uint256 tokenId)')\n * // @log: '0x6352211e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const selector = AbiItem.getSelector({\n *   inputs: [{ type: 'uint256' }],\n *   name: 'ownerOf',\n *   outputs: [],\n *   stateMutability: 'view',\n *   type: 'function'\n * })\n * // @log: '0x6352211e'\n * ```\n *\n * @param abiItem - The ABI item to compute the selector for. Can be a signature or an ABI item for an error, event, function, etc.\n * @returns The first 4 bytes of the {@link ox#Hash.(keccak256:function)} hash of the function signature.\n */\nexport function getSelector(abiItem: string | AbiItem): Hex.Hex {\n  return Hex.slice(getSignatureHash(abiItem), 0, 4)\n}\n\nexport declare namespace getSelector {\n  type ErrorType =\n    | getSignatureHash.ErrorType\n    | Hex.slice.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Computes the stringified signature for a given {@link ox#AbiItem.AbiItem}.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const signature = AbiItem.getSignature('function ownerOf(uint256 tokenId)')\n * // @log: 'ownerOf(uint256)'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const signature = AbiItem.getSignature({\n *   name: 'ownerOf',\n *   type: 'function',\n *   inputs: [{ name: 'tokenId', type: 'uint256' }],\n *   outputs: [],\n *   stateMutability: 'view',\n * })\n * // @log: 'ownerOf(uint256)'\n * ```\n *\n * @param abiItem - The ABI Item to compute the signature for.\n * @returns The stringified signature of the ABI Item.\n */\nexport function getSignature(abiItem: string | AbiItem): string {\n  const signature = (() => {\n    if (typeof abiItem === 'string') return abiItem\n    return abitype.formatAbiItem(abiItem)\n  })()\n  return internal.normalizeSignature(signature)\n}\n\nexport declare namespace getSignature {\n  type ErrorType =\n    | internal.normalizeSignature.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Computes the signature hash for an {@link ox#AbiItem.AbiItem}.\n *\n * Useful for computing Event Topic values.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const hash = AbiItem.getSignatureHash('event Transfer(address indexed from, address indexed to, uint256 amount)')\n * // @log: '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const hash = AbiItem.getSignatureHash({\n *   name: 'Transfer',\n *   type: 'event',\n *   inputs: [\n *     { name: 'from', type: 'address', indexed: true },\n *     { name: 'to', type: 'address', indexed: true },\n *     { name: 'amount', type: 'uint256', indexed: false },\n *   ],\n * })\n * // @log: '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'\n * ```\n *\n * @param abiItem - The ABI Item to compute the signature hash for.\n * @returns The {@link ox#Hash.(keccak256:function)} hash of the ABI item's signature.\n */\nexport function getSignatureHash(abiItem: string | AbiItem): Hex.Hex {\n  if (typeof abiItem !== 'string' && 'hash' in abiItem && abiItem.hash)\n    return abiItem.hash as Hex.Hex\n  return Hash.keccak256(Hex.fromString(getSignature(abiItem)))\n}\n\nexport declare namespace getSignatureHash {\n  type ErrorType =\n    | getSignature.ErrorType\n    | Hash.keccak256.ErrorType\n    | Hex.fromString.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Throws when ambiguous types are found on overloaded ABI items.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from(['function foo(address)', 'function foo(bytes20)'])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n *\n * ### Solution\n *\n * Remove one of the ambiguous types from the ABI.\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function foo(bytes20)' // [!code --]\n * ])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n */\nexport class AmbiguityError extends Errors.BaseError {\n  override readonly name = 'AbiItem.AmbiguityError'\n  constructor(\n    x: { abiItem: Abi.Abi[number]; type: string },\n    y: { abiItem: Abi.Abi[number]; type: string },\n  ) {\n    super('Found ambiguous types in overloaded ABI Items.', {\n      metaMessages: [\n        // TODO: abitype to add support for signature-formatted ABI items.\n        `\\`${x.type}\\` in \\`${internal.normalizeSignature(abitype.formatAbiItem(x.abiItem))}\\`, and`,\n        `\\`${y.type}\\` in \\`${internal.normalizeSignature(abitype.formatAbiItem(y.abiItem))}\\``,\n        '',\n        'These types encode differently and cannot be distinguished at runtime.',\n        'Remove one of the ambiguous items in the ABI.',\n      ],\n    })\n  }\n}\n\n/**\n * Throws when an ABI item is not found in the ABI.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * // @error: AbiItem.NotFoundError: ABI function with name \"baz\" not found.\n * ```\n *\n * ### Solution\n *\n * Ensure the ABI item exists on the ABI.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)',\n *   'function baz(bool)' // [!code ++]\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * ```\n */\nexport class NotFoundError extends Errors.BaseError {\n  override readonly name = 'AbiItem.NotFoundError'\n  constructor({\n    name,\n    data,\n    type = 'item',\n  }: {\n    name?: string | undefined\n    data?: Hex.Hex | undefined\n    type?: string | undefined\n  }) {\n    const selector = (() => {\n      if (name) return ` with name \"${name}\"`\n      if (data) return ` with data \"${data}\"`\n      return ''\n    })()\n    super(`ABI ${type}${selector} not found.`)\n  }\n}\n\n/**\n * Throws when the selector size is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0xaaa')\n * // @error: AbiItem.InvalidSelectorSizeError: Selector size is invalid. Expected 4 bytes. Received 2 bytes (\"0xaaa\").\n * ```\n *\n * ### Solution\n *\n * Ensure the selector size is 4 bytes.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0x7af82b1a')\n * ```\n */\nexport class InvalidSelectorSizeError extends Errors.BaseError {\n  override readonly name = 'AbiItem.InvalidSelectorSizeError'\n  constructor({ data }: { data: Hex.Hex }) {\n    super(\n      `Selector size is invalid. Expected 4 bytes. Received ${Hex.size(data)} bytes (\"${data}\").`,\n    )\n  }\n}\n", "import * as abitype from 'abitype'\nimport type * as Abi from './Abi.js'\nimport * as AbiItem from './AbiItem.js'\nimport * as AbiParameters from './AbiParameters.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type * as internal from './internal/abiConstructor.js'\nimport type { IsNarrowable } from './internal/types.js'\n\n/** Root type for an {@link ox#AbiItem.AbiItem} with a `constructor` type. */\nexport type AbiConstructor = abitype.AbiConstructor\n\n/** @internal */\nexport function decode<const abiConstructor extends AbiConstructor>(\n  abiConstructor: abiConstructor,\n  options: decode.Options,\n): decode.ReturnType<abiConstructor>\n/**\n * ABI-decodes the provided constructor input (`inputs`).\n *\n * @example\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from('constructor(address, uint256)')\n *\n * const bytecode = '0x...'\n *\n * const data = AbiConstructor.encode(constructor, {\n *   bytecode,\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n],\n * })\n *\n * const decoded = AbiConstructor.decode(constructor, { // [!code focus]\n *   bytecode, // [!code focus]\n *   data, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param abiConstructor - The ABI Constructor to decode.\n * @param options - Decoding options.\n * @returns The decoded constructor inputs.\n */\nexport function decode(\n  abiConstructor: AbiConstructor,\n  options: decode.Options,\n): readonly unknown[] | undefined\n/** @internal */\nexport function decode(\n  abiConstructor: AbiConstructor,\n  options: decode.Options,\n): decode.ReturnType {\n  const { bytecode } = options\n  if (abiConstructor.inputs.length === 0) return undefined\n  const data = options.data.replace(bytecode, '0x') as Hex.Hex\n  return AbiParameters.decode(abiConstructor.inputs, data)\n}\n\nexport declare namespace decode {\n  interface Options {\n    /** The bytecode of the contract. */\n    bytecode: Hex.Hex\n    /** The encoded constructor. */\n    data: Hex.Hex\n  }\n\n  type ReturnType<abiConstructor extends AbiConstructor = AbiConstructor> =\n    | (abiConstructor['inputs']['length'] extends 0\n        ? undefined\n        : abitype.AbiParametersToPrimitiveTypes<abiConstructor['inputs']>)\n    | (IsNarrowable<abiConstructor, AbiConstructor> extends true\n        ? never\n        : undefined)\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * ABI-encodes the provided constructor input (`inputs`).\n *\n * @example\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from('constructor(address, uint256)')\n *\n * const data = AbiConstructor.encode(constructor, {\n *   bytecode: '0x...',\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n],\n * })\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `AbiConstructor.encode` to encode the constructor of a contract and deploy it.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { AbiConstructor, Hex } from 'ox'\n *\n * // 1. Instantiate the ABI Constructor.\n * const constructor = AbiConstructor.from(\n *   'constructor(address owner, uint256 amount)',\n * )\n *\n * // 2. Encode the ABI Constructor.\n * const data = AbiConstructor.encode(constructor, {\n *   bytecode: '0x...',\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n],\n * })\n *\n * // 3. Deploy the contract.\n * const hash = await window.ethereum!.request({\n *   method: 'eth_sendTransaction',\n *   params: [{ data }],\n * })\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param abiConstructor - The ABI Constructor to encode.\n * @param options - Encoding options.\n * @returns The encoded constructor.\n */\nexport function encode<const abiConstructor extends AbiConstructor>(\n  abiConstructor: abiConstructor,\n  options: encode.Options<abiConstructor>,\n): encode.ReturnType {\n  const { bytecode, args } = options\n  return Hex.concat(\n    bytecode,\n    abiConstructor.inputs?.length && args?.length\n      ? AbiParameters.encode(abiConstructor.inputs, args as readonly unknown[])\n      : '0x',\n  )\n}\n\nexport declare namespace encode {\n  type Options<\n    abiConstructor extends AbiConstructor = AbiConstructor,\n    ///\n    args extends abitype.AbiParametersToPrimitiveTypes<\n      abiConstructor['inputs']\n    > = abitype.AbiParametersToPrimitiveTypes<abiConstructor['inputs']>,\n  > = {\n    /** The bytecode of the contract. */\n    bytecode: Hex.Hex\n    /** The constructor arguments to encode. */\n    args?: args | undefined\n  } & (readonly [] extends args\n    ? {}\n    : {\n        /** The constructor arguments to encode. */\n        args: args\n      })\n\n  type ReturnType = Hex.Hex\n\n  type ErrorType =\n    | Hex.concat.ErrorType\n    | AbiParameters.encode.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function format<const abiConstructor extends AbiConstructor>(\n  abiConstructor: abiConstructor,\n): format.ReturnType<abiConstructor>\n/**\n * Formats an {@link ox#AbiConstructor.AbiConstructor} into a **Human Readable ABI Function**.\n *\n * @example\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const formatted = AbiConstructor.format({\n *   inputs: [\n *     { name: 'owner', type: 'address' },\n *   ],\n *   payable: false,\n *   stateMutability: 'nonpayable',\n *   type: 'constructor',\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiConstructor - The ABI Constructor to format.\n * @returns The formatted ABI Constructor.\n */\nexport function format(abiConstructor: AbiConstructor): string\n/** @internal */\nexport function format(abiConstructor: AbiConstructor): format.ReturnType {\n  return abitype.formatAbiItem(abiConstructor)\n}\n\nexport declare namespace format {\n  type ReturnType<abiConstructor extends AbiConstructor = AbiConstructor> =\n    abitype.FormatAbiItem<abiConstructor>\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function from<\n  const abiConstructor extends AbiConstructor | string | readonly string[],\n>(\n  abiConstructor: (abiConstructor | string | readonly string[]) &\n    (\n      | (abiConstructor extends string\n          ? internal.Signature<abiConstructor>\n          : never)\n      | (abiConstructor extends readonly string[]\n          ? internal.Signatures<abiConstructor>\n          : never)\n      | AbiConstructor\n    ),\n): from.ReturnType<abiConstructor>\n/**\n * Parses an arbitrary **JSON ABI Constructor** or **Human Readable ABI Constructor** into a typed {@link ox#AbiConstructor.AbiConstructor}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from({\n *   inputs: [\n *     { name: 'owner', type: 'address' },\n *   ],\n *   payable: false,\n *   stateMutability: 'nonpayable',\n *   type: 'constructor',\n * })\n *\n * constructor\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from(\n *   'constructor(address owner)' // [!code hl]\n * )\n *\n * constructor\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from([\n *   'struct Foo { address owner; uint256 amount; }', // [!code hl]\n *   'constructor(Foo foo)',\n * ])\n *\n * constructor\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiConstructor - The ABI Constructor to parse.\n * @returns Typed ABI Constructor.\n */\nexport function from(\n  abiConstructor: AbiConstructor | string | readonly string[],\n): AbiConstructor\n/** @internal */\nexport function from(\n  abiConstructor: AbiConstructor | string | readonly string[],\n): from.ReturnType {\n  return AbiItem.from(abiConstructor as AbiConstructor)\n}\n\nexport declare namespace from {\n  type ReturnType<\n    abiConstructor extends\n      | AbiConstructor\n      | string\n      | readonly string[] = AbiConstructor,\n  > = AbiItem.from.ReturnType<abiConstructor>\n\n  type ErrorType = AbiItem.from.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function fromAbi<const abi extends Abi.Abi | readonly unknown[]>(\n  abi: abi | Abi.Abi | readonly unknown[],\n): fromAbi.ReturnType<abi>\n/**\n * Extracts an {@link ox#AbiConstructor.AbiConstructor} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ### Extracting by Name\n *\n * ABI Events can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiConstructor } from 'ox'\n *\n * const abi = Abi.from([\n *   'constructor(address owner)',\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiConstructor.fromAbi(abi) // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @returns The ABI constructor.\n */\nexport function fromAbi(abi: Abi.Abi | readonly unknown[]): AbiConstructor\n/** @internal */\nexport function fromAbi(abi: Abi.Abi | readonly unknown[]): fromAbi.ReturnType {\n  const item = (abi as Abi.Abi).find((item) => item.type === 'constructor')\n  if (!item) throw new AbiItem.NotFoundError({ name: 'constructor' })\n  return item\n}\n\nexport declare namespace fromAbi {\n  type ReturnType<abi extends Abi.Abi | readonly unknown[] = Abi.Abi> = Extract<\n    abi[number],\n    { type: 'constructor' }\n  >\n\n  type ErrorType = AbiItem.NotFoundError | Errors.GlobalErrorType\n}\n", "import * as abitype from 'abitype'\nimport type * as Abi from './Abi.js'\nimport * as AbiItem from './AbiItem.js'\nimport * as AbiParameters from './AbiParameters.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type * as internal from './internal/abiFunction.js'\nimport type * as AbiItem_internal from './internal/abiItem.js'\nimport type * as AbiParameters_internal from './internal/abiParameters.js'\nimport type { IsNarrowable } from './internal/types.js'\n\n/** Root type for an {@link ox#AbiItem.AbiItem} with a `function` type. */\nexport type AbiFunction = abitype.AbiFunction & {\n  hash?: Hex.Hex | undefined\n  overloads?: readonly AbiFunction[] | undefined\n}\n\n/**\n * Extracts an {@link ox#AbiFunction.AbiFunction} item from an {@link ox#Abi.Abi}, given a name.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo(string)',\n *   'function bar(uint256)',\n * ])\n *\n * type Foo = AbiFunction.FromAbi<typeof abi, 'foo'>\n * //   ^?\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n */\nexport type FromAbi<\n  abi extends Abi.Abi,\n  name extends ExtractNames<abi>,\n> = abitype.ExtractAbiFunction<abi, name>\n\n/**\n * Extracts the names of all {@link ox#AbiFunction.AbiFunction} items in an {@link ox#Abi.Abi}.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo(string)',\n *   'function bar(uint256)',\n * ])\n *\n * type names = AbiFunction.Name<typeof abi>\n * //   ^?\n *\n *\n * ```\n */\nexport type Name<abi extends Abi.Abi | readonly unknown[] = Abi.Abi> =\n  abi extends Abi.Abi ? ExtractNames<abi> : string\n\nexport type ExtractNames<\n  abi extends Abi.Abi,\n  abiStateMutability extends\n    abitype.AbiStateMutability = abitype.AbiStateMutability,\n> = abitype.ExtractAbiFunctionNames<abi, abiStateMutability>\n\n/**\n * ABI-decodes function arguments according to the ABI Item's input types (`inputs`).\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from('function approve(address, uint256)')\n *\n * const data = AbiFunction.encodeData(\n *   approve,\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n]\n * )\n * // '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'\n *\n * const input = AbiFunction.decodeData(approve, data) // [!code focus]\n * // @log: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n]\n * ```\n *\n * @param abiFunction - The ABI Item to decode.\n * @param data - The data to decode.\n */\nexport function decodeData<const abiItem extends AbiFunction>(\n  abiFunction: abiItem | AbiFunction,\n  data: Hex.Hex,\n): decodeData.ReturnType<abiItem> {\n  const { overloads } = abiFunction\n\n  if (Hex.size(data) < 4) throw new AbiItem.InvalidSelectorSizeError({ data })\n  if (abiFunction.inputs.length === 0) return undefined\n\n  const item = overloads\n    ? fromAbi([abiFunction, ...overloads], data as never)\n    : abiFunction\n\n  if (Hex.size(data) <= 4) return undefined\n  return AbiParameters.decode(item.inputs, Hex.slice(data, 4))\n}\n\nexport declare namespace decodeData {\n  type ReturnType<abiFunction extends AbiFunction = AbiFunction> = IsNarrowable<\n    abiFunction,\n    AbiFunction\n  > extends true\n    ? abiFunction['inputs'] extends readonly []\n      ? undefined\n      :\n          | AbiParameters_internal.ToPrimitiveTypes<abiFunction['inputs']>\n          | (abiFunction['overloads'] extends readonly AbiFunction[]\n              ? AbiParameters_internal.ToPrimitiveTypes<\n                  abiFunction['overloads'][number]['inputs']\n                >\n              : never)\n    : unknown\n\n  type ErrorType =\n    | fromAbi.ErrorType\n    | AbiParameters.decode.ErrorType\n    | Hex.size.ErrorType\n    | Hex.slice.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * ABI-decodes a function's result according to the ABI Item's output types (`outputs`).\n *\n * :::tip\n *\n * This function is typically used to decode contract function return values (e.g. the response of an `eth_call` or the `input` property of a Transaction).\n *\n * See the [End-to-end Example](#end-to-end).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const data = '0x000000000000000000000000000000000000000000000000000000000000002a'\n *\n * const totalSupply = AbiFunction.from('function totalSupply() returns (uint256)')\n *\n * const output = AbiFunction.decodeResult(totalSupply, data)\n * // @log: 42n\n * ```\n *\n * @example\n * You can extract an ABI Function from a JSON ABI with {@link ox#AbiFunction.(fromAbi:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const data = '0x000000000000000000000000000000000000000000000000000000000000002a'\n *\n * const erc20Abi = Abi.from([...]) // [!code hl]\n * const totalSupply = AbiFunction.fromAbi(erc20Abi, 'totalSupply') // [!code hl]\n *\n * const output = AbiFunction.decodeResult(totalSupply, data)\n * // @log: 42n\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `AbiFunction.decodeResult` to decode the result of a `balanceOf` contract call on the [Wagmi Mint Example contract](https://etherscan.io/address/0xfba3912ca04dd458c843e2ee08967fc04f3579c2).\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Abi, AbiFunction } from 'ox'\n *\n * // 1. Extract the Function from the Contract's ABI.\n * const abi = Abi.from([\n *   // ...\n *   {\n *     name: 'balanceOf',\n *     type: 'function',\n *     inputs: [{ name: 'account', type: 'address' }],\n *     outputs: [{ name: 'balance', type: 'uint256' }],\n *     stateMutability: 'view',\n *   },\n *   // ...\n * ])\n * const balanceOf = AbiFunction.fromAbi(abi, 'balanceOf')\n *\n * // 2. Encode the Function Input.\n * const data = AbiFunction.encodeData(\n *   balanceOf,\n *   ['0xd2135CfB216b74109775236E36d4b433F1DF507B']\n * )\n *\n * // 3. Perform the Contract Call.\n * const response = await window.ethereum!.request({\n *   method: 'eth_call',\n *   params: [\n *     {\n *       data,\n *       to: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *     },\n *   ],\n * })\n *\n * // 4. Decode the Function Output. // [!code focus]\n * const balance = AbiFunction.decodeResult(balanceOf, response) // [!code focus]\n * // @log: 42n\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param abiFunction - ABI Function to decode\n * @param data - ABI-encoded function output\n * @param options - Decoding options\n * @returns Decoded function output\n */\nexport function decodeResult<\n  const abiFunction extends AbiFunction,\n  as extends 'Object' | 'Array' = 'Array',\n>(\n  abiFunction: abiFunction | AbiFunction,\n  data: Hex.Hex,\n  options: decodeResult.Options<as> = {},\n): decodeResult.ReturnType<abiFunction, as> {\n  const values = AbiParameters.decode(abiFunction.outputs, data, options)\n  if (values && Object.keys(values).length === 0) return undefined\n  if (values && Object.keys(values).length === 1) {\n    if (Array.isArray(values)) return values[0]\n    return Object.values(values)[0]\n  }\n  return values\n}\n\nexport declare namespace decodeResult {\n  type Options<as extends 'Object' | 'Array'> = {\n    /**\n     * Whether the decoded values should be returned as an `Object` or `Array`.\n     *\n     * @default \"Array\"\n     */\n    as?: as | 'Array' | 'Object' | undefined\n  }\n\n  type ReturnType<\n    abiFunction extends AbiFunction = AbiFunction,\n    as extends 'Object' | 'Array' = 'Array',\n  > = IsNarrowable<abiFunction, AbiFunction> extends true\n    ? abiFunction['outputs'] extends readonly []\n      ? undefined\n      : abiFunction['outputs'] extends readonly [\n            infer type extends abitype.AbiParameter,\n          ]\n        ? abitype.AbiParameterToPrimitiveType<type>\n        : AbiParameters.decode.ReturnType<\n              abiFunction['outputs'],\n              as\n            > extends infer types\n          ? types extends readonly []\n            ? undefined\n            : types extends readonly [infer type]\n              ? type\n              : types\n          : never\n    : unknown\n\n  type ErrorType = AbiParameters.decode.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * ABI-encodes function arguments (`inputs`), prefixed with the 4 byte function selector.\n *\n * :::tip\n *\n * This function is typically used to encode a contract function and its arguments for contract calls (e.g. `data` parameter of an `eth_call` or `eth_sendTransaction`).\n *\n * See the [End-to-end Example](#end-to-end).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from('function approve(address, uint256)')\n *\n * const data = AbiFunction.encodeData( // [!code focus]\n *   approve, // [!code focus]\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n] // [!code focus]\n * ) // [!code focus]\n * // @log: '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'\n * ```\n *\n * @example\n * You can extract an ABI Function from a JSON ABI with {@link ox#AbiFunction.(fromAbi:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const erc20Abi = Abi.from([...]) // [!code hl]\n * const approve = AbiFunction.fromAbi(erc20Abi, 'approve') // [!code hl]\n *\n * const data = AbiFunction.encodeData(\n *   approve,\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n]\n * )\n * // @log: '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `AbiFunction.encodeData` to encode the input of a `balanceOf` contract call on the [Wagmi Mint Example contract](https://etherscan.io/address/0xfba3912ca04dd458c843e2ee08967fc04f3579c2).\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Abi, AbiFunction } from 'ox'\n *\n * // 1. Extract the Function from the Contract's ABI.\n * const abi = Abi.from([\n *   // ...\n *   {\n *     name: 'balanceOf',\n *     type: 'function',\n *     inputs: [{ name: 'account', type: 'address' }],\n *     outputs: [{ name: 'balance', type: 'uint256' }],\n *     stateMutability: 'view',\n *   },\n *   // ...\n * ])\n * const balanceOf = AbiFunction.fromAbi(abi, 'balanceOf')\n *\n * // 2. Encode the Function Input. // [!code focus]\n * const data = AbiFunction.encodeData( // [!code focus]\n *   balanceOf, // [!code focus]\n *   ['0xd2135CfB216b74109775236E36d4b433F1DF507B'] // [!code focus]\n * ) // [!code focus]\n *\n * // 3. Perform the Contract Call.\n * const response = await window.ethereum!.request({\n *   method: 'eth_call',\n *   params: [\n *     {\n *       data,\n *       to: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *     },\n *   ],\n * })\n *\n * // 4. Decode the Function Output.\n * const balance = AbiFunction.decodeResult(balanceOf, response)\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param abiFunction - ABI Function to encode\n * @param args - Function arguments\n * @returns ABI-encoded function name and arguments\n */\nexport function encodeData<const abiFunction extends AbiFunction>(\n  abiFunction: abiFunction | AbiFunction,\n  ...args: encodeData.Args<abiFunction>\n): Hex.Hex {\n  const { overloads } = abiFunction\n\n  const item = overloads\n    ? (fromAbi([abiFunction as AbiFunction, ...overloads], abiFunction.name, {\n        args: (args as any)[0],\n      }) as AbiFunction)\n    : abiFunction\n\n  const selector = getSelector(item)\n\n  const data =\n    args.length > 0\n      ? AbiParameters.encode(item.inputs, (args as any)[0])\n      : undefined\n\n  return data ? Hex.concat(selector, data) : selector\n}\n\nexport declare namespace encodeData {\n  type Args<abiFunction extends AbiFunction = AbiFunction> = IsNarrowable<\n    abiFunction,\n    AbiFunction\n  > extends true\n    ?\n        | (abitype.AbiParametersToPrimitiveTypes<\n            abiFunction['inputs']\n          > extends readonly []\n            ? []\n            : [abitype.AbiParametersToPrimitiveTypes<abiFunction['inputs']>])\n        | (abiFunction['overloads'] extends readonly AbiFunction[]\n            ? [\n                abitype.AbiParametersToPrimitiveTypes<\n                  abiFunction['overloads'][number]['inputs']\n                >,\n              ]\n            : [])\n    : readonly unknown[]\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * ABI-encodes a function's result (`outputs`).\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const totalSupply = AbiFunction.from('function totalSupply() returns (uint256)')\n * const output = AbiFunction.decodeResult(totalSupply, '0x000000000000000000000000000000000000000000000000000000000000002a')\n * // 42n\n *\n * const data = AbiFunction.encodeResult(totalSupply, 42n) // [!code focus]\n * // @log: '0x000000000000000000000000000000000000000000000000000000000000002a'\n * ```\n *\n * @param abiFunction - The ABI item to encode the function output for.\n * @param output - The function output to encode.\n * @param options - Encoding options.\n * @returns The encoded function output.\n */\nexport function encodeResult<\n  const abiFunction extends AbiFunction,\n  as extends 'Object' | 'Array' = 'Array',\n>(\n  abiFunction: abiFunction | AbiFunction,\n  output: encodeResult.Output<abiFunction, as>,\n  options: encodeResult.Options<as> = {},\n): Hex.Hex {\n  const { as = 'Array' } = options\n\n  const values = (() => {\n    if (abiFunction.outputs.length === 1) return [output]\n    if (Array.isArray(output)) return output\n    if (as === 'Object') return Object.values(output as any)\n    return [output]\n  })()\n\n  return AbiParameters.encode(abiFunction.outputs, values)\n}\n\nexport declare namespace encodeResult {\n  type Output<\n    abiFunction extends AbiFunction = AbiFunction,\n    as extends 'Object' | 'Array' = 'Array',\n  > = abiFunction['outputs'] extends readonly []\n    ? never\n    : abiFunction['outputs']['length'] extends 1\n      ? AbiParameters_internal.ToPrimitiveTypes<abiFunction['outputs']>[0]\n      : as extends 'Object'\n        ? AbiParameters_internal.ToObject<abiFunction['outputs']>\n        : AbiParameters_internal.ToPrimitiveTypes<abiFunction['outputs']>\n\n  type Options<as extends 'Object' | 'Array'> = {\n    as?: as | 'Object' | 'Array' | undefined\n  }\n\n  type ErrorType = AbiParameters.encode.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Formats an {@link ox#AbiFunction.AbiFunction} into a **Human Readable ABI Function**.\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const formatted = AbiFunction.format({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiFunction - The ABI Function to format.\n * @returns The formatted ABI Function.\n */\nexport function format<const abiFunction extends AbiFunction>(\n  abiFunction: abiFunction | AbiFunction,\n): abitype.FormatAbiItem<abiFunction> {\n  return abitype.formatAbiItem(abiFunction) as never\n}\n\nexport declare namespace format {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Parses an arbitrary **JSON ABI Function** or **Human Readable ABI Function** into a typed {@link ox#AbiFunction.AbiFunction}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from(\n *   'function approve(address spender, uint256 amount) returns (bool)' // [!code hl]\n * )\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'function approve(Foo foo) returns (bool)',\n * ])\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiFunction - The ABI Function to parse.\n * @returns Typed ABI Function.\n */\nexport function from<\n  const abiFunction extends AbiFunction | string | readonly string[],\n>(\n  abiFunction: (abiFunction | AbiFunction | string | readonly string[]) &\n    (\n      | (abiFunction extends string ? internal.Signature<abiFunction> : never)\n      | (abiFunction extends readonly string[]\n          ? internal.Signatures<abiFunction>\n          : never)\n      | AbiFunction\n    ),\n  options: from.Options = {},\n): from.ReturnType<abiFunction> {\n  return AbiItem.from(abiFunction as AbiFunction, options) as never\n}\n\nexport declare namespace from {\n  type Options = {\n    /**\n     * Whether or not to prepare the extracted function (optimization for encoding performance).\n     * When `true`, the `hash` property is computed and included in the returned value.\n     *\n     * @default true\n     */\n    prepare?: boolean | undefined\n  }\n\n  type ReturnType<\n    abiFunction extends AbiFunction | string | readonly string[],\n  > = AbiItem.from.ReturnType<abiFunction>\n\n  type ErrorType = AbiItem.from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Extracts an {@link ox#AbiFunction.AbiFunction} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ### Extracting by Name\n *\n * ABI Functions can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiFunction.fromAbi(abi, 'foo') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Functions can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiFunction.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Function from an `eth_call` RPC response or\n * from a Transaction `input`.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */\nexport function fromAbi<\n  const abi extends Abi.Abi | readonly unknown[],\n  name extends Name<abi>,\n  const args extends\n    | AbiItem_internal.ExtractArgs<abi, name>\n    | undefined = undefined,\n  //\n  allNames = Name<abi>,\n>(\n  abi: abi | Abi.Abi | readonly unknown[],\n  name: Hex.Hex | (name extends allNames ? name : never),\n  options?: AbiItem.fromAbi.Options<\n    abi,\n    name,\n    args,\n    AbiItem_internal.ExtractArgs<abi, name>\n  >,\n): AbiItem.fromAbi.ReturnType<abi, name, args, AbiFunction> {\n  const item = AbiItem.fromAbi(abi, name, options as any)\n  if (item.type !== 'function')\n    throw new AbiItem.NotFoundError({ name, type: 'function' })\n  return item as never\n}\n\nexport declare namespace fromAbi {\n  type ErrorType = AbiItem.fromAbi.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Computes the [4-byte selector](https://solidity-by-example.org/function-selector/) for an {@link ox#AbiFunction.AbiFunction}.\n *\n * Useful for computing function selectors for calldata.\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const selector = AbiFunction.getSelector('function ownerOf(uint256 tokenId)')\n * // @log: '0x6352211e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const selector = AbiFunction.getSelector({\n *   inputs: [{ type: 'uint256' }],\n *   name: 'ownerOf',\n *   outputs: [],\n *   stateMutability: 'view',\n *   type: 'function'\n * })\n * // @log: '0x6352211e'\n * ```\n *\n * @param abiItem - The ABI item to compute the selector for.\n * @returns The first 4 bytes of the {@link ox#Hash.(keccak256:function)} hash of the function signature.\n */\nexport function getSelector(abiItem: string | AbiFunction): Hex.Hex {\n  return AbiItem.getSelector(abiItem)\n}\n\nexport declare namespace getSelector {\n  type ErrorType = AbiItem.getSelector.ErrorType | Errors.GlobalErrorType\n}\n", "import type * as Abi from '../core/Abi.js'\nimport * as AbiParameters from '../core/AbiParameters.js'\nimport type * as Address from '../core/Address.js'\nimport * as Errors from '../core/Errors.js'\nimport * as Hex from '../core/Hex.js'\nimport * as Signature from '../core/Signature.js'\n\n/** ERC-6492 Wrapped Signature. */\nexport type WrappedSignature = {\n  /** Calldata to pass to the target address for counterfactual verification. */\n  data: Hex.Hex\n  /** The original signature. */\n  signature: Signature.Signature\n  /** The target address to use for counterfactual verification. */\n  to: Address.Address\n}\n\n/**\n * Magic bytes used to identify ERC-6492 wrapped signatures.\n */\nexport const magicBytes =\n  '0x6492649264926492649264926492649264926492649264926492649264926492' as const\n\n/**\n * Deployless ERC-6492 signature verification bytecode.\n */\nexport const universalSignatureValidatorBytecode =\n  '0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572'\n\n/**\n * ABI for the ERC-6492 universal deployless signature validator contract.\n *\n * Constructor return value is `0x1` (valid) or `0x0` (invalid).\n */\nexport const universalSignatureValidatorAbi = [\n  {\n    inputs: [\n      {\n        name: '_signer',\n        type: 'address',\n      },\n      {\n        name: '_hash',\n        type: 'bytes32',\n      },\n      {\n        name: '_signature',\n        type: 'bytes',\n      },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'constructor',\n  },\n  {\n    inputs: [\n      {\n        name: '_signer',\n        type: 'address',\n      },\n      {\n        name: '_hash',\n        type: 'bytes32',\n      },\n      {\n        name: '_signature',\n        type: 'bytes',\n      },\n    ],\n    outputs: [\n      {\n        type: 'bool',\n      },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'function',\n    name: 'isValidSig',\n  },\n] as const satisfies Abi.Abi\n\n/**\n * Asserts that the wrapped signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { WrappedSignature } from 'ox/erc6492'\n *\n * WrappedSignature.assert('0xdeadbeef')\n * // @error: InvalidWrappedSignatureError: Value `0xdeadbeef` is an invalid ERC-6492 wrapped signature.\n * ```\n *\n * @param wrapped - The wrapped signature to assert.\n */\nexport function assert(wrapped: Hex.Hex) {\n  if (Hex.slice(wrapped, -32) !== magicBytes)\n    throw new InvalidWrappedSignatureError(wrapped)\n}\n\nexport declare namespace assert {\n  type ErrorType =\n    | InvalidWrappedSignatureError\n    | Hex.slice.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Parses an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { WrappedSignature } from 'ox/erc6492' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * // Instantiate from serialized format. // [!code focus]\n * const wrapped = WrappedSignature.from('0x...') // [!code focus]\n * // @log: { data: '0x...', signature: { ... }, to: '0x...', } // [!code focus]\n *\n * // Instantiate from constituent parts. // [!code focus]\n * const wrapped = WrappedSignature.from({ // [!code focus]\n *   data: '0x...', // [!code focus]\n *   signature, // [!code focus]\n *   to: '0x...', // [!code focus]\n * })\n * // @log: { data: '0x...', signature: { ... }, to: '0x...', }\n * ```\n *\n * @param wrapped - Wrapped signature to parse.\n * @returns Wrapped signature.\n */\nexport function from(wrapped: WrappedSignature | Hex.Hex): WrappedSignature {\n  if (typeof wrapped === 'string') return fromHex(wrapped)\n  return wrapped\n}\n\nexport declare namespace from {\n  type ReturnType = WrappedSignature\n\n  type ErrorType =\n    | AbiParameters.from.ErrorType\n    | AbiParameters.decode.ErrorType\n    | Signature.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Parses an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * import { WrappedSignature } from 'ox/erc6492'\n *\n * const { data, signature, to } = WrappedSignature.fromHex('0x...')\n * ```\n *\n * @param wrapped - Wrapped signature to parse.\n * @returns Wrapped signature.\n */\nexport function fromHex(wrapped: Hex.Hex): WrappedSignature {\n  assert(wrapped)\n\n  const [to, data, signature_hex] = AbiParameters.decode(\n    AbiParameters.from('address, bytes, bytes'),\n    wrapped,\n  )\n\n  const signature = Signature.fromHex(signature_hex)\n\n  return { data, signature, to }\n}\n\nexport declare namespace fromHex {\n  type ErrorType =\n    | AbiParameters.from.ErrorType\n    | AbiParameters.decode.ErrorType\n    | Signature.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Serializes an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification).\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n * import { WrappedSignature } from 'ox/erc6492' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * const wrapped = WrappedSignature.toHex({ // [!code focus]\n *   data: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n *   to: '0x00000000219ab540356cBB839Cbe05303d7705Fa', // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param value - Wrapped signature to serialize.\n * @returns Serialized wrapped signature.\n */\nexport function toHex(value: WrappedSignature): Hex.Hex {\n  const { data, signature, to } = value\n\n  return Hex.concat(\n    AbiParameters.encode(AbiParameters.from('address, bytes, bytes'), [\n      to,\n      data,\n      Signature.toHex(signature),\n    ]),\n    magicBytes,\n  )\n}\n\nexport declare namespace toHex {\n  type ErrorType =\n    | AbiParameters.encode.ErrorType\n    | Hex.concat.ErrorType\n    | Signature.toHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Validates a wrapped signature. Returns `true` if the wrapped signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { WrappedSignature } from 'ox/erc6492'\n *\n * const valid = WrappedSignature.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param wrapped - The wrapped signature to validate.\n * @returns `true` if the wrapped signature is valid, `false` otherwise.\n */\nexport function validate(wrapped: Hex.Hex): boolean {\n  try {\n    assert(wrapped)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/** Thrown when the ERC-6492 wrapped signature is invalid. */\nexport class InvalidWrappedSignatureError extends Errors.BaseError {\n  override readonly name = 'WrappedSignature.InvalidWrappedSignatureError'\n\n  constructor(wrapped: Hex.Hex) {\n    super(`Value \\`${wrapped}\\` is an invalid ERC-6492 wrapped signature.`)\n  }\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"isValidSignature\" function.\n */\nexport type IsValidSignatureParams = {\n  hash: AbiParameterToPrimitiveType<{ type: \"bytes32\"; name: \"hash\" }>;\n  signature: AbiParameterToPrimitiveType<{ type: \"bytes\"; name: \"signature\" }>;\n};\n\nexport const FN_SELECTOR = \"0x1626ba7e\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"bytes32\",\n    name: \"hash\",\n  },\n  {\n    type: \"bytes\",\n    name: \"signature\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"bytes4\",\n  },\n] as const;\n\n/**\n * Checks if the `isValidSignature` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `isValidSignature` method is supported.\n * @extension ERC1271\n * @example\n * ```ts\n * import { isIsValidSignatureSupported } from \"thirdweb/extensions/erc1271\";\n * const supported = isIsValidSignatureSupported([\"0x...\"]);\n * ```\n */\nexport function isIsValidSignatureSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"isValidSignature\" function.\n * @param options - The options for the isValidSignature function.\n * @returns The encoded ABI parameters.\n * @extension ERC1271\n * @example\n * ```ts\n * import { encodeIsValidSignatureParams } from \"thirdweb/extensions/erc1271\";\n * const result = encodeIsValidSignatureParams({\n *  hash: ...,\n *  signature: ...,\n * });\n * ```\n */\nexport function encodeIsValidSignatureParams(options: IsValidSignatureParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.hash, options.signature]);\n}\n\n/**\n * Encodes the \"isValidSignature\" function into a Hex string with its parameters.\n * @param options - The options for the isValidSignature function.\n * @returns The encoded hexadecimal string.\n * @extension ERC1271\n * @example\n * ```ts\n * import { encodeIsValidSignature } from \"thirdweb/extensions/erc1271\";\n * const result = encodeIsValidSignature({\n *  hash: ...,\n *  signature: ...,\n * });\n * ```\n */\nexport function encodeIsValidSignature(options: IsValidSignatureParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeIsValidSignatureParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the isValidSignature function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC1271\n * @example\n * ```ts\n * import { decodeIsValidSignatureResult } from \"thirdweb/extensions/erc1271\";\n * const result = decodeIsValidSignatureResultResult(\"...\");\n * ```\n */\nexport function decodeIsValidSignatureResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"isValidSignature\" function on the contract.\n * @param options - The options for the isValidSignature function.\n * @returns The parsed result of the function call.\n * @extension ERC1271\n * @example\n * ```ts\n * import { isValidSignature } from \"thirdweb/extensions/erc1271\";\n *\n * const result = await isValidSignature({\n *  contract,\n *  hash: ...,\n *  signature: ...,\n * });\n *\n * ```\n */\nexport async function isValidSignature(\n  options: BaseTransactionOptions<IsValidSignatureParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.hash, options.signature],\n  });\n}\n", "import * as ox__Bytes from \"ox/Bytes\";\nimport { type Hex, uint8ArrayToHex } from \"./hex.js\";\n\nexport type FromBytesParameters<\n  TTo extends \"string\" | \"hex\" | \"bigint\" | \"number\" | \"boolean\",\n> =\n  | TTo\n  | {\n      /** Size of the bytes. */\n      size?: number;\n      /** Type to convert to. */\n      to: TTo;\n    };\n\nexport type FromBytesReturnType<TTo> = TTo extends \"string\"\n  ? string\n  : TTo extends \"hex\"\n    ? Hex\n    : TTo extends \"bigint\"\n      ? bigint\n      : TTo extends \"number\"\n        ? number\n        : TTo extends \"boolean\"\n          ? boolean\n          : never;\n\n/**\n * Converts a Uint8Array to the specified type.\n * @param bytes - The Uint8Array to convert.\n * @param toOrOpts - The target type or conversion options.\n * @returns The converted value of the specified type.\n * @example\n * ```ts\n * import { fromBytes } from \"thirdweb/utils\";\n * const bytes = new Uint8Array([1, 164]);\n * const number = fromBytes(bytes, \"number\");\n * console.log(number); // 420\n * ```\n * @utils\n */\nexport function fromBytes<\n  TTo extends \"string\" | \"hex\" | \"bigint\" | \"number\" | \"boolean\",\n>(\n  bytes: Uint8Array,\n  toOrOpts: FromBytesParameters<TTo>,\n): FromBytesReturnType<TTo> {\n  const opts = typeof toOrOpts === \"string\" ? { to: toOrOpts } : toOrOpts;\n  switch (opts.to) {\n    case \"number\":\n      return bytesToNumber(bytes, opts) as FromBytesReturnType<TTo>;\n    case \"bigint\":\n      return bytesToBigInt(bytes, opts) as FromBytesReturnType<TTo>;\n    case \"boolean\":\n      return bytesToBool(bytes, opts) as FromBytesReturnType<TTo>;\n    case \"string\":\n      return bytesToString(bytes, opts) as FromBytesReturnType<TTo>;\n    default:\n      return uint8ArrayToHex(bytes, opts) as FromBytesReturnType<TTo>;\n  }\n}\n\nexport type BytesToBigIntOpts = {\n  /** Whether or not the number of a signed representation. */\n  signed?: boolean;\n  /** Size of the bytes. */\n  size?: number;\n};\n\n/**\n * Converts a Uint8Array of bytes to a bigint.\n * @param bytes - The Uint8Array of bytes to convert.\n * @param opts - Optional parameters for the conversion.\n * @returns The converted bigint.\n * @example\n * ```ts\n * import { bytesToBigInt } from \"thirdweb/utils\";\n * const bytes = new Uint8Array([1, 164]);\n * const bigInt = bytesToBigInt(bytes);\n * console.log(bigInt); // 420n\n * ```\n * @utils\n */\nexport function bytesToBigInt(\n  bytes: Uint8Array,\n  opts: BytesToBigIntOpts = {},\n): bigint {\n  return ox__Bytes.toBigInt(bytes, opts);\n}\n\nexport type BytesToBoolOpts = ox__Bytes.toBoolean.Options;\n\n/**\n * Converts a byte array to a boolean value.\n * @param bytes_ - The byte array to convert.\n * @param opts - Optional parameters for the conversion.\n * @returns The boolean value converted from the byte array.\n * @throws Error if the byte array is invalid or the boolean representation is invalid.\n * @example\n * ```ts\n * import { bytesToBool } from \"thirdweb/utils\";\n * const bytes = new Uint8Array([1]);\n * const bool = bytesToBool(bytes);\n * console.log(bool); // true\n * ```\n * @utils\n */\nexport function bytesToBool(\n  bytes_: Uint8Array,\n  opts: BytesToBoolOpts = {},\n): boolean {\n  return ox__Bytes.toBoolean(bytes_, opts);\n}\n\nexport type BytesToNumberOpts = BytesToBigIntOpts;\n\n/**\n * Converts a Uint8Array of bytes to a number.\n * @param bytes - The Uint8Array of bytes to convert.\n * @param opts - Optional configuration options.\n * @returns The converted number.\n * @example\n * ```ts\n * import { bytesToNumber } from \"thirdweb/utils\";\n * const bytes = new Uint8Array([1, 164]);\n * const number = bytesToNumber(bytes);\n * console.log(number); // 420\n * ```\n * @utils\n */\nexport function bytesToNumber(\n  bytes: Uint8Array,\n  opts: BytesToNumberOpts = {},\n): number {\n  return ox__Bytes.toNumber(bytes, opts);\n}\n\nexport type BytesToStringOpts = ox__Bytes.toString.Options;\n\n/**\n * Converts an array of bytes to a string using UTF-8 encoding.\n * @param bytes_ - The array of bytes to convert.\n * @param opts - Optional parameters for the conversion.\n * @returns The resulting string.\n * @example\n * ```ts\n * import { bytesToString } from \"thirdweb/utils\";\n * const bytes = new Uint8Array([72, 101, 108, 108, 111]);\n * const string = bytesToString(bytes);\n * console.log(string); // \"Hello\"\n * ```\n * @utils\n */\nexport function bytesToString(\n  bytes_: Uint8Array,\n  opts: BytesToStringOpts = {},\n): string {\n  return ox__Bytes.toString(bytes_, opts);\n}\n", "import * as ox__Abi from \"ox/Abi\";\nimport * as ox__AbiConstructor from \"ox/AbiConstructor\";\nimport * as ox__AbiFunction from \"ox/AbiFunction\";\nimport * as ox__Signature from \"ox/Signature\";\nimport { WrappedSignature as ox__WrappedSignature } from \"ox/erc6492\";\nimport type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { type ThirdwebContract, getContract } from \"../contract/contract.js\";\nimport { isValidSignature } from \"../extensions/erc1271/__generated__/isValidSignature/read/isValidSignature.js\";\nimport { eth_call } from \"../rpc/actions/eth_call.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\nimport type { Address } from \"../utils/address.js\";\nimport { isZkSyncChain } from \"../utils/any-evm/zksync/isZkSyncChain.js\";\nimport { isContractDeployed } from \"../utils/bytecode/is-contract-deployed.js\";\nimport { fromBytes } from \"../utils/encoding/from-bytes.js\";\nimport { type Hex, hexToBool, isHex } from \"../utils/encoding/hex.js\";\nimport { serializeErc6492Signature } from \"./serialize-erc6492-signature.js\";\n\nexport type VerifyHashParams = {\n  hash: Hex;\n  signature: string | Uint8Array | ox__Signature.Signature;\n  address: string;\n  client: ThirdwebClient;\n  chain: Chain;\n  accountFactory?: {\n    address: string;\n    verificationCalldata: Hex;\n  };\n};\n\nconst ZKSYNC_VALIDATOR_ADDRESS: Address =\n  \"0xfB688330379976DA81eB64Fe4BF50d7401763B9C\";\n\n/**\n * Verify that an address created the provided signature for a given hash using [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492). This function is interoperable with all wallet types, including EOAs.\n * This function should rarely be used directly, instead use @see {import(\"./verify-signature.js\")} and @see {import(\"./verify-typed-data.js\")}}\n *\n * @param {Hex} options.hash The hash that was signed\n * @param {string | Uint8Array | Signature} options.signature The signature that was signed\n * @param {string} options.address The address that signed the hash\n * @param {ThirdwebClient} options.client The Thirdweb client\n * @param {Chain} options.chain The chain that the address is on. For an EOA, this can be any chain.\n * @param {string} [options.accountFactory.address] The address of the account factory that created the account if using a smart account with a custom account factory\n * @param {Hex} [options.accountFactory.verificationCalldata] The calldata that was used to create the account if using a smart account with a custom account factory\n *\n * @returns {Promise<boolean>} A promise that resolves to `true` if the signature is valid, or `false` otherwise.\n *\n * @example\n * ```ts\n * import { verifyHash } from \"thirdweb/utils\";\n * const isValid = await verifyHash({\n *   hash: \"0x1234\",\n *   signature: \"0x1234\",\n *   address: \"0x1234\",\n *   client,\n *   chain,\n * });\n * ```\n *\n * @auth\n */\nexport async function verifyHash({\n  hash,\n  signature,\n  address,\n  client,\n  chain,\n  accountFactory,\n}: VerifyHashParams): Promise<boolean> {\n  const signatureHex = (() => {\n    if (isHex(signature)) return signature;\n    if (typeof signature === \"object\" && \"r\" in signature && \"s\" in signature)\n      return ox__Signature.toHex(signature);\n    if (signature instanceof Uint8Array) return fromBytes(signature, \"hex\");\n    // We should never hit this but TS doesn't know that\n    throw new Error(\n      `Invalid signature type for signature ${signature}: ${typeof signature}`,\n    );\n  })();\n\n  const isDeployed = await isContractDeployed(\n    getContract({\n      address,\n      client,\n      chain,\n    }),\n  );\n\n  if (isDeployed) {\n    const validEip1271 = await verifyEip1271Signature({\n      hash,\n      signature: signatureHex,\n      contract: getContract({\n        chain,\n        address,\n        client,\n      }),\n    }).catch((err) => {\n      console.error(\"Error verifying EIP-1271 signature\", err);\n      return false;\n    });\n    if (validEip1271) {\n      return true;\n    }\n  }\n\n  // contract not deployed, use erc6492 validator to verify signature\n  const wrappedSignature: Hex = await (async () => {\n    // If no factory is provided, we have to assume its already deployed or is an EOA\n    // TODO: Figure out how to automatically tell if our default factory was used\n    if (!accountFactory) return signatureHex;\n\n    // If this sigature was already wrapped for ERC-6492, carry on\n    if (ox__WrappedSignature.validate(signatureHex)) return signatureHex;\n\n    // Otherwise, serialize the signature for ERC-6492 validation\n    return serializeErc6492Signature({\n      address: accountFactory.address,\n      data: accountFactory.verificationCalldata,\n      signature: signatureHex,\n    });\n  })();\n\n  let verificationData: {\n    to?: Address;\n    data: Hex;\n  };\n\n  const zkSyncChain = await isZkSyncChain(chain);\n  const abi = ox__Abi.from(ox__WrappedSignature.universalSignatureValidatorAbi);\n  if (zkSyncChain) {\n    // zksync chains dont support deploying code with eth_call\n    // need to call a deployed contract instead\n    verificationData = {\n      to: ZKSYNC_VALIDATOR_ADDRESS,\n      data: ox__AbiFunction.encodeData(\n        ox__AbiFunction.fromAbi(abi, \"isValidSig\"),\n        [address, hash, wrappedSignature],\n      ),\n    };\n  } else {\n    const validatorConstructor = ox__AbiConstructor.fromAbi(abi);\n    verificationData = {\n      data: ox__AbiConstructor.encode(validatorConstructor, {\n        args: [address, hash, wrappedSignature],\n        bytecode: ox__WrappedSignature.universalSignatureValidatorBytecode,\n      }),\n    };\n  }\n\n  const rpcRequest = getRpcClient({\n    chain,\n    client,\n  });\n\n  try {\n    const result = await eth_call(rpcRequest, verificationData);\n    return hexToBool(result);\n  } catch {\n    // Some chains do not support the eth_call simulation and will fail, so we fall back to regular EIP1271 validation\n    const validEip1271 = await verifyEip1271Signature({\n      hash,\n      signature: signatureHex,\n      contract: getContract({\n        chain,\n        address,\n        client,\n      }),\n    }).catch((err) => {\n      console.error(\"Error verifying EIP-1271 signature\", err);\n      return false;\n    });\n    if (validEip1271) {\n      return true;\n    }\n    // TODO: Improve overall RPC error handling so we can tell if this was an actual verification failure or some other error\n    // Verification failed somehow\n    return false;\n  }\n}\n\nconst EIP_1271_MAGIC_VALUE = \"0x1626ba7e\";\nexport async function verifyEip1271Signature({\n  hash,\n  signature,\n  contract,\n}: {\n  hash: Hex;\n  signature: Hex;\n  contract: ThirdwebContract;\n}): Promise<boolean> {\n  try {\n    const result = await isValidSignature({\n      hash,\n      signature,\n      contract,\n    });\n    return result === EIP_1271_MAGIC_VALUE;\n  } catch (err) {\n    console.error(\"Error verifying EIP-1271 signature\", err);\n    return false;\n  }\n}\n", "import * as ox__Bytes from \"ox/Bytes\";\nimport type { Hex } from \"../encoding/hex.js\";\nimport { stringToBytes, toBytes } from \"../encoding/to-bytes.js\";\nimport type { SignableMessage } from \"../types.js\";\nimport { keccak256 } from \"./keccak256.js\";\n\nconst presignMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\ntype To = \"hex\" | \"bytes\";\n\ntype HashMessage<TTo extends To> =\n  | (TTo extends \"bytes\" ? ox__Bytes.Bytes : never)\n  | (TTo extends \"hex\" ? Hex : never);\n\n/**\n * Ethereum Signed Message hashing\n * @param message - The message to hash, either as a string, a Uint8Array, or an object with a `raw` property containing a Uint8Array.\n * @param to_ - The desired output format of the hash (optional). Defaults to 'hex'.\n * @example\n * ```ts\n * import { hashMessage } from \"thirdweb/utils\";\n * const hash = hashMessage(\"hello world\");\n * ```\n * @returns The Ethereum Signed Message hash of the message in the specified format.\n * @utils\n */\nexport function hashMessage<TTo extends To = \"hex\">(\n  message: SignableMessage,\n  to_?: TTo,\n): HashMessage<TTo> {\n  const messageBytes = (() => {\n    if (typeof message === \"string\") {\n      return stringToBytes(message);\n    }\n    if (message.raw instanceof Uint8Array) {\n      return message.raw;\n    }\n    return toBytes(message.raw);\n  })();\n  const prefixBytes = stringToBytes(\n    `${presignMessagePrefix}${messageBytes.length}`,\n  );\n  return keccak256(ox__Bytes.concat(prefixBytes, messageBytes), to_);\n}\n", "import type * as ox__AbiParameters from \"ox/AbiParameters\";\nimport * as ox__Bytes from \"ox/Bytes\";\nimport * as ox__TypedData from \"ox/TypedData\";\nimport { encodeAbiParameters } from \"../abi/encodeAbiParameters.js\";\nimport { type Hex, toHex } from \"../encoding/hex.js\";\nimport { keccak256 } from \"./keccak256.js\";\n\ntype MessageTypeProperty = {\n  name: string;\n  type: string;\n};\n\nexport type HashTypedDataParams<\n  typedData extends\n    | ox__TypedData.TypedData\n    | Record<string, unknown> = ox__TypedData.TypedData,\n  primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n> = ox__TypedData.Definition<typedData, primaryType>;\n\n/**\n * @internal\n */\nexport function hashTypedData<\n  const typedData extends ox__TypedData.TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | \"EIP712Domain\",\n>(parameters: HashTypedDataParams<typedData, primaryType>): Hex {\n  const {\n    domain = {},\n    message,\n    primaryType,\n  } = parameters as HashTypedDataParams;\n  const types = {\n    EIP712Domain: ox__TypedData.extractEip712DomainTypes(domain),\n    ...parameters.types,\n  };\n\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  ox__TypedData.validate({\n    domain,\n    message,\n    primaryType,\n    types,\n  });\n\n  const parts: Hex[] = [\"0x1901\"];\n  if (domain)\n    parts.push(\n      ox__TypedData.hashDomain({\n        domain,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    );\n\n  if (primaryType !== \"EIP712Domain\") {\n    const hashedStruct = (() => {\n      const encoded = encodeData({\n        data: message,\n        primaryType,\n        types: types as Record<string, MessageTypeProperty[]>,\n      });\n      return keccak256(encoded);\n    })();\n\n    parts.push(hashedStruct);\n  }\n\n  return keccak256(ox__Bytes.concat(...parts.map((p) => ox__Bytes.fromHex(p))));\n}\n\nfunction encodeData({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>;\n  primaryType: string;\n  types: Record<string, MessageTypeProperty[]>;\n}) {\n  const encodedTypes: ox__AbiParameters.Parameter[] = [{ type: \"bytes32\" }];\n  const encodedValues: unknown[] = [hashType({ primaryType, types })];\n\n  if (!types[primaryType]) throw new Error(\"Invalid types\");\n  for (const field of types[primaryType]) {\n    const [type, value] = encodeField({\n      types,\n      name: field.name,\n      type: field.type,\n      value: data[field.name],\n    });\n    encodedTypes.push(type);\n    encodedValues.push(value);\n  }\n\n  return encodeAbiParameters(encodedTypes, encodedValues);\n}\n\nfunction hashType({\n  primaryType,\n  types,\n}: {\n  primaryType: string;\n  types: Record<string, MessageTypeProperty[]>;\n}) {\n  const encodedHashType = toHex(encodeType({ primaryType, types }));\n  return keccak256(encodedHashType);\n}\n\nfunction encodeType({\n  primaryType,\n  types,\n}: {\n  primaryType: string;\n  types: Record<string, MessageTypeProperty[]>;\n}) {\n  let result = \"\";\n  const unsortedDeps = findTypeDependencies({ primaryType, types });\n  unsortedDeps.delete(primaryType);\n\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()];\n  for (const type of deps) {\n    if (!types[type]) throw new Error(\"Invalid types\");\n    result += `${type}(${types[type]\n      .map(({ name, type: t }) => `${t} ${name}`)\n      .join(\",\")})`;\n  }\n\n  return result;\n}\n\nfunction findTypeDependencies(\n  {\n    primaryType: primaryType_,\n    types,\n  }: {\n    primaryType: string;\n    types: Record<string, MessageTypeProperty[]>;\n  },\n  results: Set<string> = new Set(),\n): Set<string> {\n  const match = primaryType_.match(/^\\w*/u);\n  const primaryType = match?.[0] as string;\n  if (results.has(primaryType) || types[primaryType] === undefined) {\n    return results;\n  }\n\n  results.add(primaryType);\n\n  for (const field of types[primaryType]) {\n    findTypeDependencies({ primaryType: field.type, types }, results);\n  }\n  return results;\n}\n\nfunction encodeField({\n  types,\n  name,\n  type,\n  value,\n}: {\n  types: Record<string, MessageTypeProperty[]>;\n  name: string;\n  type: string;\n  // biome-ignore lint/suspicious/noExplicitAny: Can't anticipate types of nested values\n  value: any;\n  // biome-ignore lint/suspicious/noExplicitAny: Can't anticipate types of nested values\n}): [type: ox__AbiParameters.Parameter, value: any] {\n  if (types[type] !== undefined) {\n    return [\n      { type: \"bytes32\" },\n      keccak256(encodeData({ data: value, primaryType: type, types })),\n    ];\n  }\n\n  if (type === \"bytes\") {\n    const prepend = value.length % 2 ? \"0\" : \"\";\n    value = `0x${prepend + value.slice(2)}`;\n    return [{ type: \"bytes32\" }, keccak256(value)];\n  }\n\n  if (type === \"string\") return [{ type: \"bytes32\" }, keccak256(toHex(value))];\n\n  if (type.lastIndexOf(\"]\") === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf(\"[\"));\n    const typeValuePairs =\n      // biome-ignore lint/suspicious/noExplicitAny: Can't anticipate types of nested values\n      (value as [ox__AbiParameters.Parameter, any][]).map((item) =>\n        encodeField({\n          name,\n          type: parsedType,\n          types,\n          value: item,\n        }),\n      );\n    return [\n      { type: \"bytes32\" },\n      keccak256(\n        encodeAbiParameters(\n          typeValuePairs.map(([t]) => t),\n          typeValuePairs.map(([, v]) => v),\n        ),\n      ),\n    ];\n  }\n\n  return [{ type }, value];\n}\n", "import type * as ox__TypedData from \"ox/TypedData\";\nimport { serializeErc6492Signature } from \"../../../auth/serialize-erc6492-signature.js\";\nimport {\n  verifyEip1271Signature,\n  verifyHash,\n} from \"../../../auth/verify-hash.js\";\nimport type { Chain } from \"../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport {\n  type ThirdwebContract,\n  getContract,\n} from \"../../../contract/contract.js\";\nimport { encode } from \"../../../transaction/actions/encode.js\";\nimport { readContract } from \"../../../transaction/read-contract.js\";\nimport { encodeAbiParameters } from \"../../../utils/abi/encodeAbiParameters.js\";\nimport { isContractDeployed } from \"../../../utils/bytecode/is-contract-deployed.js\";\nimport type { Hex } from \"../../../utils/encoding/hex.js\";\nimport { hashMessage } from \"../../../utils/hashing/hashMessage.js\";\nimport { hashTypedData } from \"../../../utils/hashing/hashTypedData.js\";\nimport type { SignableMessage } from \"../../../utils/types.js\";\nimport type { Account } from \"../../../wallets/interfaces/wallet.js\";\nimport type { SmartAccountOptions } from \"../types.js\";\nimport { prepareCreateAccount } from \"./calls.js\";\n\n/**\n * If the account is already deployed, generate an ERC-1271 signature.\n * If the account is not deployed, generate an ERC-6492 signature unless otherwise specified.\n *\n * @internal\n */\nexport async function smartAccountSignMessage({\n  accountContract,\n  factoryContract,\n  options,\n  message,\n}: {\n  accountContract: ThirdwebContract;\n  factoryContract: ThirdwebContract;\n  options: SmartAccountOptions;\n  message: SignableMessage;\n}) {\n  const originalMsgHash = hashMessage(message);\n  const is712Factory = await checkFor712Factory({\n    factoryContract,\n    accountContract,\n    originalMsgHash,\n  });\n\n  let sig: `0x${string}`;\n  if (is712Factory) {\n    const wrappedMessageHash = encodeAbiParameters(\n      [{ type: \"bytes32\" }],\n      [originalMsgHash],\n    );\n\n    sig = await options.personalAccount.signTypedData({\n      domain: {\n        name: \"Account\",\n        version: \"1\",\n        chainId: options.chain.id,\n        verifyingContract: accountContract.address,\n      },\n      primaryType: \"AccountMessage\",\n      types: { AccountMessage: [{ name: \"message\", type: \"bytes\" }] },\n      message: { message: wrappedMessageHash },\n    });\n  } else {\n    sig = await options.personalAccount.signMessage({ message });\n  }\n\n  const isDeployed = await isContractDeployed(accountContract);\n  if (isDeployed) {\n    const isValid = await verifyEip1271Signature({\n      hash: originalMsgHash,\n      signature: sig,\n      contract: accountContract,\n    });\n    if (isValid) {\n      return sig;\n    }\n    throw new Error(\"Failed to verify signature\");\n  } else {\n    const deployTx = prepareCreateAccount({\n      factoryContract,\n      adminAddress: options.personalAccount.address,\n      accountSalt: options.overrides?.accountSalt,\n      createAccountOverride: options.overrides?.createAccount,\n    });\n    if (!deployTx) {\n      throw new Error(\"Create account override not provided\");\n    }\n    const initCode = await encode(deployTx);\n    const erc6492Sig = serializeErc6492Signature({\n      address: factoryContract.address,\n      data: initCode,\n      signature: sig,\n    });\n\n    // check if the signature is valid\n    const isValid = await verifyHash({\n      hash: originalMsgHash,\n      signature: erc6492Sig,\n      address: accountContract.address,\n      chain: accountContract.chain,\n      client: accountContract.client,\n    });\n\n    if (isValid) {\n      return erc6492Sig;\n    }\n    throw new Error(\"Unable to verify ERC-6492 signature after signing.\");\n  }\n}\n\nexport async function smartAccountSignTypedData<\n  const typedData extends ox__TypedData.TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n>({\n  accountContract,\n  factoryContract,\n  options,\n  typedData,\n}: {\n  accountContract: ThirdwebContract;\n  factoryContract: ThirdwebContract;\n  options: SmartAccountOptions;\n  typedData: ox__TypedData.Definition<typedData, primaryType>;\n}) {\n  const isSelfVerifyingContract =\n    (\n      typedData.domain as ox__TypedData.Domain\n    )?.verifyingContract?.toLowerCase() ===\n    accountContract.address?.toLowerCase();\n\n  if (isSelfVerifyingContract) {\n    // if the contract is self-verifying, we can just sign the message with the EOA (ie. adding a session key)\n    return options.personalAccount.signTypedData(typedData);\n  }\n\n  const originalMsgHash = hashTypedData(typedData);\n  // check if the account contract supports EIP721 domain separator based signing\n  const is712Factory = await checkFor712Factory({\n    factoryContract,\n    accountContract,\n    originalMsgHash,\n  });\n\n  let sig: `0x${string}`;\n  if (is712Factory) {\n    const wrappedMessageHash = encodeAbiParameters(\n      [{ type: \"bytes32\" }],\n      [originalMsgHash],\n    );\n    sig = await options.personalAccount.signTypedData({\n      domain: {\n        name: \"Account\",\n        version: \"1\",\n        chainId: options.chain.id,\n        verifyingContract: accountContract.address,\n      },\n      primaryType: \"AccountMessage\",\n      types: { AccountMessage: [{ name: \"message\", type: \"bytes\" }] },\n      message: { message: wrappedMessageHash },\n    });\n  } else {\n    sig = await options.personalAccount.signTypedData(typedData);\n  }\n\n  const isDeployed = await isContractDeployed(accountContract);\n  if (isDeployed) {\n    const isValid = await verifyEip1271Signature({\n      hash: originalMsgHash,\n      signature: sig,\n      contract: accountContract,\n    });\n    if (isValid) {\n      return sig;\n    }\n    throw new Error(\"Failed to verify signature\");\n  } else {\n    const deployTx = prepareCreateAccount({\n      factoryContract,\n      adminAddress: options.personalAccount.address,\n      accountSalt: options.overrides?.accountSalt,\n      createAccountOverride: options.overrides?.createAccount,\n    });\n    if (!deployTx) {\n      throw new Error(\"Create account override not provided\");\n    }\n    const initCode = await encode(deployTx);\n    const erc6492Sig = serializeErc6492Signature({\n      address: factoryContract.address,\n      data: initCode,\n      signature: sig,\n    });\n\n    // check if the signature is valid\n    const isValid = await verifyHash({\n      hash: originalMsgHash,\n      signature: erc6492Sig,\n      address: accountContract.address,\n      chain: accountContract.chain,\n      client: accountContract.client,\n    });\n\n    if (isValid) {\n      return erc6492Sig;\n    }\n    throw new Error(\n      \"Unable to verify signature on smart account, please make sure the admin wallet has permissions and the signature is valid.\",\n    );\n  }\n}\n\nexport async function confirmContractDeployment(args: {\n  accountContract: ThirdwebContract;\n}) {\n  const { accountContract } = args;\n  const startTime = Date.now();\n  const timeout = 60000; // wait 1 minute max\n  const { isContractDeployed } = await import(\n    \"../../../utils/bytecode/is-contract-deployed.js\"\n  );\n  let isDeployed = await isContractDeployed(accountContract);\n  while (!isDeployed) {\n    if (Date.now() - startTime > timeout) {\n      throw new Error(\n        \"Timeout: Smart account deployment not confirmed after 1 minute\",\n      );\n    }\n    await new Promise((resolve) => setTimeout(resolve, 500));\n    isDeployed = await isContractDeployed(accountContract);\n  }\n}\n\nasync function checkFor712Factory({\n  factoryContract,\n  accountContract,\n  originalMsgHash,\n}: {\n  factoryContract: ThirdwebContract;\n  accountContract: ThirdwebContract;\n  originalMsgHash: Hex;\n}) {\n  try {\n    const implementationAccount = await readContract({\n      contract: factoryContract,\n      method: \"function accountImplementation() public view returns (address)\",\n    });\n    // check if the account contract supports EIP721 domain separator or modular based signing\n    const is712Factory = await readContract({\n      contract: getContract({\n        address: implementationAccount,\n        chain: accountContract.chain,\n        client: accountContract.client,\n      }),\n      method:\n        \"function getMessageHash(bytes32 _hash) public view returns (bytes32)\",\n      params: [originalMsgHash],\n    })\n      .then((res) => res !== \"0x\")\n      .catch(() => false);\n\n    return is712Factory;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Deployes a smart account via a dummy transaction. If the account is already deployed, this will do nothing.\n *\n * @param args - Arguments for the deployment.\n * @param args.smartAccount - The smart account to deploy.\n * @param args.chain - The chain to deploy on.\n * @param args.client - The client to use for the deployment.\n * @param args.accountContract - The account contract to deploy.\n *\n * @example\n * ```ts\n * import { deploySmartAccount } from \"thirdweb\";\n *\n * const account = await deploySmartAccount({\n *   smartAccount,\n *   chain,\n *   client,\n *   accountContract,\n * });\n * ```\n *\n * @wallet\n */\nexport async function deploySmartAccount(args: {\n  smartAccount: Account;\n  chain: Chain;\n  client: ThirdwebClient;\n  accountContract: ThirdwebContract;\n}) {\n  const { chain, client, smartAccount, accountContract } = args;\n  const isDeployed = await isContractDeployed(accountContract);\n  if (isDeployed) {\n    return;\n  }\n\n  const [{ sendTransaction }, { prepareTransaction }] = await Promise.all([\n    import(\"../../../transaction/actions/send-transaction.js\"),\n    import(\"../../../transaction/prepare-transaction.js\"),\n  ]);\n  const dummyTx = prepareTransaction({\n    client: client,\n    chain: chain,\n    to: accountContract.address,\n    value: 0n,\n    gas: 50000n, // force gas to avoid simulation error\n  });\n  const deployResult = await sendTransaction({\n    transaction: dummyTx,\n    account: smartAccount,\n  });\n\n  await confirmContractDeployment({\n    accountContract,\n  });\n\n  return deployResult;\n}\n"],
  "mappings": "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",
  "names": ["from", "validate", "abiItem", "encode", "concat", "fromAbi", "item", "fromAbi", "getSelector", "concat", "fromAbi", "getSelector", "from", "fromHex", "toHex", "validate", "from", "fromHex", "toHex", "concat", "validate", "toHex", "from", "fromAbi", "encode", "keccak256", "validate", "encodeData", "keccak256", "encode", "isContractDeployed"]
}
