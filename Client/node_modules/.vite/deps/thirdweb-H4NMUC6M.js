import {
  __publicField
} from "./chunk-OS7ZSSJM.js";

// node_modules/@hey-api/client-fetch/dist/index.js
var A = async (t, r) => {
  let e = typeof r == "function" ? await r(t) : r;
  if (e) return t.scheme === "bearer" ? `Bearer ${e}` : t.scheme === "basic" ? `Basic ${btoa(e)}` : e;
};
var R = { bodySerializer: (t) => JSON.stringify(t, (r, e) => typeof e == "bigint" ? e.toString() : e) };
var U = (t) => {
  switch (t) {
    case "label":
      return ".";
    case "matrix":
      return ";";
    case "simple":
      return ",";
    default:
      return "&";
  }
};
var _ = (t) => {
  switch (t) {
    case "form":
      return ",";
    case "pipeDelimited":
      return "|";
    case "spaceDelimited":
      return "%20";
    default:
      return ",";
  }
};
var D = (t) => {
  switch (t) {
    case "label":
      return ".";
    case "matrix":
      return ";";
    case "simple":
      return ",";
    default:
      return "&";
  }
};
var O = ({ allowReserved: t, explode: r, name: e, style: a, value: i }) => {
  if (!r) {
    let s = (t ? i : i.map((l) => encodeURIComponent(l))).join(_(a));
    switch (a) {
      case "label":
        return `.${s}`;
      case "matrix":
        return `;${e}=${s}`;
      case "simple":
        return s;
      default:
        return `${e}=${s}`;
    }
  }
  let o = U(a), n = i.map((s) => a === "label" || a === "simple" ? t ? s : encodeURIComponent(s) : y({ allowReserved: t, name: e, value: s })).join(o);
  return a === "label" || a === "matrix" ? o + n : n;
};
var y = ({ allowReserved: t, name: r, value: e }) => {
  if (e == null) return "";
  if (typeof e == "object") throw new Error("Deeply-nested arrays/objects arenâ€™t supported. Provide your own `querySerializer()` to handle these.");
  return `${r}=${t ? e : encodeURIComponent(e)}`;
};
var q = ({ allowReserved: t, explode: r, name: e, style: a, value: i }) => {
  if (i instanceof Date) return `${e}=${i.toISOString()}`;
  if (a !== "deepObject" && !r) {
    let s = [];
    Object.entries(i).forEach(([f, u]) => {
      s = [...s, f, t ? u : encodeURIComponent(u)];
    });
    let l = s.join(",");
    switch (a) {
      case "form":
        return `${e}=${l}`;
      case "label":
        return `.${l}`;
      case "matrix":
        return `;${e}=${l}`;
      default:
        return l;
    }
  }
  let o = D(a), n = Object.entries(i).map(([s, l]) => y({ allowReserved: t, name: a === "deepObject" ? `${e}[${s}]` : s, value: l })).join(o);
  return a === "label" || a === "matrix" ? o + n : n;
};
var H = /\{[^{}]+\}/g;
var B = ({ path: t, url: r }) => {
  let e = r, a = r.match(H);
  if (a) for (let i of a) {
    let o = false, n = i.substring(1, i.length - 1), s = "simple";
    n.endsWith("*") && (o = true, n = n.substring(0, n.length - 1)), n.startsWith(".") ? (n = n.substring(1), s = "label") : n.startsWith(";") && (n = n.substring(1), s = "matrix");
    let l = t[n];
    if (l == null) continue;
    if (Array.isArray(l)) {
      e = e.replace(i, O({ explode: o, name: n, style: s, value: l }));
      continue;
    }
    if (typeof l == "object") {
      e = e.replace(i, q({ explode: o, name: n, style: s, value: l }));
      continue;
    }
    if (s === "matrix") {
      e = e.replace(i, `;${y({ name: n, value: l })}`);
      continue;
    }
    let f = encodeURIComponent(s === "label" ? `.${l}` : l);
    e = e.replace(i, f);
  }
  return e;
};
var E = ({ allowReserved: t, array: r, object: e } = {}) => (i) => {
  let o = [];
  if (i && typeof i == "object") for (let n in i) {
    let s = i[n];
    if (s != null) {
      if (Array.isArray(s)) {
        o = [...o, O({ allowReserved: t, explode: true, name: n, style: "form", value: s, ...r })];
        continue;
      }
      if (typeof s == "object") {
        o = [...o, q({ allowReserved: t, explode: true, name: n, style: "deepObject", value: s, ...e })];
        continue;
      }
      o = [...o, y({ allowReserved: t, name: n, value: s })];
    }
  }
  return o.join("&");
};
var P = (t) => {
  var _a;
  if (!t) return "stream";
  let r = (_a = t.split(";")[0]) == null ? void 0 : _a.trim();
  if (r) {
    if (r.startsWith("application/json") || r.endsWith("+json")) return "json";
    if (r === "multipart/form-data") return "formData";
    if (["application/", "audio/", "image/", "video/"].some((e) => r.startsWith(e))) return "blob";
    if (r.startsWith("text/")) return "text";
  }
};
var I = async ({ security: t, ...r }) => {
  for (let e of t) {
    let a = await A(e, r.auth);
    if (!a) continue;
    let i = e.name ?? "Authorization";
    switch (e.in) {
      case "query":
        r.query || (r.query = {}), r.query[i] = a;
        break;
      case "cookie":
        r.headers.append("Cookie", `${i}=${a}`);
        break;
      case "header":
      default:
        r.headers.set(i, a);
        break;
    }
    return;
  }
};
var S = (t) => W({ baseUrl: t.baseUrl, path: t.path, query: t.query, querySerializer: typeof t.querySerializer == "function" ? t.querySerializer : E(t.querySerializer), url: t.url });
var W = ({ baseUrl: t, path: r, query: e, querySerializer: a, url: i }) => {
  let o = i.startsWith("/") ? i : `/${i}`, n = (t ?? "") + o;
  r && (n = B({ path: r, url: n }));
  let s = e ? a(e) : "";
  return s.startsWith("?") && (s = s.substring(1)), s && (n += `?${s}`), n;
};
var C = (t, r) => {
  var _a;
  let e = { ...t, ...r };
  return ((_a = e.baseUrl) == null ? void 0 : _a.endsWith("/")) && (e.baseUrl = e.baseUrl.substring(0, e.baseUrl.length - 1)), e.headers = x(t.headers, r.headers), e;
};
var x = (...t) => {
  let r = new Headers();
  for (let e of t) {
    if (!e || typeof e != "object") continue;
    let a = e instanceof Headers ? e.entries() : Object.entries(e);
    for (let [i, o] of a) if (o === null) r.delete(i);
    else if (Array.isArray(o)) for (let n of o) r.append(i, n);
    else o !== void 0 && r.set(i, typeof o == "object" ? JSON.stringify(o) : o);
  }
  return r;
};
var h = class {
  constructor() {
    __publicField(this, "_fns");
    this._fns = [];
  }
  clear() {
    this._fns = [];
  }
  exists(r) {
    return this._fns.indexOf(r) !== -1;
  }
  eject(r) {
    let e = this._fns.indexOf(r);
    e !== -1 && (this._fns = [...this._fns.slice(0, e), ...this._fns.slice(e + 1)]);
  }
  use(r) {
    this._fns = [...this._fns, r];
  }
};
var T = () => ({ error: new h(), request: new h(), response: new h() });
var N = E({ allowReserved: false, array: { explode: true, style: "form" }, object: { explode: true, style: "deepObject" } });
var Q = { "Content-Type": "application/json" };
var w = (t = {}) => ({ ...R, headers: Q, parseAs: "auto", querySerializer: N, ...t });
var J = (t = {}) => {
  let r = C(w(), t), e = () => ({ ...r }), a = (n) => (r = C(r, n), e()), i = T(), o = async (n) => {
    let s = { ...r, ...n, fetch: n.fetch ?? r.fetch ?? globalThis.fetch, headers: x(r.headers, n.headers) };
    s.security && await I({ ...s, security: s.security }), s.body && s.bodySerializer && (s.body = s.bodySerializer(s.body)), (s.body === void 0 || s.body === "") && s.headers.delete("Content-Type");
    let l = S(s), f = { redirect: "follow", ...s }, u = new Request(l, f);
    for (let p of i.request._fns) u = await p(u, s);
    let k = s.fetch, c = await k(u);
    for (let p of i.response._fns) c = await p(c, u, s);
    let m = { request: u, response: c };
    if (c.ok) {
      if (c.status === 204 || c.headers.get("Content-Length") === "0") return { data: {}, ...m };
      let p = (s.parseAs === "auto" ? P(c.headers.get("Content-Type")) : s.parseAs) ?? "json";
      if (p === "stream") return { data: c.body, ...m };
      let b = await c[p]();
      return p === "json" && (s.responseValidator && await s.responseValidator(b), s.responseTransformer && (b = await s.responseTransformer(b))), { data: b, ...m };
    }
    let g = await c.text();
    try {
      g = JSON.parse(g);
    } catch {
    }
    let d = g;
    for (let p of i.error._fns) d = await p(g, c, u, s);
    if (d = d || {}, s.throwOnError) throw d;
    return { error: d, ...m };
  };
  return { buildUrl: S, connect: (n) => o({ ...n, method: "CONNECT" }), delete: (n) => o({ ...n, method: "DELETE" }), get: (n) => o({ ...n, method: "GET" }), getConfig: e, head: (n) => o({ ...n, method: "HEAD" }), interceptors: i, options: (n) => o({ ...n, method: "OPTIONS" }), patch: (n) => o({ ...n, method: "PATCH" }), post: (n) => o({ ...n, method: "POST" }), put: (n) => o({ ...n, method: "PUT" }), request: o, setConfig: a, trace: (n) => o({ ...n, method: "TRACE" }) };
};

// node_modules/@thirdweb-dev/insight/dist/esm/client/client.gen.js
var client = J(w());

// node_modules/@thirdweb-dev/insight/dist/esm/client/sdk.gen.js
var getV1Webhooks = (options) => {
  return ((options == null ? void 0 : options.client) ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/webhooks",
    ...options
  });
};
var postV1Webhooks = (options) => {
  return ((options == null ? void 0 : options.client) ?? client).post({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/webhooks",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options == null ? void 0 : options.headers
    }
  });
};
var deleteV1WebhooksByWebhookId = (options) => {
  return (options.client ?? client).delete({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/webhooks/{webhook_id}",
    ...options
  });
};
var patchV1WebhooksByWebhookId = (options) => {
  return (options.client ?? client).patch({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/webhooks/{webhook_id}",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options == null ? void 0 : options.headers
    }
  });
};
var postV1WebhooksByWebhookIdVerify = (options) => {
  return (options.client ?? client).post({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/webhooks/{webhook_id}/verify",
    ...options
  });
};
var postV1WebhooksByWebhookIdResendOtp = (options) => {
  return (options.client ?? client).post({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/webhooks/{webhook_id}/resend-otp",
    ...options
  });
};
var postV1WebhooksTest = (options) => {
  return ((options == null ? void 0 : options.client) ?? client).post({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/webhooks/test",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options == null ? void 0 : options.headers
    }
  });
};
var getV1Events = (options) => {
  return ((options == null ? void 0 : options.client) ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/events",
    ...options
  });
};
var getV1EventsByContractAddress = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/events/{contractAddress}",
    ...options
  });
};
var getV1EventsByContractAddressBySignature = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/events/{contractAddress}/{signature}",
    ...options
  });
};
var getV1Transactions = (options) => {
  return ((options == null ? void 0 : options.client) ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/transactions",
    ...options
  });
};
var getV1TransactionsByContractAddress = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/transactions/{contractAddress}",
    ...options
  });
};
var getV1TransactionsByContractAddressBySignature = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/transactions/{contractAddress}/{signature}",
    ...options
  });
};
var getV1TokensTransfersTransactionByTransactionHash = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/tokens/transfers/transaction/{transaction_hash}",
    ...options
  });
};
var getV1TokensTransfersByContractAddress = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/tokens/transfers/{contract_address}",
    ...options
  });
};
var getV1TokensTransfers = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/tokens/transfers",
    ...options
  });
};
var getV1TokensErc20ByOwnerAddress = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/tokens/erc20/{ownerAddress}",
    ...options
  });
};
var getV1TokensErc721ByOwnerAddress = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/tokens/erc721/{ownerAddress}",
    ...options
  });
};
var getV1TokensErc1155ByOwnerAddress = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/tokens/erc1155/{ownerAddress}",
    ...options
  });
};
var getV1TokensPriceSupported = (options) => {
  return ((options == null ? void 0 : options.client) ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/tokens/price/supported",
    ...options
  });
};
var getV1TokensPrice = (options) => {
  return ((options == null ? void 0 : options.client) ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/tokens/price",
    ...options
  });
};
var getV1TokensLookup = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/tokens/lookup",
    ...options
  });
};
var getV1ResolveByInput = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/resolve/{input}",
    ...options
  });
};
var getV1Blocks = (options) => {
  return ((options == null ? void 0 : options.client) ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/blocks",
    ...options
  });
};
var getV1ContractsAbiByContractAddress = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/contracts/abi/{contractAddress}",
    ...options
  });
};
var getV1ContractsMetadataByContractAddress = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/contracts/metadata/{contractAddress}",
    ...options
  });
};
var postV1DecodeByContractAddress = (options) => {
  return (options.client ?? client).post({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/decode/{contractAddress}",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options == null ? void 0 : options.headers
    }
  });
};
var getV1NftsBalanceByOwnerAddress = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/nfts/balance/{ownerAddress}",
    ...options
  });
};
var getV1NftsCollectionsByContractAddress = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/nfts/collections/{contract_address}",
    ...options
  });
};
var getV1Nfts = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/nfts",
    ...options
  });
};
var getV1NftsOwnersByContractAddress = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/nfts/owners/{contract_address}",
    ...options
  });
};
var getV1NftsOwnersByContractAddressByTokenId = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/nfts/owners/{contract_address}/{token_id}",
    ...options
  });
};
var getV1NftsTransfers = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/nfts/transfers",
    ...options
  });
};
var getV1NftsTransfersTransactionByTransactionHash = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/nfts/transfers/transaction/{transaction_hash}",
    ...options
  });
};
var getV1NftsTransfersByContractAddress = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/nfts/transfers/{contract_address}",
    ...options
  });
};
var getV1NftsByContractAddress = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/nfts/{contract_address}",
    ...options
  });
};
var getV1NftsTransfersByContractAddressByTokenId = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/nfts/transfers/{contract_address}/{token_id}",
    ...options
  });
};
var getV1NftsByContractAddressByTokenId = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/nfts/{contract_address}/{token_id}",
    ...options
  });
};
var getV1NftsMetadataRefreshByContractAddress = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/nfts/metadata/refresh/{contract_address}",
    ...options
  });
};
var getV1NftsMetadataRefreshByContractAddressByTokenId = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/nfts/metadata/refresh/{contract_address}/{token_id}",
    ...options
  });
};
var getV1WalletsByWalletAddressTransactions = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "x-client-id",
        type: "apiKey"
      },
      {
        scheme: "bearer",
        type: "http"
      },
      {
        in: "query",
        name: "clientId",
        type: "apiKey"
      }
    ],
    url: "/v1/wallets/{wallet_address}/transactions",
    ...options
  });
};

// node_modules/@thirdweb-dev/insight/dist/esm/configure.js
function configure(options) {
  client.setConfig({
    headers: {
      ...options.clientId && { "x-client-id": options.clientId },
      ...options.secretKey && { "x-api-key": options.secretKey }
    },
    ...options.override ?? {}
  });
}
export {
  configure,
  deleteV1WebhooksByWebhookId,
  getV1Blocks,
  getV1ContractsAbiByContractAddress,
  getV1ContractsMetadataByContractAddress,
  getV1Events,
  getV1EventsByContractAddress,
  getV1EventsByContractAddressBySignature,
  getV1Nfts,
  getV1NftsBalanceByOwnerAddress,
  getV1NftsByContractAddress,
  getV1NftsByContractAddressByTokenId,
  getV1NftsCollectionsByContractAddress,
  getV1NftsMetadataRefreshByContractAddress,
  getV1NftsMetadataRefreshByContractAddressByTokenId,
  getV1NftsOwnersByContractAddress,
  getV1NftsOwnersByContractAddressByTokenId,
  getV1NftsTransfers,
  getV1NftsTransfersByContractAddress,
  getV1NftsTransfersByContractAddressByTokenId,
  getV1NftsTransfersTransactionByTransactionHash,
  getV1ResolveByInput,
  getV1TokensErc1155ByOwnerAddress,
  getV1TokensErc20ByOwnerAddress,
  getV1TokensErc721ByOwnerAddress,
  getV1TokensLookup,
  getV1TokensPrice,
  getV1TokensPriceSupported,
  getV1TokensTransfers,
  getV1TokensTransfersByContractAddress,
  getV1TokensTransfersTransactionByTransactionHash,
  getV1Transactions,
  getV1TransactionsByContractAddress,
  getV1TransactionsByContractAddressBySignature,
  getV1WalletsByWalletAddressTransactions,
  getV1Webhooks,
  patchV1WebhooksByWebhookId,
  postV1DecodeByContractAddress,
  postV1Webhooks,
  postV1WebhooksByWebhookIdResendOtp,
  postV1WebhooksByWebhookIdVerify,
  postV1WebhooksTest
};
//# sourceMappingURL=thirdweb-H4NMUC6M.js.map
