import {
  download
} from "./chunk-3TGJ2UPP.js";
import {
  formatBlock
} from "./chunk-QEOWYB53.js";
import {
  decodeErrorResult,
  formatTransactionRequest,
  stringify
} from "./chunk-U373M5NZ.js";
import {
  getRpcClient
} from "./chunk-G525EIYN.js";
import {
  toUnits
} from "./chunk-HAADYJEF.js";
import {
  formatAbi,
  parseAbi
} from "./chunk-HXWRQBIO.js";
import {
  getContract
} from "./chunk-OC3SQ5HK.js";
import {
  getAddress
} from "./chunk-3VPP7LG4.js";
import {
  hexToBigInt,
  isHex,
  numberToHex
} from "./chunk-7OW24QWY.js";
import {
  fromNumber2 as fromNumber
} from "./chunk-O2PTR6DB.js";
import {
  withCache
} from "./chunk-MTFDOOBS.js";
import {
  IS_DEV,
  getClientFetch
} from "./chunk-Q3BUNRF4.js";

// node_modules/thirdweb/dist/esm/rpc/actions/eth_gasPrice.js
async function eth_gasPrice(request) {
  const result = await request({
    method: "eth_gasPrice"
  });
  return hexToBigInt(result);
}

// node_modules/thirdweb/dist/esm/gas/get-gas-price.js
async function getGasPrice(options) {
  const { client, chain, percentMultiplier } = options;
  const rpcClient = getRpcClient({ client, chain });
  const gasPrice_ = await eth_gasPrice(rpcClient);
  const extraTip = percentMultiplier ? gasPrice_ / BigInt(100) * BigInt(percentMultiplier) : 0n;
  const txGasPrice = gasPrice_ + extraTip;
  return txGasPrice;
}

// node_modules/thirdweb/dist/esm/rpc/actions/eth_getBlockByNumber.js
async function eth_getBlockByNumber(request, params) {
  const blockTag = params.blockTag ?? "latest";
  const includeTransactions = params.includeTransactions ?? false;
  const blockNumberHex = params.blockNumber !== void 0 ? numberToHex(params.blockNumber) : void 0;
  const block = await request({
    method: "eth_getBlockByNumber",
    params: [blockNumberHex || blockTag, includeTransactions]
  });
  if (!block) {
    throw new Error("Block not found");
  }
  return formatBlock(block);
}

// node_modules/thirdweb/dist/esm/rpc/actions/eth_maxPriorityFeePerGas.js
async function eth_maxPriorityFeePerGas(request) {
  const result = await request({
    method: "eth_maxPriorityFeePerGas"
  });
  return hexToBigInt(result);
}

// node_modules/thirdweb/dist/esm/utils/promise/resolve-promised-value.js
async function resolvePromisedValue(value) {
  return typeof value === "function" ? await value() : value;
}

// node_modules/thirdweb/dist/esm/gas/op-gas-fee-reducer.js
function roundUpGas(value) {
  if (value === 0n || (value & value - 1n) === 0n) {
    return value;
  }
  let highestBit = 1n;
  while (value > 0n) {
    value >>= 1n;
    highestBit <<= 1n;
  }
  return highestBit;
}

// node_modules/thirdweb/dist/esm/contract/actions/resolve-abi.js
function resolveContractAbi(contract, contractApiBaseUrl = "https://contract.thirdweb.com/abi") {
  return withCache(async () => {
    if (contract.abi) {
      return contract.abi;
    }
    if (contract.chain.id === 31337 || contract.chain.id === 1337) {
      return await resolveCompositeAbi(contract);
    }
    try {
      return await resolveAbiFromContractApi(contract, contractApiBaseUrl);
    } catch {
      return await resolveCompositeAbi(contract);
    }
  }, {
    cacheKey: `${contract.chain.id}-${contract.address}`,
    cacheTime: 1e3 * 60 * 60 * 1
    // 1 hour
  });
}
async function resolveAbiFromContractApi(contract, contractApiBaseUrl = "https://contract.thirdweb.com/abi") {
  const response = await getClientFetch(contract.client)(`${contractApiBaseUrl}/${contract.chain.id}/${contract.address}`);
  const json = await response.json();
  if (!json || json.error) {
    throw new Error(`Failed to resolve ABI from contract API. ${json.error || ""}`);
  }
  return json;
}
async function resolveAbiFromBytecode(contract) {
  const [{ resolveImplementation }, { extractIPFSUri }] = await Promise.all([
    import("./resolveImplementation-6BZ3FTOS.js"),
    import("./extractIPFS-6BFQ6MEB.js")
  ]);
  const { bytecode } = await resolveImplementation(contract);
  if (bytecode === "0x") {
    const { id, name } = contract.chain;
    throw new Error(`Failed to load contract bytecode. Make sure the contract [${contract.address}] exists on the chain [${name || "Unknown Chain"} (chain id: ${id})]`);
  }
  const ipfsUri = extractIPFSUri(bytecode);
  if (!ipfsUri) {
    return [];
  }
  try {
    const res = await download({ uri: ipfsUri, client: contract.client });
    const json = await res.json();
    return json.output.abi;
  } catch {
    return [];
  }
}
var PLUGINS_ABI = {
  inputs: [],
  name: "getAllPlugins",
  outputs: [
    {
      components: [
        {
          internalType: "bytes4",
          name: "functionSelector",
          type: "bytes4"
        },
        {
          internalType: "string",
          name: "functionSignature",
          type: "string"
        },
        {
          internalType: "address",
          name: "pluginAddress",
          type: "address"
        }
      ],
      internalType: "struct IPluginMap.Plugin[]",
      name: "registered",
      type: "tuple[]"
    }
  ],
  stateMutability: "view",
  type: "function"
};
var BASE_ROUTER_ABI = {
  inputs: [],
  name: "getAllExtensions",
  outputs: [
    {
      components: [
        {
          components: [
            {
              internalType: "string",
              name: "name",
              type: "string"
            },
            {
              internalType: "string",
              name: "metadataURI",
              type: "string"
            },
            {
              internalType: "address",
              name: "implementation",
              type: "address"
            }
          ],
          internalType: "struct IExtension.ExtensionMetadata",
          name: "metadata",
          type: "tuple"
        },
        {
          components: [
            {
              internalType: "bytes4",
              name: "functionSelector",
              type: "bytes4"
            },
            {
              internalType: "string",
              name: "functionSignature",
              type: "string"
            }
          ],
          internalType: "struct IExtension.ExtensionFunction[]",
          name: "functions",
          type: "tuple[]"
        }
      ],
      internalType: "struct IExtension.Extension[]",
      name: "allExtensions",
      type: "tuple[]"
    }
  ],
  stateMutability: "view",
  type: "function"
};
var DIAMOND_ABI = {
  inputs: [],
  name: "facets",
  outputs: [
    {
      components: [
        {
          internalType: "address",
          name: "facetAddress",
          type: "address"
        },
        {
          internalType: "bytes4[]",
          name: "functionSelectors",
          type: "bytes4[]"
        }
      ],
      type: "tuple[]"
    }
  ],
  stateMutability: "view",
  type: "function"
};
async function resolveCompositeAbi(contract, rootAbi, resolveSubAbi) {
  const [rootAbi_, pluginPatternAddresses, baseRouterAddresses, modularExtensionAddresses, diamondFacetAddresses] = await Promise.all([
    rootAbi ? rootAbi : resolveAbiFromBytecode(contract),
    // check these all at the same time
    resolvePluginPatternAddresses(contract),
    resolveBaseRouterAddresses(contract),
    resolveModularModuleAddresses(contract),
    resolveDiamondFacetAddresses(contract)
  ]);
  const mergedPlugins = [
    .../* @__PURE__ */ new Set([
      ...pluginPatternAddresses,
      ...baseRouterAddresses,
      ...modularExtensionAddresses,
      ...diamondFacetAddresses
    ])
  ];
  if (!mergedPlugins.length) {
    return rootAbi_;
  }
  const pluginAbis = await getAbisForPlugins({
    contract,
    plugins: mergedPlugins,
    resolveSubAbi
  });
  return joinAbis({ rootAbi: rootAbi_, pluginAbis });
}
async function resolvePluginPatternAddresses(contract) {
  try {
    const { readContract } = await import("./read-contract-364PICXB.js");
    const pluginMap = await readContract({
      contract,
      method: PLUGINS_ABI
    });
    if (!pluginMap.length) {
      return [];
    }
    return [...new Set(pluginMap.map((item) => item.pluginAddress))];
  } catch {
  }
  return [];
}
async function resolveBaseRouterAddresses(contract) {
  try {
    const { readContract } = await import("./read-contract-364PICXB.js");
    const pluginMap = await readContract({
      contract,
      method: BASE_ROUTER_ABI
    });
    if (!pluginMap.length) {
      return [];
    }
    return [...new Set(pluginMap.map((item) => item.metadata.implementation))];
  } catch {
  }
  return [];
}
async function resolveModularModuleAddresses(contract) {
  try {
    const { getInstalledModules } = await import("./getInstalledModules-E5GJE5BR.js");
    const modules = await getInstalledModules({ contract });
    if (!modules.length) {
      return [];
    }
    return [...new Set(modules.map((item) => item.implementation))];
  } catch {
  }
  return [];
}
async function resolveDiamondFacetAddresses(contract) {
  try {
    const { readContract } = await import("./read-contract-364PICXB.js");
    const facets = await readContract({ contract, method: DIAMOND_ABI });
    if (!facets.length) {
      return [];
    }
    return facets.map((item) => item.facetAddress);
  } catch {
  }
  return [];
}
async function getAbisForPlugins(options) {
  return Promise.all(options.plugins.map((pluginAddress) => {
    const newContract = getContract({
      ...options.contract,
      address: pluginAddress
    });
    if (options.resolveSubAbi) {
      return options.resolveSubAbi(newContract);
    }
    return resolveAbiFromBytecode(newContract);
  }));
}
function joinAbis(options) {
  let mergedPlugins = options.pluginAbis.flat().filter((item) => item.type !== "constructor");
  if (options.rootAbi) {
    mergedPlugins = [...options.rootAbi, ...mergedPlugins].filter((item) => item.type !== "fallback" && item.type !== "receive").filter(Boolean);
  }
  const humanReadableAbi = [...new Set(formatAbi(mergedPlugins))];
  return parseAbi(humanReadableAbi);
}

// node_modules/thirdweb/dist/esm/transaction/extract-error.js
async function extractError(args) {
  const { error, contract } = args;
  const result = await extractErrorResult({ error, contract });
  if (result) {
    return new TransactionError(result, contract);
  }
  return error;
}
async function extractErrorResult(args) {
  const { error, contract } = args;
  if (typeof error === "object") {
    const errorObj = error;
    if (errorObj.data) {
      if (errorObj.data !== "0x" && isHex(errorObj.data)) {
        let abi = contract == null ? void 0 : contract.abi;
        if (contract && !abi) {
          abi = await resolveContractAbi(contract).catch(() => void 0);
        }
        const parsedError = decodeErrorResult({
          data: errorObj.data,
          abi
        });
        return `${parsedError.errorName}${parsedError.args ? ` - ${parsedError.args}` : ""}`;
      }
    }
  }
  return `Execution Reverted: ${stringify(error)}`;
}
var TransactionError = class extends Error {
  constructor(reason, contract) {
    var _a, _b;
    let message = reason;
    if (IS_DEV && contract) {
      message = [
        reason,
        "",
        `contract: ${contract.address}`,
        `chainId: ${(_a = contract.chain) == null ? void 0 : _a.id}`
      ].join("\n");
    }
    super(message);
    Object.defineProperty(this, "contractAddress", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "chainId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.name = "TransactionError";
    this.contractAddress = contract == null ? void 0 : contract.address;
    this.chainId = (_b = contract == null ? void 0 : contract.chain) == null ? void 0 : _b.id;
    this.message = message;
  }
};

// node_modules/thirdweb/dist/esm/transaction/actions/estimate-gas.js
var cache = /* @__PURE__ */ new WeakMap();
async function estimateGas(options) {
  var _a, _b;
  const fromAddress = typeof options.from === "string" ? options.from ?? void 0 : ((_a = options.from) == null ? void 0 : _a.address) ?? ((_b = options.account) == null ? void 0 : _b.address);
  const txWithFrom = { ...options.transaction, from: fromAddress };
  if (cache.has(txWithFrom)) {
    return cache.get(txWithFrom);
  }
  const { account } = options;
  const promise = (async () => {
    var _a2, _b2;
    const predefinedGas = await resolvePromisedValue(options.transaction.gas);
    if (predefinedGas !== void 0) {
      return predefinedGas;
    }
    if (account == null ? void 0 : account.estimateGas) {
      try {
        let gas = await account.estimateGas(options.transaction);
        if ((_a2 = options.transaction.chain.experimental) == null ? void 0 : _a2.increaseZeroByteCount) {
          gas = roundUpGas(gas);
        }
        return gas;
      } catch (error) {
        throw await extractError({
          error,
          contract: options.transaction.__contract
        });
      }
    }
    const { encode } = await import("./encode-JO7PFLMT.js");
    const [encodedData, toAddress, value, authorizationList] = await Promise.all([
      encode(options.transaction),
      resolvePromisedValue(options.transaction.to),
      resolvePromisedValue(options.transaction.value),
      resolvePromisedValue(options.transaction.authorizationList)
    ]);
    const [{ getRpcClient: getRpcClient2 }, { eth_estimateGas }] = await Promise.all([
      import("./rpc-F3LXGYUR.js"),
      import("./eth_estimateGas-WK3OXHTE.js")
    ]);
    const rpcRequest = getRpcClient2(options.transaction);
    try {
      let gas = await eth_estimateGas(rpcRequest, formatTransactionRequest({
        to: toAddress ? getAddress(toAddress) : void 0,
        data: encodedData,
        from: fromAddress ? getAddress(fromAddress) : void 0,
        value,
        // TODO: Remove this casting when we migrate this file to Ox
        authorizationList: authorizationList == null ? void 0 : authorizationList.map((auth) => ({
          ...auth,
          r: fromNumber(auth.r),
          s: fromNumber(auth.s),
          nonce: Number(auth.nonce),
          contractAddress: getAddress(auth.address)
        }))
      }));
      if ((_b2 = options.transaction.chain.experimental) == null ? void 0 : _b2.increaseZeroByteCount) {
        gas = roundUpGas(gas);
      }
      return gas;
    } catch (error) {
      throw await extractError({
        error,
        contract: options.transaction.__contract
      });
    }
  })();
  cache.set(txWithFrom, promise);
  return promise;
}

// node_modules/thirdweb/dist/esm/gas/fee-data.js
var FORCE_GAS_PRICE_CHAIN_IDS = [
  78600,
  // Vanar testnet
  2040,
  // Vanar mainnet
  248,
  // Oasys Mainnet
  9372,
  // Oasys Testnet
  841,
  // Taraxa Mainnet
  842,
  // Taraxa Testnet
  2016,
  // MainnetZ Mainnet
  9768,
  // MainnetZ Testnet
  2442,
  // Polygon zkEVM Cardona Testnet
  1942999413,
  // Humanity Testnet
  1952959480,
  // Lumia Testnet
  994873017,
  // Lumia Mainnet
  19011,
  // Homeverse Mainnet
  40875,
  // Homeverse Testnet
  1511670449,
  // GPT Mainnet
  5464
  // Saga Mainnet
];
async function getGasOverridesForTransaction(transaction) {
  var _a;
  const [maxFeePerGas, maxPriorityFeePerGas, gasPrice, type] = await Promise.all([
    resolvePromisedValue(transaction.maxFeePerGas),
    resolvePromisedValue(transaction.maxPriorityFeePerGas),
    resolvePromisedValue(transaction.gasPrice),
    resolvePromisedValue(transaction.type)
  ]);
  if (maxFeePerGas !== void 0 && maxPriorityFeePerGas !== void 0) {
    return {
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  }
  if (typeof gasPrice === "bigint") {
    return { gasPrice };
  }
  const defaultGasOverrides = await getDefaultGasOverrides(transaction.client, transaction.chain, type === "legacy" ? "legacy" : "eip1559");
  if ((_a = transaction.chain.experimental) == null ? void 0 : _a.increaseZeroByteCount) {
    if (defaultGasOverrides.gasPrice) {
      return { gasPrice: roundUpGas(defaultGasOverrides.gasPrice) };
    }
    return {
      maxFeePerGas: maxFeePerGas ?? roundUpGas(defaultGasOverrides.maxFeePerGas ?? 0n),
      maxPriorityFeePerGas: maxPriorityFeePerGas ?? roundUpGas(defaultGasOverrides.maxPriorityFeePerGas ?? 0n)
    };
  }
  if (defaultGasOverrides.gasPrice !== void 0) {
    return defaultGasOverrides;
  }
  return {
    maxFeePerGas: maxFeePerGas ?? defaultGasOverrides.maxFeePerGas,
    maxPriorityFeePerGas: maxPriorityFeePerGas ?? defaultGasOverrides.maxPriorityFeePerGas
  };
}
async function getDefaultGasOverrides(client, chain, feeType) {
  const resolvedFeeType = feeType ?? chain.feeType;
  if (resolvedFeeType === "legacy" || FORCE_GAS_PRICE_CHAIN_IDS.includes(chain.id)) {
    return {
      gasPrice: await getGasPrice({ client, chain, percentMultiplier: 10 })
    };
  }
  const feeData = await getDynamicFeeData(client, chain);
  if (feeData.maxFeePerGas !== null && feeData.maxPriorityFeePerGas !== null) {
    return {
      maxFeePerGas: feeData.maxFeePerGas,
      maxPriorityFeePerGas: feeData.maxPriorityFeePerGas
    };
  }
  return {
    gasPrice: await getGasPrice({ client, chain, percentMultiplier: 10 })
  };
}
async function getDynamicFeeData(client, chain, percentMultiplier = 10) {
  let maxFeePerGas = null;
  let maxPriorityFeePerGas_ = null;
  const rpcRequest = getRpcClient({ client, chain });
  const [block, maxPriorityFeePerGas] = await Promise.all([
    eth_getBlockByNumber(rpcRequest, { blockTag: "latest" }),
    eth_maxPriorityFeePerGas(rpcRequest).catch(() => null)
  ]);
  const baseBlockFee = block == null ? void 0 : block.baseFeePerGas;
  const chainId = chain.id;
  if (chainId === 220 || chainId === 1220) {
    return { maxFeePerGas: null, maxPriorityFeePerGas: null };
  }
  if (chainId === 80002 || chainId === 137) {
    maxPriorityFeePerGas_ = await getPolygonGasPriorityFee(chainId);
  } else if (maxPriorityFeePerGas !== null) {
    maxPriorityFeePerGas_ = maxPriorityFeePerGas;
  }
  if (maxPriorityFeePerGas_ == null || baseBlockFee == null) {
    return { maxFeePerGas: null, maxPriorityFeePerGas: null };
  }
  maxPriorityFeePerGas_ = getPreferredPriorityFee(maxPriorityFeePerGas_, percentMultiplier);
  maxFeePerGas = baseBlockFee * 2n + maxPriorityFeePerGas_;
  if (chainId === 42220 || chainId === 44787 || chainId === 62320) {
    maxPriorityFeePerGas_ = maxFeePerGas;
  }
  return {
    maxFeePerGas,
    maxPriorityFeePerGas: maxPriorityFeePerGas_
  };
}
function getPreferredPriorityFee(defaultPriorityFeePerGas, percentMultiplier = 10) {
  const extraTip = defaultPriorityFeePerGas / BigInt(100) * BigInt(percentMultiplier);
  const totalPriorityFee = defaultPriorityFeePerGas + extraTip;
  return totalPriorityFee;
}
function getGasStationUrl(chainId) {
  switch (chainId) {
    case 137:
      return "https://gasstation.polygon.technology/v2";
    case 80002:
      return "https://gasstation-testnet.polygon.technology/v2";
  }
}
var MIN_POLYGON_GAS_PRICE = 31n;
async function getPolygonGasPriorityFee(chainId) {
  const gasStationUrl = getGasStationUrl(chainId);
  try {
    const data = await (await fetch(gasStationUrl)).json();
    const priorityFee = data.fast.maxPriorityFee;
    if (priorityFee > 0) {
      const fixedFee = Number.parseFloat(priorityFee).toFixed(9);
      return toUnits(fixedFee, 9);
    }
  } catch (e) {
    console.error("failed to fetch gas", e);
  }
  return MIN_POLYGON_GAS_PRICE;
}

export {
  eth_gasPrice,
  getGasPrice,
  eth_getBlockByNumber,
  eth_maxPriorityFeePerGas,
  resolvePromisedValue,
  getGasOverridesForTransaction,
  getDefaultGasOverrides,
  resolveContractAbi,
  extractError,
  estimateGas
};
//# sourceMappingURL=chunk-AQF7QQD3.js.map
