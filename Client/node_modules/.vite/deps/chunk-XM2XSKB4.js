import {
  getContract
} from "./chunk-OC3SQ5HK.js";
import {
  getAddress
} from "./chunk-3VPP7LG4.js";
import {
  getCachedChain
} from "./chunk-6OSAHK2J.js";

// node_modules/thirdweb/dist/esm/insight/get-nfts.js
async function getOwnedNFTs(args) {
  var _a;
  const [{ getV1Nfts }, { getThirdwebDomains }, { getClientFetch }, { assertInsightEnabled }, { stringify }] = await Promise.all([
    import("./thirdweb-H4NMUC6M.js"),
    import("./domains-UQIPWRLC.js"),
    import("./fetch-TANTDEBC.js"),
    import("./common-XEVMJO7U.js"),
    import("./_esm-E77KJ75G.js")
  ]);
  const { client, chains, ownerAddress, queryOptions } = args;
  await assertInsightEnabled(chains);
  const defaultQueryOptions = {
    chain: chains.map((chain) => chain.id),
    // metadata: includeMetadata ? "true" : "false", TODO (insight): add support for this
    limit: 50,
    owner_address: ownerAddress
  };
  const result = await getV1Nfts({
    baseUrl: `https://${getThirdwebDomains().insight}`,
    fetch: getClientFetch(client),
    query: {
      ...defaultQueryOptions,
      ...queryOptions
    }
  });
  if (result.error) {
    throw new Error(`${result.response.status} ${result.response.statusText} - ${result.error ? stringify(result.error) : "Unknown error"}`);
  }
  const transformedNfts = await transformNFTModel(((_a = result.data) == null ? void 0 : _a.data) ?? [], client, ownerAddress);
  return transformedNfts.map((nft) => ({
    ...nft,
    quantityOwned: nft.quantityOwned ?? 1n
  }));
}
async function getContractNFTs(args) {
  var _a;
  const [{ getV1NftsByContractAddress }, { getThirdwebDomains }, { getClientFetch }, { assertInsightEnabled }, { stringify }] = await Promise.all([
    import("./thirdweb-H4NMUC6M.js"),
    import("./domains-UQIPWRLC.js"),
    import("./fetch-TANTDEBC.js"),
    import("./common-XEVMJO7U.js"),
    import("./json-TMY4LLIG.js")
  ]);
  const { client, chains, contractAddress, includeOwners = true, queryOptions } = args;
  const defaultQueryOptions = {
    chain: chains.map((chain) => chain.id),
    // metadata: includeMetadata ? "true" : "false", TODO (insight): add support for this
    limit: 50,
    include_owners: includeOwners === true ? "true" : "false"
  };
  await assertInsightEnabled(chains);
  const result = await getV1NftsByContractAddress({
    baseUrl: `https://${getThirdwebDomains().insight}`,
    fetch: getClientFetch(client),
    path: {
      contract_address: contractAddress
    },
    query: {
      ...defaultQueryOptions,
      ...queryOptions
    }
  });
  if (result.error) {
    throw new Error(`${result.response.status} ${result.response.statusText} - ${result.error ? stringify(result.error) : "Unknown error"}`);
  }
  return transformNFTModel(((_a = result.data) == null ? void 0 : _a.data) ?? [], client);
}
async function getNFT(args) {
  var _a;
  const [{ getV1NftsByContractAddressByTokenId }, { getThirdwebDomains }, { getClientFetch }, { assertInsightEnabled }, { stringify }] = await Promise.all([
    import("./thirdweb-H4NMUC6M.js"),
    import("./domains-UQIPWRLC.js"),
    import("./fetch-TANTDEBC.js"),
    import("./common-XEVMJO7U.js"),
    import("./json-TMY4LLIG.js")
  ]);
  const { client, chain, contractAddress, tokenId, includeOwners = true, queryOptions } = args;
  await assertInsightEnabled([chain]);
  const defaultQueryOptions = {
    chain: chain.id,
    include_owners: includeOwners === true ? "true" : "false"
  };
  const result = await getV1NftsByContractAddressByTokenId({
    baseUrl: `https://${getThirdwebDomains().insight}`,
    fetch: getClientFetch(client),
    path: {
      contract_address: contractAddress,
      token_id: tokenId.toString()
    },
    query: {
      ...defaultQueryOptions,
      ...queryOptions
    }
  });
  if (result.error) {
    throw new Error(`${result.response.status} ${result.response.statusText} - ${result.error ? stringify(result.error) : "Unknown error"}`);
  }
  const transformedNfts = await transformNFTModel(((_a = result.data) == null ? void 0 : _a.data) ?? [], client);
  return transformedNfts == null ? void 0 : transformedNfts[0];
}
async function transformNFTModel(nfts, client, ownerAddress) {
  const [{ parseNFT }, { totalSupply }] = await Promise.all([
    import("./parseNft-DRXSM77F.js"),
    import("./totalSupply-VMSLUHGR.js")
  ]);
  return await Promise.all(nfts.map(async (nft) => {
    var _a;
    let parsedNft;
    const { contract, extra_metadata, collection, metadata_url, chain_id, token_id, status, balance, token_type, ...rest } = nft;
    let metadataToUse = rest;
    let owners = ownerAddress ? [getAddress(ownerAddress)] : void 0;
    if ("owner_addresses" in rest) {
      const { owner_addresses, ...restWithoutOwnerAddresses } = rest;
      metadataToUse = restWithoutOwnerAddresses;
      owners = owners ?? (owner_addresses == null ? void 0 : owner_addresses.map((o) => getAddress(o)));
    }
    const metadata = replaceIPFSGatewayRecursively({
      uri: nft.metadata_url ?? "",
      image: nft.image_url,
      attributes: ((_a = nft.extra_metadata) == null ? void 0 : _a.attributes) ?? void 0,
      ...metadataToUse
    });
    if ((contract == null ? void 0 : contract.type) === "erc1155") {
      const supply = await totalSupply({
        contract: getContract({
          address: contract.address,
          chain: getCachedChain(contract.chain_id),
          client
        }),
        id: BigInt(token_id)
      }).catch(() => 0n);
      parsedNft = parseNFT(metadata, {
        tokenId: BigInt(token_id),
        tokenUri: replaceIPFSGateway(metadata_url) ?? "",
        type: "ERC1155",
        owner: owners == null ? void 0 : owners[0],
        tokenAddress: (contract == null ? void 0 : contract.address) ?? "",
        chainId: (contract == null ? void 0 : contract.chain_id) ?? 0,
        supply
      });
    } else {
      parsedNft = parseNFT(metadata, {
        tokenId: BigInt(token_id),
        type: "ERC721",
        owner: owners == null ? void 0 : owners[0],
        tokenUri: replaceIPFSGateway(metadata_url) ?? "",
        tokenAddress: (contract == null ? void 0 : contract.address) ?? "",
        chainId: (contract == null ? void 0 : contract.chain_id) ?? 0
      });
    }
    return parsedNft;
  }));
}
function replaceIPFSGatewayRecursively(obj) {
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }
  for (const key in obj) {
    if (typeof obj[key] === "string") {
      obj[key] = replaceIPFSGateway(obj[key]);
    } else {
      replaceIPFSGatewayRecursively(obj[key]);
    }
  }
  return obj;
}
function replaceIPFSGateway(url) {
  if (!url || typeof url !== "string") {
    return url;
  }
  try {
    const parsedUrl = new URL(url);
    if (parsedUrl.host.endsWith(".ipfscdn.io")) {
      const paths = parsedUrl.pathname.split("/");
      const index = paths.findIndex((path) => path === "ipfs");
      if (index === -1) {
        return url;
      }
      const ipfsHash = paths.slice(index + 1).join("/");
      if (ipfsHash) {
        return `ipfs://${ipfsHash}`;
      }
      return url;
    }
  } catch {
    return url;
  }
  return url;
}

export {
  getOwnedNFTs,
  getContractNFTs,
  getNFT
};
//# sourceMappingURL=chunk-XM2XSKB4.js.map
