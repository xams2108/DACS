{
  "version": 3,
  "sources": ["../../thirdweb/src/utils/hashing/sha256.ts", "../../thirdweb/src/utils/client-id.ts", "../../thirdweb/src/client/client.ts", "../../thirdweb/src/rpc/actions/eth_getBlockByHash.ts", "../../thirdweb/src/rpc/actions/eth_getTransactionByHash.ts", "../../thirdweb/src/bridge/index.ts", "../../thirdweb/src/bridge/Buy.ts", "../../thirdweb/src/bridge/constants.ts", "../../thirdweb/src/bridge/Sell.ts", "../../thirdweb/src/bridge/Status.ts", "../../thirdweb/src/bridge/Routes.ts", "../../thirdweb/src/transaction/resolve-method.ts", "../../thirdweb/src/auth/verify-typed-data.ts", "../../thirdweb/src/transaction/actions/eip7702/authorization.ts"],
  "sourcesContent": ["import { sha256 as noble_sha256 } from \"@noble/hashes/sha256\";\nimport {\n  type Hex,\n  hexToUint8Array,\n  isHex,\n  uint8ArrayToHex,\n} from \"../encoding/hex.js\";\n\ntype To = \"hex\" | \"bytes\";\n\ntype Sha256Hash<TTo extends To> =\n  | (TTo extends \"bytes\" ? Uint8Array : never)\n  | (TTo extends \"hex\" ? Hex : never);\n\n/**\n * Calculates the SHA256 hash of the given value.\n * @param value - The value to hash. It can be either a hexadecimal string or a Uint8Array.\n * @param to - (Optional) The desired output format of the hash. Defaults to 'hex'.\n * @returns The SHA256 hash of the value in the specified format.\n * @example\n * ```ts\n * import { sha256 } from \"thirdweb/utils\";\n * const hash = sha256(\"0x1234\");\n * ```\n * @utils\n */\nexport function sha256<TTo extends To = \"hex\">(\n  value: Hex | Uint8Array,\n  to?: TTo,\n): Sha256Hash<TTo> {\n  const bytes = noble_sha256(\n    isHex(value, { strict: false }) ? hexToUint8Array(value) : value,\n  );\n  if (to === \"bytes\") {\n    return bytes as Sha256Hash<TTo>;\n  }\n  return uint8ArrayToHex(bytes) as Sha256Hash<TTo>;\n}\n", "import { LruMap } from \"./caching/lru.js\";\nimport { stringToBytes } from \"./encoding/to-bytes.js\";\nimport { sha256 } from \"./hashing/sha256.js\";\n\nconst cache = new LruMap<string>(4096);\n\n/**\n * @param secretKey - the secret key to compute the client id from\n * @returns the 32 char hex client id\n * @internal\n */\nexport function computeClientIdFromSecretKey(secretKey: string): string {\n  if (cache.has(secretKey)) {\n    return cache.get(secretKey) as string;\n  }\n  // we slice off the leading `0x` and then take the first 32 chars\n  const cId = sha256(stringToBytes(secretKey)).slice(2, 34);\n  cache.set(secretKey, cId);\n  return cId;\n}\n", "import { computeClientIdFromSecretKey } from \"../utils/client-id.js\";\nimport { isJWT } from \"../utils/jwt/is-jwt.js\";\nimport type { Prettify } from \"../utils/type-utils.js\";\n\ntype FetchConfig = {\n  requestTimeoutMs?: number;\n  keepalive?: boolean;\n  headers?: HeadersInit;\n};\n\ntype ClientOptions = Prettify<{\n  /**\n   * The configuration options for the client.\n   */\n  config?: {\n    /**\n     * The configuration options for the RPC client.\n     */\n    rpc?: {\n      /**\n       * The configuration options for the fetch function.\n       * @default {}\n       */\n      fetch?: FetchConfig;\n      /**\n       * The maximum number of requests to batch together.\n       * @default 100\n       */\n      maxBatchSize?: number;\n      /**\n       * The maximum time to wait before sending a batch of requests.\n       * @default 0 (no timeout)\n       */\n      batchTimeoutMs?: number;\n    };\n    /**\n     * The configuration options for the storage client.\n     */\n    storage?: {\n      /**\n       * The configuration options for the fetch function.\n       * @default {}\n       */\n      fetch?: FetchConfig;\n      /**\n       * The IPFS gateway URL.\n       * @default \"https://<your_client_id>.ipfscdn.io/ipfs/<cid>\"\n       */\n      gatewayUrl?: string;\n    };\n  };\n\n  /**\n   * The team ID for thirdweb dashboard usage.\n   * @hidden\n   */\n  teamId?: string;\n}>;\n\nexport type CreateThirdwebClientOptions = Prettify<\n  (\n    | {\n        clientId: string;\n        secretKey?: string;\n      }\n    | {\n        clientId?: string;\n        secretKey: string;\n      }\n  ) &\n    ClientOptions\n>;\n\nexport type ThirdwebClient = {\n  readonly clientId: string;\n  readonly secretKey: string | undefined;\n} & Readonly<ClientOptions>;\n\n/**\n * Creates a Thirdweb client using the provided client ID (client-side) or secret key (server-side).\n *\n * Get your client ID and secret key from the Thirdweb dashboard [here](https://thirdweb.com/create-api-key).\n * **Never share your secret key with anyone.\n *\n * A client is necessary for most functions in the thirdweb SDK. It provides access to thirdweb APIs including built-in RPC, storage, and more.\n *\n * @param options - The options for creating the client.\n * @param [options.clientId] - The client ID to use for thirdweb services.\n * @param [options.secretKey] - The secret key to use for thirdweb services.\n * @returns The created Thirdweb client.\n * @throws An error if neither `clientId` nor `secretKey` is provided.\n *\n * @example\n * Create a client on the client side (client ID):\n * ```ts\n * import { createThirdwebClient } from \"thirdweb\";\n *\n * const client = createThirdwebClient({ clientId: \"...\" });\n * ```\n *\n * Create a client on the server (secret key):\n * ```ts\n * import { createThirdwebClient } from \"thirdweb\";\n *\n * const client = createThirdwebClient({ secretKey: \"...\" });\n * ```\n * @client\n */\nexport function createThirdwebClient(\n  options: CreateThirdwebClientOptions,\n): ThirdwebClient {\n  const { clientId, secretKey, ...rest } = options;\n\n  let realClientId: string | undefined = clientId;\n\n  if (secretKey) {\n    if (isJWT(secretKey)) {\n      // when passing a JWT as secret key we HAVE to also have a clientId\n      if (!clientId) {\n        throw new Error(\"clientId must be provided when using a JWT secretKey\");\n      }\n    } else {\n      // always PREFER the clientId if provided, only compute it from the secretKey if we don't have a clientId passed explicitly\n      realClientId = clientId ?? computeClientIdFromSecretKey(secretKey);\n    }\n  }\n\n  // only path we get here is if we have no secretKey and no clientId\n  if (!realClientId) {\n    throw new Error(\"clientId or secretKey must be provided\");\n  }\n\n  return {\n    ...rest,\n    clientId: realClientId,\n    secretKey,\n  } as const;\n}\n", "import {\n  type EIP1193RequestFn,\n  type EIP1474Methods,\n  type GetBlockReturnType,\n  type Hash,\n  formatBlock,\n} from \"viem\";\n\ntype GetBlockByHashParams<TIncludeTransactions extends boolean = false> = {\n  /** Whether or not to include transaction data in the response. */\n  includeTransactions?: TIncludeTransactions;\n} & {\n  /** Hash of the block. */\n  blockHash: Hash;\n};\n\n/**\n * Retrieves a block by its hash.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for the block retrieval.\n * @returns A promise that resolves to the retrieved block.\n * @throws An error if the block is not found.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_getBlockByHash } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const block = await eth_getBlockByHash(rpcRequest, {\n * blockHash: \"0x...\",\n * includeTransactions: true,\n * });\n * ```\n */\nexport async function eth_getBlockByHash<\n  TIncludeTransactions extends boolean = false,\n>(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: GetBlockByHashParams<TIncludeTransactions>,\n): Promise<GetBlockReturnType<undefined, TIncludeTransactions>> {\n  const includeTransactions = params.includeTransactions ?? false;\n\n  const block = await request({\n    method: \"eth_getBlockByHash\",\n    params: [params.blockHash, includeTransactions],\n  });\n  if (!block) {\n    throw new Error(\"Block not found\");\n  }\n  return formatBlock(block) as GetBlockReturnType<\n    undefined,\n    TIncludeTransactions\n  >;\n}\n", "import {\n  type EIP1193RequestFn,\n  type EIP1474Methods,\n  type Hash,\n  type Transaction,\n  formatTransaction,\n} from \"viem\";\n\ntype GetTransactionByHashParameters = {\n  hash: Hash;\n};\n\n/**\n * Retrieves a transaction by its hash.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for retrieving the transaction.\n * @returns A promise that resolves to the transaction.\n * @throws An error if the transaction is not found.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_getTransactionByHash } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n *  const transaction = await eth_getTransactionByHash(rpcRequest, {\n *  hash: \"0x...\",\n * });\n * ```\n */\nexport async function eth_getTransactionByHash(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: GetTransactionByHashParameters,\n): Promise<Transaction> {\n  const receipt = await request({\n    method: \"eth_getTransactionByHash\",\n    params: [params.hash],\n  });\n\n  if (!receipt) {\n    throw new Error(\"Transaction not found.\");\n  }\n\n  return formatTransaction(receipt);\n}\n", "export * as Buy from \"./Buy.js\";\nexport * as Sell from \"./Sell.js\";\nexport { status } from \"./Status.js\";\nexport { routes } from \"./Routes.js\";\n\nexport type { Status } from \"./types/Status.js\";\nexport type { Route } from \"./types/Route.js\";\nexport type { Quote, PreparedQuote } from \"./types/Quote.js\";\n", "import type { Address as ox__Address } from \"ox\";\nimport { defineChain } from \"../chains/utils.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { getClientFetch } from \"../utils/fetch.js\";\nimport { UNIVERSAL_BRIDGE_URL } from \"./constants.js\";\nimport type { PreparedQuote, Quote } from \"./types/Quote.js\";\n\n/**\n * Retrieves a Universal Bridge quote for the provided buy intent. The quote will specify the necessary `originAmount` to receive the desired `destinationAmount`, which is specified with the `buyAmountWei` option.\n *\n * @example\n * ```typescript\n * import { Bridge, NATIVE_TOKEN_ADDRESS } from \"thirdweb\";\n *\n * const quote = await Bridge.Buy.quote({\n *   originChainId: 1,\n *   originTokenAddress: NATIVE_TOKEN_ADDRESS,\n *   destinationChainId: 10,\n *   destinationTokenAddress: NATIVE_TOKEN_ADDRESS,\n *   amount: toWei(\"0.01\"),\n *   client: thirdwebClient,\n * });\n * ```\n *\n * This will return a quote that might look like:\n * ```typescript\n * {\n *   originAmount: 10000026098875381n,\n *   destinationAmount: 1000000000000000000n,\n *   blockNumber: 22026509n,\n *   timestamp: 1741730936680,\n *   estimatedExecutionTimeMs: 1000\n *   steps: [\n *     {\n *       originToken: {\n *         chainId: 1,\n *         address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *         symbol: \"ETH\",\n *         name: \"Ethereum\",\n *         decimals: 18,\n *         priceUsd: 0.0025,\n *         iconUri: \"https://...\"\n *       },\n *       destinationToken: {\n *         chainId: 10,\n *         address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *         symbol: \"ETH\",\n *         name: \"Ethereum\",\n *         decimals: 18,\n *         priceUsd: 0.0025,\n *         iconUri: \"https://...\"\n *       },\n *       originAmount: 10000026098875381n,\n *       destinationAmount: 1000000000000000000n,\n *       estimatedExecutionTimeMs: 1000\n *     }\n *   ],\n *   intent: {\n *     originChainId: 1,\n *     originTokenAddress: NATIVE_TOKEN_ADDRESS,\n *     destinationChainId: 10,\n *     destinationTokenAddress: NATIVE_TOKEN_ADDRESS,\n *     amount: 1000000000000000000n\n *   }\n * }\n * ```\n *\n * The quote is an **estimate** for how much you would expect to pay for a specific buy. This quote is not guaranteed and you should use `Buy.prepare` to get a finalized quote with transaction data ready for execution.\n * So why use `quote`? The quote function is sometimes slightly faster than `prepare`, and can be used before the user connects their wallet.\n *\n * You can access this functions input and output types with `Buy.quote.Options` and `Buy.quote.Result`, respectively.\n *\n * @param options - The options for the quote.\n * @param options.originChainId - The chain ID of the origin token.\n * @param options.originTokenAddress - The address of the origin token.\n * @param options.destinationChainId - The chain ID of the destination token.\n * @param options.destinationTokenAddress - The address of the destination token.\n * @param options.amount - The amount of the destination token to receive.\n * @param options.client - Your thirdweb client.\n *\n * @returns A promise that resolves to a non-finalized quote for the requested buy.\n *\n * @throws Will throw an error if there is an issue fetching the quote.\n * @bridge Buy\n * @beta\n */\nexport async function quote(options: quote.Options): Promise<quote.Result> {\n  const {\n    originChainId,\n    originTokenAddress,\n    destinationChainId,\n    destinationTokenAddress,\n    client,\n  } = options;\n  const amount =\n    \"buyAmountWei\" in options ? options.buyAmountWei : options.amount;\n\n  const clientFetch = getClientFetch(client);\n  const url = new URL(`${UNIVERSAL_BRIDGE_URL}/buy/quote`);\n  url.searchParams.set(\"originChainId\", originChainId.toString());\n  url.searchParams.set(\"originTokenAddress\", originTokenAddress);\n  url.searchParams.set(\"destinationChainId\", destinationChainId.toString());\n  url.searchParams.set(\"destinationTokenAddress\", destinationTokenAddress);\n  url.searchParams.set(\"buyAmountWei\", amount.toString());\n\n  const response = await clientFetch(url.toString());\n  if (!response.ok) {\n    const errorJson = await response.json();\n    throw new Error(\n      `${errorJson.code} | ${errorJson.message} - ${errorJson.correlationId}`,\n    );\n  }\n\n  const { data }: { data: Quote } = await response.json();\n  return {\n    originAmount: BigInt(data.originAmount),\n    destinationAmount: BigInt(data.destinationAmount),\n    blockNumber: data.blockNumber ? BigInt(data.blockNumber) : undefined,\n    timestamp: data.timestamp,\n    estimatedExecutionTimeMs: data.estimatedExecutionTimeMs,\n    steps: data.steps,\n    intent: {\n      originChainId,\n      originTokenAddress,\n      destinationChainId,\n      destinationTokenAddress,\n      buyAmountWei: amount,\n      amount,\n    },\n  };\n}\n\nexport declare namespace quote {\n  type Options = {\n    originChainId: number;\n    originTokenAddress: ox__Address.Address;\n    destinationChainId: number;\n    destinationTokenAddress: ox__Address.Address;\n    client: ThirdwebClient;\n  } & (\n    | {\n        buyAmountWei: bigint;\n      }\n    | {\n        amount: bigint;\n      }\n  );\n\n  type Result = Quote & {\n    intent: {\n      originChainId: number;\n      originTokenAddress: ox__Address.Address;\n      destinationChainId: number;\n      destinationTokenAddress: ox__Address.Address;\n      buyAmountWei: bigint;\n      amount: bigint;\n    };\n  };\n}\n\n/**\n * Prepares a **finalized** Universal Bridge quote for the provided buy request with transaction data. This function will return everything `quote` does, with the addition of a series of prepared transactions and the associated expiration timestamp.\n *\n * @example\n * ```typescript\n * import { Bridge, NATIVE_TOKEN_ADDRESS } from \"thirdweb\";\n *\n * const quote = await Bridge.Buy.prepare({\n *   originChainId: 1,\n *   originTokenAddress: NATIVE_TOKEN_ADDRESS,\n *   destinationChainId: 10,\n *   destinationTokenAddress: NATIVE_TOKEN_ADDRESS,\n *   amount: toWei(\"0.01\"),\n *   client: thirdwebClient,\n * });\n * ```\n *\n * This will return a quote that might look like:\n * ```typescript\n * {\n *   originAmount: 10000026098875381n,\n *   destinationAmount: 1000000000000000000n,\n *   blockNumber: 22026509n,\n *   timestamp: 1741730936680,\n *   estimatedExecutionTimeMs: 1000\n *   steps: [\n *     {\n *       originToken: {\n *         chainId: 1,\n *         address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *         symbol: \"ETH\",\n *         name: \"Ethereum\",\n *         decimals: 18,\n *         priceUsd: 2000,\n *         iconUri: \"https://...\"\n *       },\n *       destinationToken: {\n *         chainId: 10,\n *         address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *         symbol: \"ETH\",\n *         name: \"Ethereum\",\n *         decimals: 18,\n *         priceUsd: 2000,\n *         iconUri: \"https://...\"\n *       },\n *       originAmount: 10000026098875381n,\n *       destinationAmount: 1000000000000000000n,\n *       estimatedExecutionTimeMs: 1000\n *       transactions: [\n *         {\n *           action: \"approval\",\n *           id: \"0x\",\n *           to: \"0x...\",\n *           data: \"0x...\",\n *           chainId: 10,\n *           type: \"eip1559\"\n *         },\n *         {\n *           action: \"buy\",\n *           to: \"0x...\",\n *           value: 10000026098875381n,\n *           data: \"0x...\",\n *           chainId: 10,\n *           type: \"eip1559\"\n *         }\n *       ]\n *     }\n *   ],\n *   expiration: 1741730936680,\n *   intent: {\n *     originChainId: 1,\n *     originTokenAddress: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *     destinationChainId: 10,\n *     destinationTokenAddress: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *     amount: 1000000000000000000n\n *   }\n * }\n * ```\n *\n * ## Sending the transactions\n * The `transactions` array is a series of [ox](https://oxlib.sh) EIP-1559 transactions that must be executed one after the other in order to fulfill the complete route. There are a few things to keep in mind when executing these transactions:\n *  - Approvals will have the `approval` action specified. You can perform approvals with `sendAndConfirmTransaction`, then proceed to the next transaction.\n *  - All transactions are assumed to be executed by the `sender` address, regardless of which chain they are on. The final transaction will use the `receiver` as the recipient address.\n *  - If an `expiration` timestamp is provided, all transactions must be executed before that time to guarantee successful execution at the specified price.\n *\n * NOTE: To get the status of each non-approval transaction, use `Bridge.status` rather than checking for transaction inclusion. This function will ensure full bridge completion on the destination chain.\n *\n * You can access this functions input and output types with `Buy.prepare.Options` and `Buy.prepare.Result`, respectively.\n *\n * @param options - The options for the quote.\n * @param options.originChainId - The chain ID of the origin token.\n * @param options.originTokenAddress - The address of the origin token.\n * @param options.destinationChainId - The chain ID of the destination token.\n * @param options.destinationTokenAddress - The address of the destination token.\n * @param options.amount - The amount of the destination token to receive.\n * @param options.sender - The address of the sender.\n * @param options.receiver - The address of the recipient.\n * @param options.purchaseData - Arbitrary data to be passed to the purchase function and included with any webhooks or status calls.\n * @param options.client - Your thirdweb client.\n *\n * @returns A promise that resolves to a finalized quote and transactions for the requested buy.\n *\n * @throws Will throw an error if there is an issue fetching the quote.\n * @bridge Buy\n * @beta\n */\nexport async function prepare(\n  options: prepare.Options,\n): Promise<prepare.Result> {\n  const {\n    originChainId,\n    originTokenAddress,\n    destinationChainId,\n    destinationTokenAddress,\n    sender,\n    receiver,\n    client,\n    amount,\n    purchaseData,\n  } = options;\n\n  const clientFetch = getClientFetch(client);\n  const url = new URL(`${UNIVERSAL_BRIDGE_URL}/buy/prepare`);\n\n  const response = await clientFetch(url.toString(), {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      buyAmountWei: amount.toString(),\n      originChainId: originChainId.toString(),\n      originTokenAddress,\n      destinationChainId: destinationChainId.toString(),\n      destinationTokenAddress,\n      sender,\n      receiver,\n      purchaseData,\n    }),\n  });\n  if (!response.ok) {\n    const errorJson = await response.json();\n    throw new Error(\n      `${errorJson.code} | ${errorJson.message} - ${errorJson.correlationId}`,\n    );\n  }\n\n  const { data }: { data: PreparedQuote } = await response.json();\n  return {\n    originAmount: BigInt(data.originAmount),\n    destinationAmount: BigInt(data.destinationAmount),\n    blockNumber: data.blockNumber ? BigInt(data.blockNumber) : undefined,\n    timestamp: data.timestamp,\n    estimatedExecutionTimeMs: data.estimatedExecutionTimeMs,\n    steps: data.steps.map((step) => ({\n      ...step,\n      transactions: step.transactions.map((transaction) => ({\n        ...transaction,\n        value: transaction.value ? BigInt(transaction.value) : undefined,\n        client,\n        chain: defineChain(transaction.chainId),\n      })),\n    })),\n    intent: {\n      originChainId,\n      originTokenAddress,\n      destinationChainId,\n      destinationTokenAddress,\n      amount,\n    },\n  };\n}\n\nexport declare namespace prepare {\n  type Options = {\n    originChainId: number;\n    originTokenAddress: ox__Address.Address;\n    destinationChainId: number;\n    destinationTokenAddress: ox__Address.Address;\n    sender: ox__Address.Address;\n    receiver: ox__Address.Address;\n    amount: bigint;\n    client: ThirdwebClient;\n    purchaseData?: unknown;\n  };\n\n  type Result = PreparedQuote & {\n    intent: {\n      originChainId: number;\n      originTokenAddress: ox__Address.Address;\n      destinationChainId: number;\n      destinationTokenAddress: ox__Address.Address;\n      amount: bigint;\n      purchaseData?: unknown;\n    };\n  };\n}\n", "export const UNIVERSAL_BRIDGE_URL = \"https://bridge.thirdweb.com/v1\";\n", "import type { Address as ox__Address } from \"ox\";\nimport { defineChain } from \"../chains/utils.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { getClientFetch } from \"../utils/fetch.js\";\nimport { UNIVERSAL_BRIDGE_URL } from \"./constants.js\";\nimport type { PreparedQuote, Quote } from \"./types/Quote.js\";\n\n/**\n * Retrieves a Universal Bridge quote for the provided sell intent. The quote will specify the expected `destinationAmount` that will be received in exchange for the specified `originAmount`, which is specified with the `sellAmountWei` option.\n *\n * @example\n * ```typescript\n * import { Bridge, NATIVE_TOKEN_ADDRESS } from \"thirdweb\";\n *\n * const quote = await Bridge.Sell.quote({\n *   originChainId: 1,\n *   originTokenAddress: NATIVE_TOKEN_ADDRESS,\n *   destinationChainId: 10,\n *   destinationTokenAddress: NATIVE_TOKEN_ADDRESS,\n *   amount: toWei(\"0.01\"),\n *   client: thirdwebClient,\n * });\n * ```\n *\n * This will return a quote that might look like:\n * ```typescript\n * {\n *   originAmount: 1000000000000000000n,\n *   destinationAmount: 9999979011973735n,\n *   blockNumber: 22026509n,\n *   timestamp: 1741730936680,\n *   estimatedExecutionTimeMs: 1000\n *   steps: [\n *     {\n *       originToken: {\n *         chainId: 1,\n *         address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *         symbol: \"ETH\",\n *         name: \"Ethereum\",\n *         decimals: 18,\n *         priceUsd: 2000,\n *         iconUri: \"https://...\"\n *       },\n *       destinationToken: {\n *         chainId: 10,\n *         address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *         symbol: \"ETH\",\n *         name: \"Ethereum\",\n *         decimals: 18,\n *         priceUsd: 2000,\n *         iconUri: \"https://...\"\n *       },\n *       originAmount: 1000000000000000000n,\n *       destinationAmount:  99999979011973735n,\n *       estimatedExecutionTimeMs: 1000\n *     }\n *   ],\n *   intent: {\n *     originChainId: 1,\n *     originTokenAddress: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *     destinationChainId: 10,\n *     destinationTokenAddress: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *     amount: 1000000000000000000n\n *   }\n * }\n * ```\n *\n * The quote is an **estimate** for how much you would expect to receive for a specific sell. This quote is not guaranteed and you should use `Sell.prepare` to get a finalized quote with transaction data ready for execution.\n * So why use `quote`? The quote function is sometimes slightly faster than `prepare`, and can be used before the user connects their wallet.\n *\n * You can access this functions input and output types with `Sell.quote.Options` and `Sell.quote.Result`, respectively.\n *\n * @param options - The options for the quote.\n * @param options.originChainId - The chain ID of the origin token.\n * @param options.originTokenAddress - The address of the origin token.\n * @param options.destinationChainId - The chain ID of the destination token.\n * @param options.destinationTokenAddress - The address of the destination token.\n * @param options.amount - The amount of the origin token to sell.\n * @param options.client - Your thirdweb client.\n *\n * @returns A promise that resolves to a non-finalized quote for the requested sell.\n *\n * @throws Will throw an error if there is an issue fetching the quote.\n * @bridge Sell\n * @beta\n */\nexport async function quote(options: quote.Options): Promise<quote.Result> {\n  const {\n    originChainId,\n    originTokenAddress,\n    destinationChainId,\n    destinationTokenAddress,\n    amount,\n    client,\n  } = options;\n\n  const clientFetch = getClientFetch(client);\n  const url = new URL(`${UNIVERSAL_BRIDGE_URL}/sell/quote`);\n  url.searchParams.set(\"originChainId\", originChainId.toString());\n  url.searchParams.set(\"originTokenAddress\", originTokenAddress);\n  url.searchParams.set(\"destinationChainId\", destinationChainId.toString());\n  url.searchParams.set(\"destinationTokenAddress\", destinationTokenAddress);\n  url.searchParams.set(\"sellAmountWei\", amount.toString());\n\n  const response = await clientFetch(url.toString());\n  if (!response.ok) {\n    const errorJson = await response.json();\n    throw new Error(\n      `${errorJson.code} | ${errorJson.message} - ${errorJson.correlationId}`,\n    );\n  }\n\n  const { data }: { data: Quote } = await response.json();\n  return {\n    originAmount: BigInt(data.originAmount),\n    destinationAmount: BigInt(data.destinationAmount),\n    blockNumber: data.blockNumber ? BigInt(data.blockNumber) : undefined,\n    timestamp: data.timestamp,\n    estimatedExecutionTimeMs: data.estimatedExecutionTimeMs,\n    steps: data.steps,\n    intent: {\n      originChainId,\n      originTokenAddress,\n      destinationChainId,\n      destinationTokenAddress,\n      amount,\n    },\n  };\n}\n\nexport declare namespace quote {\n  type Options = {\n    originChainId: number;\n    originTokenAddress: ox__Address.Address;\n    destinationChainId: number;\n    destinationTokenAddress: ox__Address.Address;\n    amount: bigint;\n    client: ThirdwebClient;\n  };\n\n  type Result = Quote & {\n    intent: {\n      originChainId: number;\n      originTokenAddress: ox__Address.Address;\n      destinationChainId: number;\n      destinationTokenAddress: ox__Address.Address;\n      amount: bigint;\n    };\n  };\n}\n\n/**\n * Prepares a **finalized** Universal Bridge quote for the provided sell request with transaction data. This function will return everything `quote` does, with the addition of a series of prepared transactions and the associated expiration timestamp.\n *\n * @example\n * ```typescript\n * import { Bridge, NATIVE_TOKEN_ADDRESS } from \"thirdweb\";\n *\n * const quote = await Bridge.Sell.prepare({\n *   originChainId: 1,\n *   originTokenAddress: NATIVE_TOKEN_ADDRESS,\n *   destinationChainId: 10,\n *   destinationTokenAddress: NATIVE_TOKEN_ADDRESS,\n *   amount: toWei(\"0.01\"),\n *   client: thirdwebClient,\n * });\n * ```\n *\n * This will return a quote that might look like:\n * ```typescript\n * {\n *   originAmount: 1000000000000000000n,\n *   destinationAmount:  9980000000000000000n,\n *   blockNumber: 22026509n,\n *   timestamp: 1741730936680,\n *   estimatedExecutionTimeMs: 1000\n *   steps: [\n *     {\n *       originToken: {\n *         chainId: 1,\n *         address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *         symbol: \"ETH\",\n *         name: \"Ethereum\",\n *         decimals: 18,\n *         priceUsd: 2000,\n *         iconUri: \"https://...\"\n *       },\n *       destinationToken: {\n *         chainId: 10,\n *         address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *         symbol: \"ETH\",\n *         name: \"Ethereum\",\n *         decimals: 18,\n *         priceUsd: 2000,\n *         iconUri: \"https://...\"\n *       },\n *       originAmount: 1000000000000000000n,\n *       destinationAmount:  9980000000000000000n,\n *       estimatedExecutionTimeMs: 1000\n *     }\n *     transactions: [\n *       {\n *         id: \"0x...\",\n *         action: \"approval\",\n *         to: \"0x...\",\n *         data: \"0x...\",\n *         chainId: 10,\n *         type: \"eip1559\"\n *       },\n *       {\n *         id: \"0x...\",\n *         action: \"sell\",\n *         to: \"0x...\",\n *         data: \"0x...\",\n *         chainId: 10,\n *         type: \"eip1559\"\n *       }\n *     ],\n *   ],\n *   expiration: 1741730936680,\n *   intent: {\n *     originChainId: 1,\n *     originTokenAddress: NATIVE_TOKEN_ADDRESS,\n *     destinationChainId: 10,\n *     destinationTokenAddress: NATIVE_TOKEN_ADDRESS,\n *     amount: 1000000000000000000n\n *   }\n * }\n * ```\n *\n * ## Sending the transactions\n * The `transactions` array is a series of [ox](https://oxlib.sh) EIP-1559 transactions that must be executed one after the other in order to fulfill the complete route. There are a few things to keep in mind when executing these transactions:\n *  - Approvals will have the `approval` action specified. You can perform approvals with `sendAndConfirmTransaction`, then proceed to the next transaction.\n *  - All transactions are assumed to be executed by the `sender` address, regardless of which chain they are on. The final transaction will use the `receiver` as the recipient address.\n *  - If an `expiration` timestamp is provided, all transactions must be executed before that time to guarantee successful execution at the specified price.\n *\n * NOTE: To get the status of each non-approval transaction, use `Bridge.status` rather than checking for transaction inclusion. This function will ensure full bridge completion on the destination chain.\n *\n * You can access this functions input and output types with `Sell.prepare.Options` and `Sell.prepare.Result`, respectively.\n *\n * @param options - The options for the quote.\n * @param options.originChainId - The chain ID of the origin token.\n * @param options.originTokenAddress - The address of the origin token.\n * @param options.destinationChainId - The chain ID of the destination token.\n * @param options.destinationTokenAddress - The address of the destination token.\n * @param options.amount - The amount of the origin token to sell.\n * @param options.sender - The address of the sender.\n * @param options.receiver - The address of the recipient.\n * @param options.purchaseData - Arbitrary data to be passed to the purchase function and included with any webhooks or status calls.\n * @param options.client - Your thirdweb client.\n *\n * @returns A promise that resolves to a finalized quote and transactions for the requested sell.\n *\n * @throws Will throw an error if there is an issue fetching the quote.\n * @bridge Sell\n * @beta\n */\nexport async function prepare(\n  options: prepare.Options,\n): Promise<prepare.Result> {\n  const {\n    originChainId,\n    originTokenAddress,\n    destinationChainId,\n    destinationTokenAddress,\n    amount,\n    sender,\n    receiver,\n    client,\n    purchaseData,\n  } = options;\n\n  const clientFetch = getClientFetch(client);\n  const url = new URL(`${UNIVERSAL_BRIDGE_URL}/sell/prepare`);\n\n  const response = await clientFetch(url.toString(), {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      sellAmountWei: amount.toString(),\n      originChainId: originChainId.toString(),\n      originTokenAddress,\n      destinationChainId: destinationChainId.toString(),\n      destinationTokenAddress,\n      sender,\n      receiver,\n      purchaseData,\n    }),\n  });\n  if (!response.ok) {\n    const errorJson = await response.json();\n    throw new Error(\n      `${errorJson.code} | ${errorJson.message} - ${errorJson.correlationId}`,\n    );\n  }\n\n  const { data }: { data: PreparedQuote } = await response.json();\n  return {\n    originAmount: BigInt(data.originAmount),\n    destinationAmount: BigInt(data.destinationAmount),\n    blockNumber: data.blockNumber ? BigInt(data.blockNumber) : undefined,\n    timestamp: data.timestamp,\n    estimatedExecutionTimeMs: data.estimatedExecutionTimeMs,\n    steps: data.steps.map((step) => ({\n      ...step,\n      transactions: step.transactions.map((transaction) => ({\n        ...transaction,\n        value: transaction.value ? BigInt(transaction.value) : undefined,\n        client,\n        chain: defineChain(transaction.chainId),\n      })),\n    })),\n    expiration: data.expiration,\n    intent: {\n      originChainId,\n      originTokenAddress,\n      destinationChainId,\n      destinationTokenAddress,\n      amount,\n      purchaseData,\n    },\n  };\n}\n\nexport declare namespace prepare {\n  type Options = {\n    originChainId: number;\n    originTokenAddress: ox__Address.Address;\n    destinationChainId: number;\n    destinationTokenAddress: ox__Address.Address;\n    amount: bigint;\n    sender: ox__Address.Address;\n    receiver: ox__Address.Address;\n    client: ThirdwebClient;\n    purchaseData?: unknown;\n  };\n\n  type Result = PreparedQuote & {\n    intent: {\n      originChainId: number;\n      originTokenAddress: ox__Address.Address;\n      destinationChainId: number;\n      destinationTokenAddress: ox__Address.Address;\n      amount: bigint;\n      purchaseData?: unknown;\n    };\n  };\n}\n", "import type { Hex as ox__Hex } from \"ox\";\nimport type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { getClientFetch } from \"../utils/fetch.js\";\nimport { UNIVERSAL_BRIDGE_URL } from \"./constants.js\";\nimport type { Status } from \"./types/Status.js\";\n\n/**\n * Retrieves a Universal Bridge quote for the provided sell intent. The quote will specify the expected `destinationAmount` that will be received in exchange for the specified `originAmount`, which is specified with the `sellAmountWei` option.\n *\n * The returned status will include both the origin and destination transactions and any finalized amounts for the route.\n *\n * @example\n * ```typescript\n * import { Bridge } from \"thirdweb\";\n *\n * const status = await Bridge.status({\n *   transactionHash: \"0xe199ef82a0b6215221536e18ec512813c1aa10b4f5ed0d4dfdfcd703578da56d\",\n *   chainId: 8453,\n *   client: thirdwebClient,\n * });\n * ```\n *\n * If the transaction is complete, a response might look like:\n * ```typescript\n * {\n *   status: 'COMPLETED',\n *   originAmount: 200000000000000n,\n *   destinationAmount: 188625148000000n,\n *   originChainId: 8453,\n *   destinationChainId: 2741,\n *   originTokenAddress: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE',\n *   destinationTokenAddress: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE',\n *   transactions: [\n *     {\n *       chainId: 8453,\n *       transactionHash: '0xe199ef82a0b6215221536e18ec512813c1aa10b4f5ed0d4dfdfcd703578da56d'\n *     },\n *     {\n *       chainId: 2741,\n *       transactionHash: '0xa70a82f42330f54be95a542e1fcfe6ed2dd9f07fb8c82ae67afb4342319f7433'\n *     }\n *   ],\n *   purchaseData: {\n *     foo: \"bar\"\n *   }\n * }\n * ```\n *\n * If the origin transaction hasn't been mined yet, a response might look like:\n * ```typescript\n * {\n *   status: \"NOT_FOUND\",\n * }\n * ```\n * This is to allow you to poll for the status without catching an error. Be sure your transaction hash and chain are correct though, as this could also represent a legitimate 404 if the transaction doesn't exist.\n *\n * If the transaction is still pending, a response might look like:\n * ```typescript\n * {\n *   status: \"PENDING\",\n *   originAmount: 1000000000000000000n,\n *   originChainId: 466,\n *   destinationChainId: 1,\n *   originTokenAddress: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *   destinationTokenAddress: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *   transactions: [\n *     {\n *       transactionHash: \"0xe199ef82a0b6215221536e18ec512813c1aa10b4f5ed0d4dfdfcd703578da56d\",\n *       chainId: 466,\n *     }\n *   ]\n * }\n * ```\n *\n * If the transaction failed, a response might look like:\n * ```typescript\n * {\n *   status: \"FAILED\",\n *   transactions: [\n *     {\n *       transactionHash: \"0xe199ef82a0b6215221536e18ec512813c1aa10b4f5ed0d4dfdfcd703578da56d\",\n *       chainId: 466,\n *     }\n *   ]\n * }\n * ```\n *\n * This status is for a **single origin transaction only**. If your route involves multiple transactions, you'll need to get the status for each of them individually.\n *\n * If sending multiple dependent sequential transactions, wait until `status` returns `COMPLETED` before sending the next transaction.\n *\n * You can access this function's input and output types with `status.Options` and `status.Result`, respectively.\n *\n * @param options - The options for the quote.\n * @param options.transactionHash - The hash of the origin transaction to get the bridge status for.\n * @param options.chainId - The chain ID of the origin token.\n * @param options.client - Your thirdweb client.\n *\n * @returns A promise that resolves to a status object for the transaction.\n *\n * @throws Will throw an error if there is an issue fetching the status.\n * @bridge\n * @beta\n */\nexport async function status(options: status.Options): Promise<status.Result> {\n  const { transactionHash, client } = options;\n  const chainId = \"chainId\" in options ? options.chainId : options.chain.id;\n\n  const clientFetch = getClientFetch(client);\n  const url = new URL(`${UNIVERSAL_BRIDGE_URL}/status`);\n  url.searchParams.set(\"transactionHash\", transactionHash);\n  url.searchParams.set(\"chainId\", chainId.toString());\n\n  const response = await clientFetch(url.toString());\n  if (!response.ok) {\n    const errorJson = await response.json();\n    throw new Error(\n      `${errorJson.code} | ${errorJson.message} - ${errorJson.correlationId}`,\n    );\n  }\n\n  const { data }: { data: Status } = await response.json();\n  if (data.status === \"FAILED\") {\n    return {\n      status: \"FAILED\",\n      transactions: data.transactions,\n    };\n  }\n\n  if (data.status === \"PENDING\") {\n    return {\n      status: \"PENDING\",\n      originAmount: BigInt(data.originAmount),\n      originChainId: data.originChainId,\n      destinationChainId: data.destinationChainId,\n      originTokenAddress: data.originTokenAddress,\n      destinationTokenAddress: data.destinationTokenAddress,\n      transactions: data.transactions,\n    };\n  }\n\n  if (data.status === \"NOT_FOUND\") {\n    return {\n      status: \"NOT_FOUND\",\n      transactions: [],\n    };\n  }\n\n  return {\n    status: \"COMPLETED\",\n    originAmount: BigInt(data.originAmount),\n    destinationAmount: BigInt(data.destinationAmount),\n    originChainId: data.originChainId,\n    destinationChainId: data.destinationChainId,\n    originTokenAddress: data.originTokenAddress,\n    destinationTokenAddress: data.destinationTokenAddress,\n    transactions: data.transactions,\n    purchaseData: data.purchaseData,\n  };\n}\n\nexport declare namespace status {\n  type Options =\n    | {\n        transactionHash: ox__Hex.Hex;\n        chainId: number;\n        client: ThirdwebClient;\n      }\n    | {\n        transactionHash: ox__Hex.Hex;\n        chain: Chain;\n        client: ThirdwebClient;\n      };\n\n  type Result = Status;\n}\n", "import type { Address as ox__Address, Hex as ox__Hex } from \"ox\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { getClientFetch } from \"../utils/fetch.js\";\nimport { UNIVERSAL_BRIDGE_URL } from \"./constants.js\";\nimport type { Route } from \"./types/Route.js\";\n\n/**\n * Retrieves supported Universal Bridge routes based on the provided filters.\n *\n * When multiple filters are specified, a route must satisfy all filters to be included (it acts as an AND operator).\n *\n * @example\n * ```typescript\n * import { Bridge } from \"thirdweb\";\n *\n * const routes = await Bridge.routes({\n *   client: thirdwebClient,\n * });\n * ```\n *\n * Returned routes might look something like:\n * ```typescript\n * [\n *    {\n *     destinationToken: {\n *       address: \"0x12c88a3C30A7AaBC1dd7f2c08a97145F5DCcD830\",\n *       chainId: 1,\n *       decimals: 18,\n *       iconUri: \"https://assets.coingecko.com/coins/images/37207/standard/G.jpg\",\n *       name: \"G7\",\n *       symbol: \"G7\",\n *     },\n *     originToken: {\n *       address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *       chainId: 480,\n *       decimals: 18,\n *       iconUri: \"https://assets.relay.link/icons/1/light.png\",\n *       name: \"Ether\",\n *       symbol: \"ETH\",\n *     }\n *   },\n *   {\n *     destinationToken: {\n *       address: \"0x4d224452801ACEd8B2F0aebE155379bb5D594381\",\n *       chainId: 1,\n *       decimals: 18,\n *       iconUri: \"https://coin-images.coingecko.com/coins/images/24383/large/apecoin.jpg?1696523566\",\n *       name: \"ApeCoin\",\n *       symbol: \"APE\",\n *     },\n *     originToken: {\n *       address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *       chainId: 480,\n *       decimals: 18,\n *       iconUri: \"https://assets.relay.link/icons/1/light.png\",\n *       name: \"Ether\",\n *       symbol: \"ETH\",\n *     }\n *   }\n * ]\n * ```\n *\n * You can filter for specific chains or tokens:\n * ```typescript\n * import { Bridge } from \"thirdweb\";\n *\n * // Get all routes starting from mainnet ETH\n * const routes = await Bridge.routes({\n *   originChainId: 1,\n *   originTokenAddress: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *   client: thirdwebClient,\n * });\n * ```\n *\n * The returned routes will be limited based on the API. You can paginate through the results using the `limit` and `offset` parameters:\n * ```typescript\n * import { Bridge } from \"thirdweb\";\n *\n * // Get the first 10 routes starting from mainnet ETH\n * const routes = await Bridge.routes({\n *   originChainId: 1,\n *   originTokenAddress: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *   limit: 10,\n *   offset: 0,\n *   client: thirdwebClient,\n * });\n * ```\n *\n * @param options - The options for the quote.\n * @param options.client - Your thirdweb client.\n * @param options.originChainId - Filter by a specific origin chain ID.\n * @param options.originTokenAddress - Filter by a specific origin token address.\n * @param options.destinationChainId - Filter by a specific destination chain ID.\n * @param options.destinationTokenAddress - Filter by a specific destination token address.\n * @param options.transactionHash - Filter by a specific transaction hash.\n * @param options.maxSteps - Limit the number of steps returned.\n * @param options.limit - Limit the number of routes returned.\n * @param options.offset - Offset the number of routes returned.\n *\n * @returns A promise that resolves to an array of routes.\n *\n * @throws Will throw an error if there is an issue fetching the routes.\n * @bridge\n * @beta\n */\nexport async function routes(options: routes.Options): Promise<routes.Result> {\n  const {\n    client,\n    originChainId,\n    originTokenAddress,\n    destinationChainId,\n    destinationTokenAddress,\n    maxSteps,\n    limit,\n    offset,\n  } = options;\n\n  const clientFetch = getClientFetch(client);\n  const url = new URL(`${UNIVERSAL_BRIDGE_URL}/routes`);\n  if (originChainId) {\n    url.searchParams.set(\"originChainId\", originChainId.toString());\n  }\n  if (originTokenAddress) {\n    url.searchParams.set(\"originTokenAddress\", originTokenAddress);\n  }\n  if (destinationChainId) {\n    url.searchParams.set(\"destinationChainId\", destinationChainId.toString());\n  }\n  if (destinationTokenAddress) {\n    url.searchParams.set(\"destinationTokenAddress\", destinationTokenAddress);\n  }\n  if (maxSteps) {\n    url.searchParams.set(\"maxSteps\", maxSteps.toString());\n  }\n  if (limit) {\n    url.searchParams.set(\"limit\", limit.toString());\n  }\n  if (offset) {\n    url.searchParams.set(\"offset\", offset.toString());\n  }\n\n  const response = await clientFetch(url.toString());\n  if (!response.ok) {\n    const errorJson = await response.json();\n    throw new Error(`${errorJson.code} | ${errorJson.message}`);\n  }\n\n  const { data }: { data: Route[] } = await response.json();\n  return data;\n}\n\nexport declare namespace routes {\n  type Options = {\n    client: ThirdwebClient;\n    originChainId?: number;\n    originTokenAddress?: ox__Address.Address;\n    destinationChainId?: number;\n    destinationTokenAddress?: ox__Address.Address;\n    transactionHash?: ox__Hex.Hex;\n    maxSteps?: number;\n    limit?: number;\n    offset?: number;\n  };\n\n  type Result = Route[];\n}\n", "import type { Abi, AbiFunction } from \"abitype\";\nimport { parseAbiItem } from \"abitype\";\nimport { resolveContractAbi } from \"../contract/actions/resolve-abi.js\";\nimport type { ThirdwebContract } from \"../contract/contract.js\";\n\n/**\n * Resolves and returns the ABI function with the specified method name.\n * Throws an error if the function is not found in the ABI.\n * @template abiFn - The type of the ABI function.\n * @param method - The name of the method to resolve.\n * @returns The resolved ABI function.\n * @throws Error if the function is not found in the ABI.\n * @example\n * ```ts\n * import { resolveMethod, prepareContractCall } from \"thirdweb\";\n * const tx = prepareContractCall({\n *  contract,\n *  // automatically resolves the necessary abi to encode the transaction\n *  method: resolveMethod(\"transfer\"),\n *  // however there is no type completion for params in this case (as the resolution is async and happens at runtime)\n *  params: [to, value],\n * });\n * ```\n * @contract\n */\nexport function resolveMethod<\n  abiFn extends AbiFunction,\n  TAbi extends Abi = Abi,\n>(method: string) {\n  return async (contract: ThirdwebContract<TAbi>) => {\n    if (typeof method === \"string\" && method.startsWith(\"function \")) {\n      // we know it will be an abi function so we can cast it\n      return parseAbiItem(method) as AbiFunction;\n    }\n\n    const resolvedAbi = contract.abi?.length\n      ? contract.abi\n      : await resolveContractAbi<Abi>(contract);\n    // we try to find the abiFunction in the abi\n    const abiFunction = resolvedAbi.find((item) => {\n      // if the item is not a function we can ignore it\n      if (item.type !== \"function\") {\n        return false;\n      }\n      // if the item is a function we can compare the name\n      return item.name === method;\n    }) as abiFn | undefined;\n\n    if (!abiFunction) {\n      throw new Error(`could not find function with name \"${method}\" in abi`);\n    }\n    return abiFunction;\n  };\n}\n", "import type * as ox__Signature from \"ox/Signature\";\nimport * as ox__TypedData from \"ox/TypedData\";\nimport type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\nimport type { HashTypedDataParams } from \"../utils/hashing/hashTypedData.js\";\nimport { type VerifyHashParams, verifyHash } from \"./verify-hash.js\";\n\nexport type VerifyTypedDataParams<\n  typedData extends\n    | ox__TypedData.TypedData\n    | Record<string, unknown> = ox__TypedData.TypedData,\n  primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n> = Omit<VerifyHashParams, \"hash\"> &\n  ox__TypedData.Definition<typedData, primaryType> & {\n    address: string;\n    signature: string | Uint8Array | ox__Signature.Signature;\n    client: ThirdwebClient;\n    chain: Chain;\n    accountFactory?: {\n      address: string;\n      verificationCalldata: Hex;\n    };\n  };\n\n/**\n * Verify am [EIP-712](https://eips.ethereum.org/EIPS/eip-712) typed data signature. This function is interoperable with all wallet types (smart accounts or EOAs).\n *\n * @param {string} options.address The address that signed the typed data\n * @param {string | Uint8Array | Signature} options.signature The signature that was signed\n * @param {ThirdwebClient} options.client The Thirdweb client\n * @param {Chain} options.chain The chain that the address is on. For an EOA, this can be any chain.\n * @param {string} [options.accountFactory.address] The address of the account factory that created the account if using a smart account with a custom account factory\n * @param {Hex} [options.accountFactory.verificationCalldata] The calldata that was used to create the account if using a smart account with a custom account factory\n * @param {typeof VerifyTypedDataParams.message} options.message The EIP-712 message that was signed.\n * @param {typeof VerifyTypedDataParams.domain} options.domain The EIP-712 domain that was signed.\n * @param {typeof VerifyTypedDataParams.primaryType} options.primaryType The EIP-712 primary type that was signed.\n * @param {typeof VerifyTypedDataParams.types} options.types The EIP-712 types that were signed.\n *\n * @returns {Promise<boolean>} A promise that resolves to `true` if the signature is valid, or `false` otherwise.\n *\n * @example\n * ```ts\n * import { verifyTypedData } from \"thirdweb/utils\";\n * const isValid = await verifyTypedData({\n *   address: \"0x...\",\n *   signature: \"0x...\",\n *   client,\n *   chain,\n *   domain: {\n      name: \"Ether Mail\",\n      version: \"1\",\n      chainId: 1,\n      verifyingContract: \"0x0000000000000000000000000000000000000000\",\n    },\n *   primaryType: \"Mail\",\n *   types: {\n      Person: [\n        { name: \"name\", type: \"string\" },\n        { name: \"wallet\", type: \"address\" },\n      ],\n      Mail: [\n        { name: \"from\", type: \"Person\" },\n        { name: \"to\", type: \"Person\" },\n        { name: \"contents\", type: \"string\" },\n      ],\n    },\n    message: {\n      from: {\n        name: \"Cow\",\n        wallet: \"0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826\",\n      },\n      to: {\n        name: \"Bob\",\n        wallet: \"0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB\",\n      },\n      contents: \"Hello, Bob!\",\n    },\n * });\n * ```\n *\n * @auth\n */\nexport async function verifyTypedData<\n  typedData extends ox__TypedData.TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | \"EIP712Domain\",\n>({\n  address,\n  signature,\n  client,\n  chain,\n  accountFactory,\n  message,\n  domain,\n  primaryType,\n  types,\n}: VerifyTypedDataParams<typedData, primaryType>): Promise<boolean> {\n  const messageHash = ox__TypedData.getSignPayload({\n    message,\n    domain,\n    primaryType,\n    types,\n  } as HashTypedDataParams);\n  return verifyHash({\n    hash: messageHash,\n    signature,\n    address,\n    chain,\n    client,\n    accountFactory,\n  });\n}\n", "import type * as ox__Authorization from \"ox/Authorization\";\nimport type { Address } from \"../../../utils/address.js\";\nimport type { Account } from \"../../../wallets/interfaces/wallet.js\";\n\n/**\n * An EIP-7702 authorization object fully prepared and ready for signing.\n *\n * @beta\n * @transaction\n */\nexport type AuthorizationRequest = {\n  address: Address;\n  chainId: number;\n  nonce: bigint;\n};\n\n/**\n * Represents a signed EIP-7702 authorization object.\n *\n * @beta\n * @transaction\n */\nexport type SignedAuthorization = ox__Authorization.ListSigned[number];\n\n/**\n * Sign the given EIP-7702 authorization object.\n * @param options - The options for `signAuthorization`\n * Refer to the type [`SignAuthorizationOptions`](https://portal.thirdweb.com/references/typescript/v5/SignAuthorizationOptions)\n * @returns The signed authorization object\n *\n * ```ts\n * import { signAuthorization } from \"thirdweb\";\n *\n * const authorization = await signAuthorization({\n *     request: {\n *         address: \"0x...\",\n *         chainId: 911867,\n *         nonce: 100n,\n *     },\n *     account: myAccount,\n * });\n * ```\n *\n * @beta\n * @transaction\n */\nexport async function signAuthorization(options: {\n  account: Account;\n  request: AuthorizationRequest;\n}): Promise<SignedAuthorization> {\n  const { account, request } = options;\n  if (typeof account.signAuthorization === \"undefined\") {\n    throw new Error(\n      \"This account type does not yet support signing EIP-7702 authorizations\",\n    );\n  }\n  return account.signAuthorization(request);\n}\n"],
  "mappings": "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",
  "names": ["sha256", "sha256", "prepare", "quote", "quote", "prepare"]
}
