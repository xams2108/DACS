import {
  createInAppWallet,
  createWalletEmitter,
  trackConnect
} from "./chunk-NXASE243.js";
import {
  isEcosystemWallet
} from "./chunk-ZURXGIGP.js";
import {
  webLocalStorage
} from "./chunk-G4H2UJKK.js";
import {
  getInjectedProvider
} from "./chunk-FB5IB3WF.js";
import {
  getCoinbaseWebProvider
} from "./chunk-CMLY7B67.js";
import {
  COINBASE
} from "./chunk-LZH3KM55.js";
import {
  getDefaultAccountFactory
} from "./chunk-F5UXFDUH.js";
import {
  isZkSyncChain
} from "./chunk-ZVVOIXUB.js";
import {
  isContractDeployed
} from "./chunk-XRZYIZWV.js";
import {
  getContract
} from "./chunk-OC3SQ5HK.js";
import {
  getCachedChainIfExists
} from "./chunk-6OSAHK2J.js";
import {
  detectOS
} from "./chunk-3OXDSLPJ.js";

// node_modules/thirdweb/dist/esm/wallets/in-app/web/ecosystem.js
function ecosystemWallet(...args) {
  const [ecosystemId, createOptions] = args;
  const ecosystem = {
    id: ecosystemId,
    partnerId: createOptions == null ? void 0 : createOptions.partnerId
  };
  return createInAppWallet({
    ecosystem,
    createOptions: {
      auth: {
        ...createOptions == null ? void 0 : createOptions.auth,
        options: []
        // controlled by ecosystem
      },
      partnerId: ecosystem.partnerId
    },
    connectorFactory: async (client) => {
      const { InAppWebConnector } = await import("./web-connector-LBVZPVMP.js");
      return new InAppWebConnector({
        client,
        ecosystem,
        storage: createOptions == null ? void 0 : createOptions.storage
      });
    }
  });
}

// node_modules/thirdweb/dist/esm/wallets/in-app/web/in-app.js
function inAppWallet(createOptions) {
  return createInAppWallet({
    createOptions,
    connectorFactory: async (client) => {
      var _a;
      const { InAppWebConnector } = await import("./web-connector-LBVZPVMP.js");
      return new InAppWebConnector({
        client,
        passkeyDomain: (_a = createOptions == null ? void 0 : createOptions.auth) == null ? void 0 : _a.passkeyDomain,
        storage: createOptions == null ? void 0 : createOptions.storage
      });
    }
  });
}

// node_modules/thirdweb/dist/esm/wallets/smart/smart-wallet.js
function smartWallet(createOptions) {
  const emitter = createWalletEmitter();
  let account = void 0;
  let adminAccount = void 0;
  let chain = void 0;
  let lastConnectOptions;
  return {
    id: "smart",
    subscribe: emitter.subscribe,
    getChain() {
      if (!chain) {
        return void 0;
      }
      chain = getCachedChainIfExists(chain.id) || chain;
      return chain;
    },
    getConfig: () => createOptions,
    getAccount: () => account,
    getAdminAccount: () => adminAccount,
    autoConnect: async (options) => {
      const { connectSmartAccount: connectSmartWallet } = await import("./smart-TEYHVJYM.js");
      const [connectedAccount, connectedChain] = await connectSmartWallet(options, createOptions);
      lastConnectOptions = options;
      account = connectedAccount;
      chain = connectedChain;
      trackConnect({
        client: options.client,
        walletType: "smart",
        walletAddress: account.address,
        chainId: chain.id
      });
      return account;
    },
    connect: async (options) => {
      const { connectSmartAccount } = await import("./smart-TEYHVJYM.js");
      const [connectedAccount, connectedChain] = await connectSmartAccount(options, createOptions);
      adminAccount = options.personalAccount;
      lastConnectOptions = options;
      account = connectedAccount;
      chain = connectedChain;
      trackConnect({
        client: options.client,
        walletType: "smart",
        walletAddress: account.address,
        chainId: chain.id
      });
      emitter.emit("accountChanged", account);
      return account;
    },
    disconnect: async () => {
      if (account) {
        const { disconnectSmartAccount } = await import("./smart-TEYHVJYM.js");
        await disconnectSmartAccount(account);
      }
      account = void 0;
      adminAccount = void 0;
      chain = void 0;
      emitter.emit("disconnect", void 0);
    },
    switchChain: async (newChain) => {
      var _a;
      if (!lastConnectOptions) {
        throw new Error("Cannot switch chain without a previous connection");
      }
      const isZksyncChain = await isZkSyncChain(newChain);
      if (!isZksyncChain) {
        const factory = getContract({
          address: createOptions.factoryAddress || getDefaultAccountFactory((_a = createOptions.overrides) == null ? void 0 : _a.entrypointAddress),
          chain: newChain,
          client: lastConnectOptions.client
        });
        const isDeployed = await isContractDeployed(factory);
        if (!isDeployed) {
          throw new Error(`Factory contract not deployed on chain: ${newChain.id}`);
        }
      }
      const { connectSmartAccount } = await import("./smart-TEYHVJYM.js");
      const [connectedAccount, connectedChain] = await connectSmartAccount({ ...lastConnectOptions, chain: newChain }, createOptions);
      account = connectedAccount;
      chain = connectedChain;
      emitter.emit("accountChanged", connectedAccount);
      emitter.emit("chainChanged", connectedChain);
    }
  };
}

// node_modules/thirdweb/dist/esm/utils/web/isMobile.js
function isAndroid() {
  if (typeof navigator === "undefined") {
    return false;
  }
  const os = detectOS(navigator.userAgent);
  return os ? os.toLowerCase().includes("android") : false;
}
function isIOS() {
  if (typeof navigator === "undefined") {
    return false;
  }
  const os = detectOS(navigator.userAgent);
  return os ? os.toLowerCase().includes("ios") || os.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 : false;
}
function isMobile() {
  return isAndroid() || isIOS();
}

// node_modules/thirdweb/dist/esm/utils/web/openWindow.js
function openWindow(uri) {
  const isInsideIframe = window !== window.top;
  if (isInsideIframe) {
    window.open(uri);
  } else {
    if (uri.startsWith("http")) {
      const link = document.createElement("a");
      link.href = uri;
      link.target = "_blank";
      link.rel = "noreferrer noopener";
      link.click();
    } else {
      window.location.href = uri;
    }
  }
}

// node_modules/thirdweb/dist/esm/wallets/coinbase/coinbase-wallet.js
function coinbaseWalletSDK(args) {
  const { createOptions } = args;
  const emitter = createWalletEmitter();
  let account = void 0;
  let chain = void 0;
  function reset() {
    account = void 0;
    chain = void 0;
  }
  let handleDisconnect = async () => {
  };
  let handleSwitchChain = async (newChain) => {
    chain = newChain;
  };
  const unsubscribeChainChanged = emitter.subscribe("chainChanged", (newChain) => {
    chain = newChain;
  });
  const unsubscribeDisconnect = emitter.subscribe("disconnect", () => {
    reset();
    unsubscribeChainChanged();
    unsubscribeDisconnect();
  });
  emitter.subscribe("accountChanged", (_account) => {
    account = _account;
  });
  return {
    id: COINBASE,
    subscribe: emitter.subscribe,
    getChain() {
      if (!chain) {
        return void 0;
      }
      chain = getCachedChainIfExists(chain.id) || chain;
      return chain;
    },
    getConfig: () => createOptions,
    getAccount: () => account,
    autoConnect: async (options) => {
      const { autoConnectCoinbaseWalletSDK } = await import("./coinbase-web-S4GRJ5XG.js");
      const provider = await args.providerFactory();
      const [connectedAccount, connectedChain, doDisconnect, doSwitchChain] = await autoConnectCoinbaseWalletSDK(options, emitter, provider);
      account = connectedAccount;
      chain = connectedChain;
      handleDisconnect = doDisconnect;
      handleSwitchChain = doSwitchChain;
      trackConnect({
        client: options.client,
        walletType: COINBASE,
        walletAddress: account.address,
        chainId: chain.id
      });
      return account;
    },
    connect: async (options) => {
      const { connectCoinbaseWalletSDK } = await import("./coinbase-web-S4GRJ5XG.js");
      const provider = await args.providerFactory();
      const [connectedAccount, connectedChain, doDisconnect, doSwitchChain] = await connectCoinbaseWalletSDK(options, emitter, provider);
      account = connectedAccount;
      chain = connectedChain;
      handleDisconnect = doDisconnect;
      handleSwitchChain = doSwitchChain;
      trackConnect({
        client: options.client,
        walletType: COINBASE,
        walletAddress: account.address,
        chainId: chain.id
      });
      return account;
    },
    disconnect: async () => {
      reset();
      await handleDisconnect();
    },
    switchChain: async (newChain) => {
      await handleSwitchChain(newChain);
    },
    onConnectRequested: async () => {
      var _a;
      if (args.onConnectRequested) {
        const provider = await args.providerFactory();
        return (_a = args.onConnectRequested) == null ? void 0 : _a.call(args, provider);
      }
    }
  };
}

// node_modules/thirdweb/dist/esm/wallets/create-wallet.js
function createWallet(...args) {
  const [id, creationOptions] = args;
  switch (true) {
    /**
     * SMART WALLET
     */
    case id === "smart": {
      return smartWallet(creationOptions);
    }
    /**
     * IN-APP WALLET
     */
    case (id === "embedded" || id === "inApp"): {
      return inAppWallet(creationOptions);
    }
    /**
     * ECOSYSTEM WALLET
     */
    case isEcosystemWallet(id):
      return ecosystemWallet(...args);
    /**
     * COINBASE WALLET VIA SDK
     * -> if no injected coinbase found, we'll use the coinbase SDK
     */
    case id === COINBASE: {
      const options = creationOptions;
      return coinbaseWalletSDK({
        createOptions: options,
        providerFactory: () => getCoinbaseWebProvider(options),
        onConnectRequested: async (provider) => {
          const { showCoinbasePopup } = await import("./utils-TPJADCMG.js");
          return showCoinbasePopup(provider);
        }
      });
    }
    /**
     * WALLET CONNECT AND INJECTED WALLETS + walletConnect standalone
     */
    default: {
      let reset = function() {
        account = void 0;
        chain = void 0;
      };
      const emitter = createWalletEmitter();
      let account = void 0;
      let chain = void 0;
      let unsubscribeChain = void 0;
      let handleDisconnect = async () => {
      };
      const unsubscribeDisconnect = emitter.subscribe("disconnect", () => {
        reset();
        unsubscribeChain == null ? void 0 : unsubscribeChain();
        unsubscribeDisconnect();
      });
      emitter.subscribe("accountChanged", (_account) => {
        account = _account;
      });
      let handleSwitchChain = async () => {
        throw new Error("Not implemented yet");
      };
      const sessionHandler = isMobile() ? (uri) => openWindow(uri) : void 0;
      const wallet = {
        id,
        subscribe: emitter.subscribe,
        getConfig: () => args[1],
        getChain() {
          if (!chain) {
            return void 0;
          }
          chain = getCachedChainIfExists(chain.id) || chain;
          return chain;
        },
        getAccount: () => account,
        autoConnect: async (options) => {
          const { injectedProvider } = await import("./mipdStore-M3CZRW25.js");
          if (id !== "walletConnect" && injectedProvider(id)) {
            const { autoConnectEip1193Wallet } = await import("./injected-U2HKS4LU.js");
            const [connectedAccount, connectedChain, doDisconnect, doSwitchChain] = await autoConnectEip1193Wallet({
              id,
              provider: getInjectedProvider(id),
              emitter,
              chain: options.chain,
              client: options.client
            });
            account = connectedAccount;
            chain = connectedChain;
            handleDisconnect = doDisconnect;
            handleSwitchChain = doSwitchChain;
            unsubscribeChain = emitter.subscribe("chainChanged", (newChain) => {
              chain = newChain;
            });
            trackConnect({
              client: options.client,
              walletType: id,
              walletAddress: account.address,
              chainId: chain.id
            });
            return account;
          }
          if (options && "client" in options) {
            const { autoConnectWC } = await import("./controller-E2BI32O3.js");
            const [connectedAccount, connectedChain, doDisconnect, doSwitchChain] = await autoConnectWC(options, emitter, wallet.id, webLocalStorage, sessionHandler);
            account = connectedAccount;
            chain = connectedChain;
            handleDisconnect = doDisconnect;
            handleSwitchChain = doSwitchChain;
            trackConnect({
              client: options.client,
              walletType: id,
              walletAddress: account.address,
              chainId: chain.id
            });
            return account;
          }
          throw new Error("Failed to auto connect");
        },
        connect: async (options) => {
          async function wcConnect(wcOptions) {
            const { connectWC } = await import("./controller-E2BI32O3.js");
            const [connectedAccount, connectedChain, doDisconnect, doSwitchChain] = await connectWC(wcOptions, emitter, wallet.id, webLocalStorage, sessionHandler);
            account = connectedAccount;
            chain = connectedChain;
            handleDisconnect = doDisconnect;
            handleSwitchChain = doSwitchChain;
            trackConnect({
              client: wcOptions.client,
              walletType: id,
              walletAddress: account.address,
              chainId: chain.id
            });
            return account;
          }
          if (id === "walletConnect") {
            const { client, chain: _chain, ...walletConnectOptions } = options;
            return wcConnect({
              client,
              chain: _chain,
              walletConnect: {
                ...walletConnectOptions
              }
            });
          }
          const forceWalletConnectOption = options && "walletConnect" in options;
          const { injectedProvider } = await import("./mipdStore-M3CZRW25.js");
          if (injectedProvider(id) && !forceWalletConnectOption) {
            const { connectEip1193Wallet } = await import("./injected-U2HKS4LU.js");
            const [connectedAccount, connectedChain, doDisconnect, doSwitchChain] = await connectEip1193Wallet({
              id,
              provider: getInjectedProvider(id),
              client: options.client,
              chain: options.chain,
              emitter
            });
            account = connectedAccount;
            chain = connectedChain;
            handleDisconnect = doDisconnect;
            handleSwitchChain = doSwitchChain;
            unsubscribeChain = emitter.subscribe("chainChanged", (newChain) => {
              chain = newChain;
            });
            trackConnect({
              client: options.client,
              walletType: id,
              walletAddress: account.address,
              chainId: chain.id
            });
            return account;
          }
          if (options && "client" in options) {
            return wcConnect(options);
          }
          throw new Error("Failed to connect");
        },
        // these get overridden in connect and autoConnect
        disconnect: async () => {
          reset();
          await handleDisconnect();
        },
        switchChain: (c) => handleSwitchChain(c)
      };
      return wallet;
    }
  }
}
function walletConnect() {
  return createWallet("walletConnect");
}

export {
  isAndroid,
  isIOS,
  isMobile,
  openWindow,
  ecosystemWallet,
  inAppWallet,
  smartWallet,
  createWallet,
  walletConnect
};
//# sourceMappingURL=chunk-GTBRFTOM.js.map
