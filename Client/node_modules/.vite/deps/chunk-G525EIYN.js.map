{
  "version": 3,
  "sources": ["../../thirdweb/src/rpc/fetch-rpc.ts", "../../thirdweb/src/rpc/rpc.ts"],
  "sourcesContent": ["import type { ThirdwebClient } from \"../client/client.js\";\nimport { getClientFetch } from \"../utils/fetch.js\";\nimport { stringify } from \"../utils/json.js\";\n\nexport type RpcRequest = {\n  jsonrpc?: \"2.0\";\n  method: string;\n  params?: unknown;\n  id?: number;\n};\n\ntype FetchRpcOptions = {\n  requests: RpcRequest[];\n  requestTimeoutMs?: number;\n};\n\ntype SuccessResult<T> = {\n  method?: never;\n  result: T;\n  error?: never;\n};\ntype ErrorResult<T> = {\n  method?: never;\n  result?: never;\n  error: T;\n};\ntype Subscription<TResult, TError> = {\n  method: \"eth_subscription\";\n  error?: never;\n  result?: never;\n  params: {\n    subscription: string;\n  } & (\n    | {\n        result: TResult;\n        error?: never;\n      }\n    | {\n        result?: never;\n        error: TError;\n      }\n  );\n};\n\ntype RpcResponse<TResult = unknown, TError = unknown> = {\n  jsonrpc: `${number}`;\n  id: number;\n} & (\n  | SuccessResult<TResult>\n  | ErrorResult<TError>\n  | Subscription<TResult, TError>\n);\n\n/**\n * @internal\n */\nexport async function fetchRpc(\n  rpcUrl: string,\n  client: ThirdwebClient,\n  options: FetchRpcOptions,\n): Promise<RpcResponse[]> {\n  const response = await getClientFetch(client)(rpcUrl, {\n    headers: {\n      ...client.config?.rpc?.fetch?.headers,\n      \"Content-Type\": \"application/json\",\n    },\n    body: stringify(options.requests),\n    method: \"POST\",\n    requestTimeoutMs:\n      options.requestTimeoutMs ?? client.config?.rpc?.fetch?.requestTimeoutMs,\n    keepalive: client.config?.rpc?.fetch?.keepalive,\n  });\n\n  if (!response.ok) {\n    const error = await response.text().catch(() => null);\n    throw new Error(\n      `RPC request failed with status ${response.status} - ${response.statusText}: ${error || \"unknown error\"}`,\n    );\n  }\n\n  return await response.json();\n}\n\ntype FetchSingleRpcOptions = {\n  request: RpcRequest;\n  requestTimeoutMs?: number;\n};\n\n/**\n * @internal\n */\nexport async function fetchSingleRpc(\n  rpcUrl: string,\n  client: ThirdwebClient,\n  options: FetchSingleRpcOptions,\n): Promise<RpcResponse> {\n  const response = await getClientFetch(client)(rpcUrl, {\n    headers: {\n      ...(client.config?.rpc?.fetch?.headers || {}),\n      \"Content-Type\": \"application/json\",\n    },\n    body: stringify(options.request),\n    method: \"POST\",\n    requestTimeoutMs:\n      options.requestTimeoutMs ?? client.config?.rpc?.fetch?.requestTimeoutMs,\n    keepalive: client.config?.rpc?.fetch?.keepalive,\n  });\n\n  if (!response.ok) {\n    const error = await response.text().catch(() => null);\n    throw new Error(\n      `RPC request failed with status ${response.status} - ${response.statusText}: ${error || \"unknown error\"}`,\n    );\n  }\n  return await response.json();\n}\n", "import type { EIP1193RequestFn, EIP1474Methods } from \"viem\";\nimport type { ThirdwebClient } from \"../client/client.js\";\n\nimport type { Chain } from \"../chains/types.js\";\nimport { getRpcUrlForChain } from \"../chains/utils.js\";\nimport { stringify } from \"../utils/json.js\";\nimport { type RpcRequest, fetchRpc, fetchSingleRpc } from \"./fetch-rpc.js\";\n\nconst RPC_CLIENT_MAP = new WeakMap();\n\n/**\n * @internal\n */\nfunction getRpcClientMap(client: ThirdwebClient) {\n  if (RPC_CLIENT_MAP.has(client)) {\n    return RPC_CLIENT_MAP.get(client);\n  }\n  const rpcClientMap = new Map();\n  RPC_CLIENT_MAP.set(client, rpcClientMap);\n  return rpcClientMap;\n}\n\n/**\n * @internal\n */\nfunction rpcRequestKey(request: RpcRequest): string {\n  return `${request.method}:${stringify(request.params)}`;\n}\n\nconst DEFAULT_MAX_BATCH_SIZE = 100;\n// default to no timeout (next tick)\nconst DEFAULT_BATCH_TIMEOUT_MS = 0;\n\ntype RPCOptions = Readonly<{\n  client: ThirdwebClient;\n  chain: Chain;\n  config?: {\n    maxBatchSize?: number;\n    batchTimeoutMs?: number;\n    requestTimeoutMs?: number;\n  };\n}>;\n\n/**\n * Returns an RPC request that can be used to make JSON-RPC requests.\n * @param options - The RPC options.\n * @returns The RPC request function.\n * @rpc\n * @example\n * ```ts\n * import { createThirdwebClient } from \"thirdweb\";\n * import { getRpcClient } from \"thirdweb/rpc\";\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const rpcRequest = getRpcClient({ client, chain: ethereum, });\n * const blockNumber = await rpcRequest({\n *  method: \"eth_blockNumber\",\n * });\n * ```\n */\nexport function getRpcClient(\n  options: RPCOptions,\n): EIP1193RequestFn<EIP1474Methods> {\n  const rpcClientMap = getRpcClientMap(options.client);\n  const rpcUrl = options.chain.rpc;\n\n  if (rpcClientMap.has(rpcUrl)) {\n    return rpcClientMap.get(rpcUrl) as EIP1193RequestFn<EIP1474Methods>;\n  }\n\n  const rpcClient: EIP1193RequestFn<EIP1474Methods> = (() => {\n    // we can do this upfront because it cannot change later\n    const rpcUrl = getRpcUrlForChain({\n      client: options.client,\n      chain: options.chain,\n    });\n\n    const batchSize =\n      // look at the direct options passed\n      options.config?.maxBatchSize ??\n      // look at the client options\n      options.client.config?.rpc?.maxBatchSize ??\n      // use defaults\n      DEFAULT_MAX_BATCH_SIZE;\n    const batchTimeoutMs =\n      // look at the direct options passed\n      options.config?.batchTimeoutMs ??\n      // look at the client options\n      options.client.config?.rpc?.batchTimeoutMs ??\n      DEFAULT_BATCH_TIMEOUT_MS;\n\n    // inflight requests\n    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n    const inflightRequests = new Map<string, Promise<any>>();\n\n    let pendingBatch: Array<{\n      request: {\n        method: string;\n        params: unknown[];\n        id: number;\n        jsonrpc: \"2.0\";\n      };\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      resolve: (value: any) => void;\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      reject: (reason?: any) => void;\n      requestKey: string;\n    }> = [];\n    let pendingBatchTimeout: ReturnType<typeof setTimeout> | null = null;\n\n    /**\n     * Sends the pending batch of requests.\n     * @internal\n     */\n    function sendPendingBatch() {\n      // clear the timeout if any\n      if (pendingBatchTimeout) {\n        clearTimeout(pendingBatchTimeout);\n        pendingBatchTimeout = null;\n      }\n\n      // prepare the requests array (we know the size)\n      const requests = new Array(pendingBatch.length);\n      const activeBatch = pendingBatch.slice().map((inflight, index) => {\n        // assign the id to the request\n        inflight.request.id = index;\n        // also assign the jsonrpc version\n        inflight.request.jsonrpc = \"2.0\";\n        // assing the request to the requests array (so we don't have to map it again later)\n        requests[index] = inflight.request;\n        return inflight;\n      });\n      // reset pendingBatch to empty\n      pendingBatch = [];\n\n      fetchRpc(rpcUrl, options.client, {\n        requests,\n        requestTimeoutMs: options.config?.requestTimeoutMs,\n      })\n        .then((responses) => {\n          activeBatch.forEach((inflight, index) => {\n            // Handle the inflight request promise for each response.\n            const response = responses[index];\n\n            // No response.\n            if (!response) {\n              inflight.reject(\n                new Error(\n                  `No response for index ${index} - all responses: ${stringify(responses)}`,\n                ),\n              );\n            }\n            // Response is an error or error string.\n            else if (response instanceof Error) {\n              inflight.reject(response);\n            } else if (\"error\" in response) {\n              inflight.reject(response.error);\n            } else if (typeof response === \"string\") {\n              inflight.reject(new Error(response));\n            }\n            // eth_subscription is not supported yet.\n            else if (response.method === \"eth_subscription\") {\n              inflight.reject(\"Subscriptions not supported yet\");\n            }\n            // Else return the successful response for the inflight request.\n            else {\n              inflight.resolve(response.result);\n            }\n          });\n        })\n        .catch((err) => {\n          // http call failed, reject all inflight requests\n          for (const inflight of activeBatch) {\n            inflight.reject(err);\n          }\n        })\n        .finally(() => {\n          // Clear the inflight requests map so any new requests are re-fetched.\n          inflightRequests.clear();\n        });\n    }\n\n    // shortcut everything if we do not need to batch\n    if (batchSize === 1) {\n      return async (request) => {\n        // we can hard-code the id and jsonrpc version\n        // we also mutate the request object here to avoid copying it\n        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n        (request as any).id = 1;\n        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n        (request as any).jsonrpc = \"2.0\";\n        const rpcResponse = await fetchSingleRpc(rpcUrl, options.client, {\n          request: request,\n          requestTimeoutMs: options.config?.requestTimeoutMs,\n        });\n\n        if (!rpcResponse) {\n          throw new Error(\"No response\");\n        }\n        if (\"error\" in rpcResponse) {\n          throw rpcResponse.error;\n        }\n        return rpcResponse.result;\n      };\n    }\n\n    return async (request) => {\n      const requestKey = rpcRequestKey(request);\n\n      // if the request for this key is already inflight, return the promise directly\n      if (inflightRequests.has(requestKey)) {\n        // biome-ignore lint/style/noNonNullAssertion: the `has` check ensures this is defined\n        return inflightRequests.get(requestKey)!;\n      }\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      let resolve: (value: any) => void;\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      let reject: (reason?: any) => void;\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      const promise = new Promise<any>((resolve_, reject_) => {\n        resolve = resolve_;\n        reject = reject_;\n      });\n      inflightRequests.set(requestKey, promise);\n      // @ts-expect-error - they *are* definitely assigned within the promise constructor\n      pendingBatch.push({ request, resolve, reject, requestKey });\n      if (batchSize > 1) {\n        // if there is no timeout, set one\n        if (!pendingBatchTimeout) {\n          pendingBatchTimeout = setTimeout(sendPendingBatch, batchTimeoutMs);\n        }\n        // if the batch is full, send it\n        if (pendingBatch.length >= batchSize) {\n          sendPendingBatch();\n        }\n      } else {\n        sendPendingBatch();\n      }\n      return promise;\n    };\n  })();\n\n  rpcClientMap.set(rpcUrl, rpcClient);\n  return rpcClient as EIP1193RequestFn<EIP1474Methods>;\n}\n"],
  "mappings": "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",
  "names": ["rpcUrl", "_a"]
}
