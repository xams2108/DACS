import {
  autoConnectCore,
  createConnectionManager
} from "./chunk-I2O4VMV5.js";
import {
  getDefaultWallets
} from "./chunk-JLR3BWY4.js";
import {
  DefaultWalletConnectRequestHandlers,
  createWalletConnectClient,
  createWalletConnectSession,
  disconnectWalletConnectSession,
  getActiveWalletConnectSessions
} from "./chunk-ZEL44S35.js";
import "./chunk-EZUWWPN5.js";
import "./chunk-YNPP523H.js";
import {
  createWallet,
  ecosystemWallet,
  inAppWallet,
  smartWallet,
  walletConnect
} from "./chunk-GTBRFTOM.js";
import {
  getWalletBalance
} from "./chunk-44S5YASJ.js";
import {
  authenticate,
  authenticateWithRedirect,
  getProfiles,
  getUserEmail,
  getUserPhoneNumber,
  linkProfile,
  preAuthenticate,
  unlinkProfile
} from "./chunk-2WGYGS5D.js";
import {
  createWalletEmitter,
  trackConnect
} from "./chunk-NXASE243.js";
import "./chunk-WX53EMW6.js";
import "./chunk-TJPCO3UF.js";
import "./chunk-NCVQ56IM.js";
import "./chunk-67YIWUOQ.js";
import {
  getWalletInfo
} from "./chunk-ZURXGIGP.js";
import "./chunk-COI5HHKB.js";
import "./chunk-FUPOJN5U.js";
import "./chunk-FUW7UPWG.js";
import {
  webLocalStorage
} from "./chunk-G4H2UJKK.js";
import {
  autoConnectEip1193Wallet,
  connectEip1193Wallet
} from "./chunk-FB5IB3WF.js";
import {
  getInstalledWalletProviders,
  injectedProvider
} from "./chunk-NHH5L32Z.js";
import "./chunk-GUO62LYV.js";
import "./chunk-L3Z4K7ZC.js";
import "./chunk-W7P5OTWM.js";
import "./chunk-NACC2RRT.js";
import "./chunk-7FLBYZ2C.js";
import "./chunk-CMLY7B67.js";
import "./chunk-57BDDLER.js";
import "./chunk-Z3FY5SMY.js";
import "./chunk-LZH3KM55.js";
import "./chunk-Y3VUZTEO.js";
import "./chunk-QLVERXU5.js";
import "./chunk-OYHMC3VW.js";
import "./chunk-LWBFBP2R.js";
import {
  getUser,
  randomPrivateKey,
  sign,
  signTransaction
} from "./chunk-KS66USJV.js";
import {
  deploySmartAccount
} from "./chunk-W7QYMD5Y.js";
import {
  from as from2,
  getSignPayload as getSignPayload2
} from "./chunk-3CCNHYRS.js";
import {
  secp256k1,
  toHex as toHex2
} from "./chunk-AYP3M5MU.js";
import "./chunk-V2G6ITXO.js";
import "./chunk-BQJGA3C2.js";
import "./chunk-YCZ3YGMG.js";
import {
  sendTransaction
} from "./chunk-6HYR3QZE.js";
import "./chunk-NGHGMRK7.js";
import "./chunk-U7S6ZRSH.js";
import "./chunk-SYWNRZTI.js";
import "./chunk-7SULNGZP.js";
import "./chunk-F5UXFDUH.js";
import {
  eth_sendRawTransaction
} from "./chunk-CMXLKATA.js";
import "./chunk-DI3CVITR.js";
import "./chunk-ZVVOIXUB.js";
import {
  prepareTransaction
} from "./chunk-QGXAPRFG.js";
import "./chunk-XRZYIZWV.js";
import "./chunk-2E7WBB45.js";
import "./chunk-MUHOVHES.js";
import "./chunk-T2PB4DNK.js";
import "./chunk-XEGQIGX5.js";
import {
  estimateGas
} from "./chunk-AQF7QQD3.js";
import "./chunk-3TGJ2UPP.js";
import "./chunk-6DSBI7IJ.js";
import "./chunk-6KK2ZA3Q.js";
import {
  publicKeyToAddress
} from "./chunk-QEOWYB53.js";
import "./chunk-UZ6XBB6C.js";
import "./chunk-U373M5NZ.js";
import "./chunk-IOJX74IG.js";
import {
  getRpcClient
} from "./chunk-G525EIYN.js";
import "./chunk-HAADYJEF.js";
import "./chunk-DZNHJFU5.js";
import "./chunk-PH3VXGO4.js";
import {
  getSignPayload
} from "./chunk-FAVNHT4B.js";
import {
  keccak256
} from "./chunk-QIKOD3PZ.js";
import "./chunk-V4DR3IRU.js";
import "./chunk-HXWRQBIO.js";
import "./chunk-2CIJO3V3.js";
import "./chunk-OFBDYQC5.js";
import "./chunk-OC3SQ5HK.js";
import {
  getAddress
} from "./chunk-3VPP7LG4.js";
import "./chunk-2LSBKOGS.js";
import {
  hexToNumber,
  isHex,
  toHex
} from "./chunk-7OW24QWY.js";
import {
  concat2 as concat,
  from2 as from,
  fromNumber2 as fromNumber,
  fromString2 as fromString,
  size2 as size,
  toNumber2 as toNumber
} from "./chunk-O2PTR6DB.js";
import "./chunk-SQPSG2HH.js";
import "./chunk-IWKIGZF6.js";
import {
  getCachedChain,
  getCachedChainIfExists
} from "./chunk-6OSAHK2J.js";
import "./chunk-MTFDOOBS.js";
import "./chunk-Q3BUNRF4.js";
import "./chunk-3OXDSLPJ.js";
import "./chunk-5UJ7PIRT.js";
import "./chunk-PPP72TBL.js";
import {
  __export
} from "./chunk-OS7ZSSJM.js";

// node_modules/ox/_esm/core/PersonalMessage.js
function encode(data) {
  const message = from(data);
  return concat(
    // Personal Sign Format: `0x19 ‖ "Ethereum Signed Message:\n" ‖ message.length ‖ message`
    "0x19",
    fromString("Ethereum Signed Message:\n" + size(message)),
    message
  );
}
function getSignPayload3(data) {
  return keccak256(encode(data));
}

// node_modules/thirdweb/dist/esm/utils/signatures/sign-message.js
function signMessage(options) {
  if ("privateKey" in options) {
    const payload = getSignPayload3(typeof options.message === "object" ? options.message.raw : fromString(options.message));
    const signature = sign({
      payload,
      privateKey: options.privateKey
    });
    return toHex2(signature);
  }
  if ("account" in options) {
    const { message, account } = options;
    return account.signMessage({ message });
  }
  throw new Error("Either privateKey or account is required");
}

// node_modules/thirdweb/dist/esm/utils/signatures/sign-typed-data.js
function signTypedData(options) {
  var _a;
  const { privateKey, ...typedData } = options;
  if (typeof ((_a = typedData.domain) == null ? void 0 : _a.chainId) === "string") {
    typedData.domain.chainId = toNumber(typedData.domain.chainId);
  }
  const payload = getSignPayload(typedData);
  const signature = sign({
    payload,
    privateKey
  });
  return toHex2(signature);
}

// node_modules/thirdweb/dist/esm/wallets/private-key.js
function privateKeyToAccount(options) {
  const { client } = options;
  const privateKey = `0x${options.privateKey.replace(/^0x/, "")}`;
  const publicKey = toHex(secp256k1.getPublicKey(privateKey.slice(2), false));
  const address = publicKeyToAddress(publicKey);
  const account = {
    address: getAddress(address),
    sendTransaction: async (tx) => {
      const rpcRequest = getRpcClient({
        client,
        chain: getCachedChain(tx.chainId)
      });
      const signedTx = signTransaction({
        transaction: tx,
        privateKey
      });
      const transactionHash = await eth_sendRawTransaction(rpcRequest, signedTx);
      return {
        transactionHash
      };
    },
    signMessage: async ({ message }) => {
      return signMessage({
        message,
        privateKey
      });
    },
    signTypedData: async (_typedData) => {
      return signTypedData({
        ..._typedData,
        privateKey
      });
    },
    signTransaction: async (tx) => {
      return signTransaction({
        transaction: tx,
        privateKey
      });
    },
    signAuthorization: async (authorization) => {
      const signature = sign({
        payload: getSignPayload2(authorization),
        privateKey
      });
      return from2(authorization, { signature });
    }
  };
  return account;
}

// node_modules/thirdweb/dist/esm/wallets/utils/generateAccount.js
async function generateAccount(options) {
  const privateKey = toHex(secp256k1.utils.randomPrivateKey());
  return privateKeyToAccount({ privateKey, client: options.client });
}

// node_modules/thirdweb/dist/esm/wallets/getAllWalletsList.js
async function getAllWalletsList() {
  return (await import("./wallet-infos-XTFB74RB.js")).default;
}

// node_modules/thirdweb/dist/esm/adapters/wallet-adapter.js
function createWalletAdapter(options) {
  const emitter = createWalletEmitter();
  let _chain = options.chain;
  return {
    id: "adapter",
    subscribe: emitter.subscribe,
    connect: async () => {
      emitter.emit("onConnect", options);
      return options.adaptedAccount;
    },
    autoConnect: async () => {
      emitter.emit("onConnect", options);
      return options.adaptedAccount;
    },
    disconnect: async () => {
      await options.onDisconnect();
      emitter.emit("disconnect", void 0);
    },
    getAccount() {
      return options.adaptedAccount;
    },
    getChain() {
      const cachedChain = getCachedChainIfExists(_chain.id);
      _chain = cachedChain || _chain;
      return _chain;
    },
    getConfig() {
      return options;
    },
    switchChain: async (chain) => {
      await options.switchChain(chain);
      _chain = chain;
      emitter.emit("chainChanged", chain);
    }
  };
}

// node_modules/thirdweb/dist/esm/adapters/eip1193/index.js
var eip1193_exports = {};
__export(eip1193_exports, {
  fromProvider: () => fromProvider,
  toProvider: () => toProvider
});

// node_modules/thirdweb/dist/esm/adapters/eip1193/from-eip1193.js
function fromProvider(options) {
  const id = options.walletId ?? "adapter";
  const emitter = createWalletEmitter();
  let account = void 0;
  let chain = void 0;
  let provider = void 0;
  const getProvider = async (params) => {
    provider = typeof options.provider === "function" ? await options.provider(params) : options.provider;
    return provider;
  };
  const unsubscribeChain = emitter.subscribe("chainChanged", (newChain) => {
    chain = newChain;
  });
  function reset() {
    account = void 0;
    chain = void 0;
  }
  let handleDisconnect = async () => {
  };
  const unsubscribeDisconnect = emitter.subscribe("disconnect", () => {
    reset();
    unsubscribeChain();
    unsubscribeDisconnect();
  });
  emitter.subscribe("accountChanged", (_account) => {
    account = _account;
  });
  let handleSwitchChain = async (c) => {
    await (provider == null ? void 0 : provider.request({
      method: "wallet_switchEthereumChain",
      params: [{ chainId: fromNumber(c.id) }]
    }));
  };
  return {
    id,
    subscribe: emitter.subscribe,
    getConfig: () => void 0,
    getChain() {
      if (!chain) {
        return void 0;
      }
      chain = getCachedChainIfExists(chain.id) || chain;
      return chain;
    },
    getAccount: () => account,
    connect: async (connectOptions) => {
      var _a;
      const [connectedAccount, connectedChain, doDisconnect, doSwitchChain] = await connectEip1193Wallet({
        id,
        provider: await getProvider({ chainId: (_a = connectOptions.chain) == null ? void 0 : _a.id }),
        client: connectOptions.client,
        chain: connectOptions.chain,
        emitter
      });
      account = connectedAccount;
      chain = connectedChain;
      handleDisconnect = doDisconnect;
      handleSwitchChain = doSwitchChain;
      emitter.emit("onConnect", connectOptions);
      trackConnect({
        client: connectOptions.client,
        walletType: id,
        walletAddress: account.address
      });
      return account;
    },
    autoConnect: async (connectOptions) => {
      var _a;
      const [connectedAccount, connectedChain, doDisconnect, doSwitchChain] = await autoConnectEip1193Wallet({
        id,
        provider: await getProvider({ chainId: (_a = connectOptions.chain) == null ? void 0 : _a.id }),
        emitter,
        chain: connectOptions.chain,
        client: connectOptions.client
      });
      account = connectedAccount;
      chain = connectedChain;
      handleDisconnect = doDisconnect;
      handleSwitchChain = doSwitchChain;
      emitter.emit("onConnect", connectOptions);
      trackConnect({
        client: connectOptions.client,
        walletType: id,
        walletAddress: account.address
      });
      return account;
    },
    disconnect: async () => {
      reset();
      await handleDisconnect();
      emitter.emit("disconnect", void 0);
    },
    switchChain: async (c) => {
      await handleSwitchChain(c);
      emitter.emit("chainChanged", c);
    }
  };
}

// node_modules/thirdweb/dist/esm/adapters/eip1193/to-eip1193.js
function toProvider(options) {
  const { chain, client, wallet, connectOverride } = options;
  const rpcClient = getRpcClient({ client, chain });
  return {
    on: wallet.subscribe,
    removeListener: () => {
    },
    request: async (request) => {
      if (request.method === "eth_sendTransaction") {
        const account = wallet.getAccount();
        if (!account) {
          throw new Error("Account not connected");
        }
        const result = await sendTransaction({
          transaction: prepareTransaction({
            ...request.params[0],
            chain,
            client
          }),
          account
        });
        return result.transactionHash;
      }
      if (request.method === "eth_estimateGas") {
        const account = wallet.getAccount();
        if (!account) {
          throw new Error("Account not connected");
        }
        return estimateGas({
          transaction: prepareTransaction({
            ...request.params[0],
            chain,
            client
          }),
          account
        });
      }
      if (request.method === "personal_sign") {
        const account = wallet.getAccount();
        if (!account) {
          throw new Error("Account not connected");
        }
        return account.signMessage({
          message: {
            raw: request.params[0]
          }
        });
      }
      if (request.method === "eth_signTypedData_v4") {
        const account = wallet.getAccount();
        if (!account) {
          throw new Error("Account not connected");
        }
        const data = JSON.parse(request.params[1]);
        return account.signTypedData(data);
      }
      if (request.method === "eth_accounts") {
        const account = wallet.getAccount();
        if (!account) {
          throw new Error("Account not connected");
        }
        return [account.address];
      }
      if (request.method === "eth_requestAccounts") {
        const account = connectOverride ? await connectOverride(wallet) : await wallet.connect({
          client
        });
        if (!account) {
          throw new Error("Unable to connect wallet");
        }
        return [account.address];
      }
      if (request.method === "wallet_switchEthereumChain" || request.method === "wallet_addEthereumChain") {
        const data = request.params[0];
        const chainIdHex = data.chainId;
        if (!chainIdHex) {
          throw new Error("Chain ID is required");
        }
        const chainId = isHex(chainIdHex) ? hexToNumber(chainIdHex) : chainIdHex;
        const chain2 = getCachedChain(chainId);
        return wallet.switchChain(chain2);
      }
      return rpcClient(request);
    }
  };
}

// node_modules/thirdweb/dist/esm/wallets/connection/autoConnect.js
async function autoConnect(props) {
  const wallets = props.wallets || getDefaultWallets(props);
  const manager = createConnectionManager(webLocalStorage);
  const result = await autoConnectCore({
    storage: webLocalStorage,
    props: {
      ...props,
      wallets
    },
    createWalletFn: createWallet,
    getInstalledWallets: () => {
      const specifiedWalletIds = new Set(wallets.map((x) => x.id));
      const installedWallets = getInstalledWalletProviders().filter((x) => !specifiedWalletIds.has(x.info.rdns)).map((x) => createWallet(x.info.rdns));
      return installedWallets;
    },
    manager
  });
  return result;
}
export {
  DefaultWalletConnectRequestHandlers,
  eip1193_exports as EIP1193,
  authenticate,
  authenticateWithRedirect,
  autoConnect,
  createWallet,
  createWalletAdapter,
  createWalletConnectClient,
  createWalletConnectSession,
  deploySmartAccount,
  disconnectWalletConnectSession,
  ecosystemWallet,
  inAppWallet as embeddedWallet,
  generateAccount,
  getActiveWalletConnectSessions,
  getAllWalletsList,
  getProfiles,
  getUser,
  getUserEmail,
  getUserPhoneNumber,
  getWalletBalance,
  getWalletInfo,
  inAppWallet,
  injectedProvider,
  linkProfile,
  preAuthenticate,
  privateKeyToAccount as privateKeyAccount,
  privateKeyToAccount,
  randomPrivateKey,
  smartWallet,
  unlinkProfile,
  walletConnect
};
//# sourceMappingURL=thirdweb_wallets.js.map
